<!DOCTYPE html>

<html>
<head>
  <title>verb.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>verb.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">"use strict"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>browser context</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> exports != <span class="hljs-string">'object'</span> || exports === <span class="hljs-literal">undefined</span> )  
{
	<span class="hljs-keyword">var</span> verb = {}
		, numeric = <span class="hljs-built_in">window</span>.numeric
		, binomial = <span class="hljs-built_in">window</span>.binomial
		, labor = <span class="hljs-built_in">window</span>.labor;
} <span class="hljs-keyword">else</span>  {
	<span class="hljs-keyword">var</span> verb = <span class="hljs-built_in">module</span>.exports = {}
		, numeric = <span class="hljs-built_in">require</span>(<span class="hljs-string">'numeric'</span>)
		, binomial = <span class="hljs-built_in">require</span>(<span class="hljs-string">'binomial'</span>)
		, labor = <span class="hljs-built_in">require</span>(<span class="hljs-string">'labor'</span>);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Initialize the verb namespace objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb = verb || {};
verb = verb || {};
verb.eval = verb.eval || {};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h4 id="verb-epsilon">verb.EPSILON</h4>
<p>Used for numeric comparisons</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.EPSILON = <span class="hljs-number">1e-10</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h4 id="verb-tolerance">verb.TOLERANCE</h4>
<p>Default tolerance for geometric operations - defines “close enough” 
for tesselation, intersection, and more</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.TOLERANCE = <span class="hljs-number">1e-6</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h4 id="init-">init()</h4>
<p>Start a default Engine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.init = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
	verb.nurbsEngine = <span class="hljs-keyword">new</span> verb.Engine( verb.eval );
	verb.NurbsGeometry.prototype.nurbsEngine = verb.nurbsEngine;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h4 id="douglas-crockford-s-method-">Douglas Crockford’s “method”</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">Function</span>.prototype.method = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, func)</span> </span>{
    <span class="hljs-keyword">this</span>.prototype[name] = func;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h4 id="douglas-crockford-s-inherits-">Douglas Crockford’s “inherits”</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">Function</span>.method(<span class="hljs-string">'inherits'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(parent)</span> </span>{
    <span class="hljs-keyword">this</span>.prototype = <span class="hljs-keyword">new</span> parent();
    <span class="hljs-keyword">var</span> d = {}, 
        p = <span class="hljs-keyword">this</span>.prototype;
    <span class="hljs-keyword">this</span>.prototype.constructor = parent; 
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
});</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h4 id="array-flatten-">Array.flatten()</h4>
<p>Collapse a multidimensional arrays to a 1d</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">Array</span>.prototype.flatten = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];

	<span class="hljs-keyword">var</span> merged = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++){
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[i] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>){
			merged = merged.concat( <span class="hljs-keyword">this</span>[i].flatten() );
		} <span class="hljs-keyword">else</span> {
			merged = merged.concat( <span class="hljs-keyword">this</span>[i] );
		}
	}

	<span class="hljs-keyword">return</span> merged;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h4 id="numeric-normalized-arr-">numeric.normalized( arr )</h4>
<p>Extend numeric to obtain the normalized version of an array</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Array of numbers</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, The array after normalization</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
numeric.normalized = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arr)</span></span>{

	<span class="hljs-keyword">return</span> numeric.div( arr, numeric.norm2(arr) );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h4 id="numeric-cross-u-v-">numeric.cross( u, v )</h4>
<p>Extend numeric to form the cross product between two length 3 arrays</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array of numbers</li>
<li><em>Array</em>, Length 3 array of numbers</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, The length 3 array cross product</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>numeric.cross = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(u, v)</span></span>{

	<span class="hljs-keyword">return</span> [u[<span class="hljs-number">1</span>]*v[<span class="hljs-number">2</span>]-u[<span class="hljs-number">2</span>]*v[<span class="hljs-number">1</span>],u[<span class="hljs-number">2</span>]*v[<span class="hljs-number">0</span>]-u[<span class="hljs-number">0</span>]*v[<span class="hljs-number">2</span>],u[<span class="hljs-number">0</span>]*v[<span class="hljs-number">1</span>]-u[<span class="hljs-number">1</span>]*v[<span class="hljs-number">0</span>]];

}</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h4 id="left-arr-">left(arr)</h4>
<p>Get the first half of an array including the pivot</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of stuff</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, the left half</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.left = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arr)</span></span>{ 
	<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">var</span> len = <span class="hljs-built_in">Math</span>.ceil( arr.length / <span class="hljs-number">2</span> ); 
	<span class="hljs-keyword">return</span> arr.slice( <span class="hljs-number">0</span>, len );
}</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <h4 id="right-arr-">right(arr)</h4>
<p>Get the second half of an array, not including the pivot</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of stuff</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, the right half</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.right = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arr)</span></span>{
	<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">var</span> len = <span class="hljs-built_in">Math</span>.ceil( arr.length / <span class="hljs-number">2</span> );
	<span class="hljs-keyword">return</span> arr.slice( len );
}</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h4 id="last-arr-">last(arr)</h4>
<p>Get the last element of an array</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of stuff</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Something</em>, the last element of the array</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.last = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arr)</span></span>{

	<span class="hljs-keyword">if</span> (!arr.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;

	<span class="hljs-keyword">return</span> arr[arr.length-<span class="hljs-number">1</span>];
}</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h4 id="rightwithpivot-arr-">rightWithPivot(arr)</h4>
<p>Get the second half of an array including the pivot</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of stuff</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, the right half</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.rightWithPivot = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arr)</span></span>{
	<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">var</span> len = <span class="hljs-built_in">Math</span>.ceil( arr.length / <span class="hljs-number">2</span> );
	<span class="hljs-keyword">return</span> arr.slice( len-<span class="hljs-number">1</span> );
}</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <h4 id="unique-arr-comparator-">unique(arr, comparator)</h4>
<p>Obtain the unique set of elements in an array</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of stuff</li>
<li><em>Function</em>, a function that receives two arguments (two objects from the array).  Returning true indicates
the objects are equal.  </li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, array of unique elements</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.unique = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( arr, comp )</span></span>{

	<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];

	<span class="hljs-keyword">var</span> uniques = [ arr.pop() ];

	<span class="hljs-keyword">while</span> (arr.length &gt; <span class="hljs-number">0</span>){

		<span class="hljs-keyword">var</span> ele = arr.pop();
		<span class="hljs-keyword">var</span> isUnique = <span class="hljs-literal">true</span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; uniques.length; j++ ){
			<span class="hljs-keyword">if</span> ( comp( ele, uniques[j] ) ){
				isUnique = <span class="hljs-literal">false</span>;
				<span class="hljs-keyword">break</span>;
			}
		}

		<span class="hljs-keyword">if</span> ( isUnique ){
			uniques.push( ele );
		}

	}

	<span class="hljs-keyword">return</span> uniques;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <h4 id="iszero-vector-">isZero(vector)</h4>
<p>Determine if a vector is of zero length with
no multiplies and no square roots</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, vector</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Boolean</em>, range array</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.isZero = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( vec )</span></span>{

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = vec.length; i &lt; l; i++){
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs( vec[i] ) &gt; verb.TOLERANCE ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <h4 id="range-start-stop-step-">range(start, stop, step)</h4>
<p>Obtain a range of numbers</p>
<p>Borrowed from underscore.js port of the python function
of the same name</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, start point</li>
<li><em>Number</em>, end point </li>
<li><em>Number</em>, step</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, range array</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.range = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(start, stop, step)</span> </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &lt;= <span class="hljs-number">1</span>) {
    stop = start || <span class="hljs-number">0</span>;
    start = <span class="hljs-number">0</span>;
  }
  step = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>] || <span class="hljs-number">1</span>;

  <span class="hljs-keyword">var</span> len = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.ceil((stop - start) / step), <span class="hljs-number">0</span>);
  <span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> range = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);

  <span class="hljs-keyword">while</span>(idx &lt; len) {
    range[idx++] = start;
    start += step;
  }

  <span class="hljs-keyword">return</span> range;
};

 <span class="hljs-comment">/**
 * AUTHOR OF INITIAL JS LIBRARY
 * k-d Tree JavaScript - V 1.0
 *
 * https://github.com/ubilabs/kd-tree-javascript
 *
 * @author Mircea Pricop &lt;pricop@ubilabs.net&gt;, 2012
 * @author Martin Kleppe &lt;kleppe@ubilabs.net&gt;, 2012
 * @author Ubilabs http://ubilabs.net, 2012
 * @license MIT License &lt;http://www.opensource.org/licenses/mit-license.php&gt;
 */</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span><span class="hljs-params">(obj, dimension, parent)</span> </span>{
  <span class="hljs-keyword">this</span>.obj = obj;
  <span class="hljs-keyword">this</span>.left = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.right = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.parent = parent;
  <span class="hljs-keyword">this</span>.dimension = dimension;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">KdTree</span><span class="hljs-params">(points, metric, dimensions)</span> </span>{

  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(points, depth, parent)</span> </span>{
    <span class="hljs-keyword">var</span> dim = depth % dimensions.length,
      median,
      node;

    <span class="hljs-keyword">if</span> (points.length === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
    <span class="hljs-keyword">if</span> (points.length === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node(points[<span class="hljs-number">0</span>], dim, parent);
    }

    points.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span> </span>{
      <span class="hljs-keyword">return</span> a[dimensions[dim]] - b[dimensions[dim]];
    });

    median = <span class="hljs-built_in">Math</span>.floor(points.length / <span class="hljs-number">2</span>);
    node = <span class="hljs-keyword">new</span> Node(points[median], dim, parent);
    node.left = buildTree(points.slice(<span class="hljs-number">0</span>, median), depth + <span class="hljs-number">1</span>, node);
    node.right = buildTree(points.slice(median + <span class="hljs-number">1</span>), depth + <span class="hljs-number">1</span>, node);

    <span class="hljs-keyword">return</span> node;
  }

  <span class="hljs-keyword">this</span>.root = buildTree(points, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);

  <span class="hljs-keyword">this</span>.insert = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(point)</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerSearch</span><span class="hljs-params">(node, parent)</span> </span>{

      <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> parent;
      }

      <span class="hljs-keyword">var</span> dimension = dimensions[node.dimension];
      <span class="hljs-keyword">if</span> (point[dimension] &lt; node.obj[dimension]) {
        <span class="hljs-keyword">return</span> innerSearch(node.left, node);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> innerSearch(node.right, node);
      }
    }

    <span class="hljs-keyword">var</span> insertPosition = innerSearch(<span class="hljs-keyword">this</span>.root, <span class="hljs-literal">null</span>),
      newNode,
      dimension;

    <span class="hljs-keyword">if</span> (insertPosition === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">this</span>.root = <span class="hljs-keyword">new</span> Node(point, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);
      <span class="hljs-keyword">return</span>;
    }

    newNode = <span class="hljs-keyword">new</span> Node(point, (insertPosition.dimension + <span class="hljs-number">1</span>) % dimensions.length, insertPosition);
    dimension = dimensions[insertPosition.dimension];

    <span class="hljs-keyword">if</span> (point[dimension] &lt; insertPosition.obj[dimension]) {
      insertPosition.left = newNode;
    } <span class="hljs-keyword">else</span> {
      insertPosition.right = newNode;
    }
  };

  <span class="hljs-keyword">this</span>.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(point)</span> </span>{
    <span class="hljs-keyword">var</span> node;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nodeSearch</span><span class="hljs-params">(node)</span> </span>{
      <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (node.obj === point) {
        <span class="hljs-keyword">return</span> node;
      }

      <span class="hljs-keyword">var</span> dimension = dimensions[node.dimension];

      <span class="hljs-keyword">if</span> (point[dimension] &lt; node.obj[dimension]) {
        <span class="hljs-keyword">return</span> nodeSearch(node.left, node);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> nodeSearch(node.right, node);
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(node)</span> </span>{
      <span class="hljs-keyword">var</span> nextNode,
        nextObj,
        pDimension;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findMax</span><span class="hljs-params">(node, dim)</span> </span>{
        <span class="hljs-keyword">var</span> dimension,
          own,
          left,
          right,
          max;

        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        dimension = dimensions[dim];
        <span class="hljs-keyword">if</span> (node.dimension === dim) {
          <span class="hljs-keyword">if</span> (node.right !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> findMax(node.right, dim);
          }
          <span class="hljs-keyword">return</span> node;
        }

        own = node.obj[dimension];
        left = findMax(node.left, dim);
        right = findMax(node.right, dim);
        max = node;

        <span class="hljs-keyword">if</span> (left !== <span class="hljs-literal">null</span> &amp;&amp; left.obj[dimension] &gt; own) {
          max = left;
        }

        <span class="hljs-keyword">if</span> (right !== <span class="hljs-literal">null</span> &amp;&amp; right.obj[dimension] &gt; max.obj[dimension]) {
          max = right;
        }
        <span class="hljs-keyword">return</span> max;
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findMin</span><span class="hljs-params">(node, dim)</span> </span>{
        <span class="hljs-keyword">var</span> dimension,
          own,
          left,
          right,
          min;

        <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        dimension = dimensions[dim];

        <span class="hljs-keyword">if</span> (node.dimension === dim) {
          <span class="hljs-keyword">if</span> (node.left !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> findMin(node.left, dim);
          }
          <span class="hljs-keyword">return</span> node;
        }

        own = node.obj[dimension];
        left = findMin(node.left, dim);
        right = findMin(node.right, dim);
        min = node;

        <span class="hljs-keyword">if</span> (left !== <span class="hljs-literal">null</span> &amp;&amp; left.obj[dimension] &lt; own) {
          min = left;
        }
        <span class="hljs-keyword">if</span> (right !== <span class="hljs-literal">null</span> &amp;&amp; right.obj[dimension] &lt; min.obj[dimension]) {
          min = right;
        }
        <span class="hljs-keyword">return</span> min;
      }

      <span class="hljs-keyword">if</span> (node.left === <span class="hljs-literal">null</span> &amp;&amp; node.right === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (node.parent === <span class="hljs-literal">null</span>) {
          self.root = <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">return</span>;
        }

        pDimension = dimensions[node.parent.dimension];

        <span class="hljs-keyword">if</span> (node.obj[pDimension] &lt; node.parent.obj[pDimension]) {
          node.parent.left = <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">else</span> {
          node.parent.right = <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (node.left !== <span class="hljs-literal">null</span>) {
        nextNode = findMax(node.left, node.dimension);
      } <span class="hljs-keyword">else</span> {
        nextNode = findMin(node.right, node.dimension);
      }

      nextObj = nextNode.obj;
      removeNode(nextNode);
      node.obj = nextObj;

    }

    node = nodeSearch(self.root);

    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) { <span class="hljs-keyword">return</span>; }

    removeNode(node);
  };

  <span class="hljs-keyword">this</span>.nearest = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(point, maxNodes, maxDistance)</span> </span>{
    <span class="hljs-keyword">var</span> i,
      result,
      bestNodes;

    bestNodes = <span class="hljs-keyword">new</span> BinaryHeap(
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> </span>{ <span class="hljs-keyword">return</span> -e[<span class="hljs-number">1</span>]; }
    );

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nearestSearch</span><span class="hljs-params">(node)</span> </span>{
      <span class="hljs-keyword">var</span> bestChild,
        dimension = dimensions[node.dimension],
        ownDistance = metric(point, node.obj),
        linearPoint = {},
        linearDistance,
        otherChild,
        i;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">saveNode</span><span class="hljs-params">(node, distance)</span> </span>{
        bestNodes.push([node, distance]);
        <span class="hljs-keyword">if</span> (bestNodes.size() &gt; maxNodes) {
          bestNodes.pop();
        }
      }

      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; dimensions.length; i += <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> (i === node.dimension) {
          linearPoint[dimensions[i]] = point[dimensions[i]];
        } <span class="hljs-keyword">else</span> {
          linearPoint[dimensions[i]] = node.obj[dimensions[i]];
        }
      }

      linearDistance = metric(linearPoint, node.obj);

      <span class="hljs-keyword">if</span> (node.right === <span class="hljs-literal">null</span> &amp;&amp; node.left === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (bestNodes.size() &lt; maxNodes || ownDistance &lt; bestNodes.peek()[<span class="hljs-number">1</span>]) {
          saveNode(node, ownDistance);
        }
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (node.right === <span class="hljs-literal">null</span>) {
        bestChild = node.left;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.left === <span class="hljs-literal">null</span>) {
        bestChild = node.right;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (point[dimension] &lt; node.obj[dimension]) {
          bestChild = node.left;
        } <span class="hljs-keyword">else</span> {
          bestChild = node.right;
        }
      }

      nearestSearch(bestChild);

      <span class="hljs-keyword">if</span> (bestNodes.size() &lt; maxNodes || ownDistance &lt; bestNodes.peek()[<span class="hljs-number">1</span>]) {
        saveNode(node, ownDistance);
      }

      <span class="hljs-keyword">if</span> (bestNodes.size() &lt; maxNodes || <span class="hljs-built_in">Math</span>.abs(linearDistance) &lt; bestNodes.peek()[<span class="hljs-number">1</span>]) {
        <span class="hljs-keyword">if</span> (bestChild === node.left) {
          otherChild = node.right;
        } <span class="hljs-keyword">else</span> {
          otherChild = node.left;
        }
        <span class="hljs-keyword">if</span> (otherChild !== <span class="hljs-literal">null</span>) {
          nearestSearch(otherChild);
        }
      }
    }

    <span class="hljs-keyword">if</span> (maxDistance) {
      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; maxNodes; i += <span class="hljs-number">1</span>) {
        bestNodes.push([<span class="hljs-literal">null</span>, maxDistance]);
      }
    }

    nearestSearch(self.root);

    result = [];

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; maxNodes; i += <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">if</span> (bestNodes.content[i][<span class="hljs-number">0</span>]) {
        result.push([bestNodes.content[i][<span class="hljs-number">0</span>].obj, bestNodes.content[i][<span class="hljs-number">1</span>]]);
      }
    }
    <span class="hljs-keyword">return</span> result;
  };

  <span class="hljs-keyword">this</span>.balanceFactor = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">height</span><span class="hljs-params">(node)</span> </span>{
      <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(height(node.left), height(node.right)) + <span class="hljs-number">1</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">count</span><span class="hljs-params">(node)</span> </span>{
      <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      }
      <span class="hljs-keyword">return</span> count(node.left) + count(node.right) + <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">return</span> height(self.root) / (<span class="hljs-built_in">Math</span>.log(count(self.root)) / <span class="hljs-built_in">Math</span>.log(<span class="hljs-number">2</span>));
  };
}</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Binary heap implementation from:
<a href="http://eloquentjavascript.net/appendix2.html">http://eloquentjavascript.net/appendix2.html</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BinaryHeap</span><span class="hljs-params">(scoreFunction)</span></span>{
  <span class="hljs-keyword">this</span>.content = [];
  <span class="hljs-keyword">this</span>.scoreFunction = scoreFunction;
}

BinaryHeap.prototype = {
  push: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(element)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Add the new element to the end of the array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.content.push(element);</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Allow it to bubble up.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.bubbleUp(<span class="hljs-keyword">this</span>.content.length - <span class="hljs-number">1</span>);
  },

  pop: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Store the first element so we can return it later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>.content[<span class="hljs-number">0</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Get the element at the end of the array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> end = <span class="hljs-keyword">this</span>.content.pop();</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>If there are any elements left, put the end element at the
start, and let it sink down.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.content.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.content[<span class="hljs-number">0</span>] = end;
      <span class="hljs-keyword">this</span>.sinkDown(<span class="hljs-number">0</span>);
    }
    <span class="hljs-keyword">return</span> result;
  },

  peek: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.content[<span class="hljs-number">0</span>];
  },

  remove: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node)</span> </span>{
    <span class="hljs-keyword">var</span> len = <span class="hljs-keyword">this</span>.content.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>To remove a value, we must search through the array to find
it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.content[i] == node) {</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>When it is found, the process seen in ‘pop’ is repeated
to fill up the hole.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> end = <span class="hljs-keyword">this</span>.content.pop();
        <span class="hljs-keyword">if</span> (i != len - <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">this</span>.content[i] = end;
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.scoreFunction(end) &lt; <span class="hljs-keyword">this</span>.scoreFunction(node))
            <span class="hljs-keyword">this</span>.bubbleUp(i);
          <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">this</span>.sinkDown(i);
        }
        <span class="hljs-keyword">return</span>;
      }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Node not found."</span>);
  },

  size: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.content.length;
  },

  bubbleUp: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Fetch the element that has to be moved.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> element = <span class="hljs-keyword">this</span>.content[n];</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>When at 0, an element can not go up any further.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Compute the parent element’s index, and fetch it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> parentN = <span class="hljs-built_in">Math</span>.floor((n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>,
          parent = <span class="hljs-keyword">this</span>.content[parentN];</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Swap the elements if the parent is greater.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.scoreFunction(element) &lt; <span class="hljs-keyword">this</span>.scoreFunction(parent)) {
        <span class="hljs-keyword">this</span>.content[parentN] = element;
        <span class="hljs-keyword">this</span>.content[n] = parent;</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Update ‘n’ to continue at the new position.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        n = parentN;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Found a parent that is less, no need to move it further.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">break</span>;
      }
    }
  },

  sinkDown: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Look up the target element and its score.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> length = <span class="hljs-keyword">this</span>.content.length,
        element = <span class="hljs-keyword">this</span>.content[n],
        elemScore = <span class="hljs-keyword">this</span>.scoreFunction(element);

    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Compute the indices of the child elements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> child2N = (n + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>, child1N = child2N - <span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>This is used to store the new position of the element,
if any.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> swap = <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>If the first child exists (is inside the array)…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (child1N &lt; length) {</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Look it up and compute its score.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">this</span>.content[child1N],
            child1Score = <span class="hljs-keyword">this</span>.scoreFunction(child1);</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>If the score is less than our element’s, we need to swap.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (child1Score &lt; elemScore)
          swap = child1N;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Do the same checks for the other child.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (child2N &lt; length) {
        <span class="hljs-keyword">var</span> child2 = <span class="hljs-keyword">this</span>.content[child2N],
            child2Score = <span class="hljs-keyword">this</span>.scoreFunction(child2);
        <span class="hljs-keyword">if</span> (child2Score &lt; (swap == <span class="hljs-literal">null</span> ? elemScore : child1Score)){
          swap = child2N;
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>If the element needs to be moved, swap it, and continue.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (swap != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">this</span>.content[n] = <span class="hljs-keyword">this</span>.content[swap];
        <span class="hljs-keyword">this</span>.content[swap] = element;
        n = swap;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Otherwise, we are done.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">break</span>;
      }
    }
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <h3 id="new-engine-options-">new Engine( [options] )</h3>
<p>Constructor for Engine</p>
<p><strong>params</strong></p>
<ul>
<li><em>Object</em>, An options object defining the library location, number of threads to use, tolerance of the worker, etc.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.core.Engine = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>private properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> _use_pool = ( <span class="hljs-keyword">typeof</span> Worker === <span class="hljs-string">'function'</span> ) &amp;&amp; ( options.use_pool || options.use_pool === <span class="hljs-literal">undefined</span> );
	<span class="hljs-keyword">var</span> _num_threads = options.num_workers || <span class="hljs-number">2</span>;
	<span class="hljs-keyword">var</span> _tolerance = options.tolerance || <span class="hljs-number">1e-4</span>;
	<span class="hljs-keyword">var</span> _url = options.url || <span class="hljs-string">'js/verbEval.js'</span>;
	<span class="hljs-keyword">var</span> _lib = options.library || verb.eval;
	<span class="hljs-keyword">var</span> _error_handler = options.error_handler || ( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( message )</span> </span>{ <span class="hljs-built_in">console</span>.warn( message ); } );
	<span class="hljs-keyword">var</span> _pool = <span class="hljs-literal">undefined</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>private methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> init_pool = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{

		<span class="hljs-keyword">try</span> {
			_pool = <span class="hljs-keyword">new</span> labor.Pool(_url, _num_threads );
			_pool.start();
		} <span class="hljs-keyword">catch</span> (err) {
			_error_handler( <span class="hljs-string">'Failed to initialize labor.Pool: '</span> + err );
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		}
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

	};

	<span class="hljs-keyword">var</span> eval_sync = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(func, arguments_array)</span> </span>{
		<span class="hljs-keyword">return</span> _lib[func].apply(<span class="hljs-literal">null</span>, arguments_array);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <h4 id="start-">start()</h4>
<p>Creates the thread pool if that is being used</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.start = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>initialize pool</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> ( _use_pool )
		{
			init_pool();
		}
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <h4 id="eval-func-arguments_array-callback-">eval(func, arguments_array, callback )</h4>
<p>Evaluate a function asynchronously from the library</p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, The name of the function to call in the library</li>
<li><em>Array</em>, The array of arguments to the function</li>
<li><em>Function</em>, Function to execute on completion, passing the value to it</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Unknown</em>, the return value of the function</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.eval = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(func, arguments_array, callback )</span>
	</span>{

		<span class="hljs-keyword">if</span> (!callback){
			<span class="hljs-keyword">return</span> eval_sync(func, arguments_array);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>if we are to use the pool we must init it </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> ( _use_pool &amp;&amp; ( _pool || ( _pool === <span class="hljs-literal">undefined</span> &amp;&amp; init_pool() ) ) ) {
			_pool.addWork( func, arguments_array, callback );
		}	<span class="hljs-keyword">else</span> {
			setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ callback( eval_sync(func, arguments_array ) ) }, <span class="hljs-number">0</span>);
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <h4 id="settolerance-tolerance-">setTolerance( tolerance )</h4>
<p>Set the tolerance of the library</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The tolerance value</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.setTolerance = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(tolerance)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>TODO: send message to worker pool in labor.js</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		_tolerance = tolerance;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <h4 id="setusepool-use_pool-">setUsePool( use_pool )</h4>
<p>Whether to use the thread pool or do evaluations in the main thread</p>
<p><strong>params</strong></p>
<ul>
<li><em>Boolean</em>, Use the pool or not</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.setUsePool = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( use_pool )</span> </span>{

		<span class="hljs-keyword">if</span> ( use_pool &amp;&amp; _pool === <span class="hljs-literal">undefined</span> &amp;&amp; init_pool() ) {
			_use_pool = use_pool;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !use_pool ) {
			_pool = <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		}
		
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <h4 id="seterrorhandler-handler-">setErrorHandler( handler )</h4>
<p>The error handler function</p>
<p><strong>params</strong></p>
<ul>
<li><em>Function</em>, The function that handles errors</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.setErrorHandler = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( handler )</span> </span>{
		_error_handler = handler;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <h4 id="setnumthreads-numthreads-">setNumThreads( numThreads )</h4>
<p>Set the number of threads to use</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The number of threads to use</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.setNumThreads = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( num_threads )</span> </span>{
		_num_threads = num_threads;</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>TODO: implement add or remove workers in labor.js</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	}

};</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <h3 id="new-watchobject-">new WatchObject()</h3>
<p>Constructor for WatchObject</p>
<p>WatchObject is a simple type with observable properties.  You can register callbacks for
when these properties change</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.core.WatchObject = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>name -&gt; { id -&gt; callback }</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> watchers = { <span class="hljs-string">"change"</span> : {} };</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>name -&gt; value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> properties = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>counter for watch ids</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> watcherId = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>report a property change to the watchers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> report = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, updateObject)</span></span>{

		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">"string"</span>){

			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> ele <span class="hljs-keyword">in</span> watchers[name]){
				watchers[name][ele]( updateObject );
			}

			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> ele <span class="hljs-keyword">in</span> watchers[<span class="hljs-string">"change"</span>]){
				watchers[<span class="hljs-string">"change"</span>][ele]( updateObject );
			}
			
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n <span class="hljs-keyword">in</span> name){
				report( n, updateObject );
			}
		}

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <h4 id="eval-func-arguments_array-callback-">eval(func, arguments_array, callback )</h4>
<p>Get the value of a property name. </p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, The name of the property</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Unknown</em>, The value of the property</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.get = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( name )</span></span>{

		<span class="hljs-keyword">return</span> properties[name];

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <h4 id="set-name-value-">set( name, value )</h4>
<p>Set the value of a property and update watchers.  Initializes the value if it doesn’t already exist</p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, The name of the property</li>
<li><em>Unknown</em>, The new value for the property</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.set = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( name, value )</span></span>{

		<span class="hljs-keyword">var</span> old = properties[name];

		properties[name] = value;
		watchers[name] = watchers[name] || {};

		report( name, {name: name, old: old, <span class="hljs-string">"new"</span>: value, target: that, type: <span class="hljs-string">"full"</span>});

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <h4 id="setall-propertynamevaluepairs-">setAll( propertyNameValuePairs )</h4>
<p>Set the value of a collection of properties simultaneously</p>
<p><strong>params</strong></p>
<ul>
<li><em>Object</em>, An object literal mapping from property names to new values</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.setAll = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( propertyNameValuePairs )</span></span>{

		<span class="hljs-keyword">var</span> oldVals = {};

		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> propName <span class="hljs-keyword">in</span> propertyNameValuePairs ){
			oldVals[propName] = properties[propName];
			properties[propName] = propertyNameValuePairs[propName];
			watchers[propName] = watchers[propName] || {};
		}

		report( propertyNameValuePairs, { old: oldVals, <span class="hljs-string">"new"</span>: propertyNameValuePairs, target: that, type: <span class="hljs-string">"multi"</span> } );

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <h4 id="setat-name-index-value-">setAt( name, index, value  )</h4>
<p>Set the value of an array property at a particular index.  Update watchers
indicating that it is an “index” type update.</p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, The name of the property</li>
<li><em>Number</em>, The index at which to change the value</li>
<li><em>Unknown</em>, The new value for the index</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">this</span>.setAt = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( name, index, value )</span></span>{

		<span class="hljs-keyword">var</span> oldArr = properties[name];

		<span class="hljs-keyword">if</span> (oldArr === <span class="hljs-literal">undefined</span> || oldArr.length &gt;= index || index &lt; <span class="hljs-number">0</span>){
			<span class="hljs-keyword">return</span>;
		}

		<span class="hljs-keyword">var</span> old = properties[name][index];
		properties[name][index] = value;

		report( name, {name: name, index: index, old: old, <span class="hljs-string">"new"</span>: value, target: that, type: <span class="hljs-string">"index"</span>} );

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <h4 id="watch-name-callback-">watch( name, callback )</h4>
<p>Start watching a particular property.  Use “change” as the name to receive all 
updates from this object</p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, The name of the property</li>
<li><em>Function</em>, The callback</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, A watcher id which can be used to unregister the callback</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.watch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( name, callback )</span></span>{

		<span class="hljs-keyword">if</span> ( properties[name] === <span class="hljs-literal">undefined</span> || !callback ){
			<span class="hljs-keyword">return</span>;
		}

		<span class="hljs-keyword">var</span> id = watcherId++;
		watchers[name][watcherId] = callback;

		<span class="hljs-keyword">return</span> watcherId++;
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <h4 id="watchall-names-callback-">watchAll( names, callback )</h4>
<p>Start watching multiple properties</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Array of property names</li>
<li><em>Function</em>, The callback</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, An array of watcher ids which can be used to unregister the callbacks</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.watchAll = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( names, callback )</span></span>{

		<span class="hljs-keyword">var</span> watcherIds = [];

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; names.length; i++){
			watcherIds.push( <span class="hljs-keyword">this</span>.watch( names[i], callback ) );
		}

		<span class="hljs-keyword">return</span> watcherIds;

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <h4 id="watchall-names-callback-">watchAll( names, callback )</h4>
<p>Stop watching a property</p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, Property name</li>
<li><em>Number</em>, Watcher id to remove</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">this</span>.ignore = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( name, watcherId )</span></span>{
	
		<span class="hljs-keyword">if</span> ( watchers[name] === <span class="hljs-literal">undefined</span> 
			|| watchers[name][watcherId] === <span class="hljs-literal">undefined</span>){
			<span class="hljs-keyword">return</span>;
		}

		watchers[name][watcherId] = <span class="hljs-literal">undefined</span>;

	};

};</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <h4 id="uid-">uid()</h4>
<p>Generate a unique id.</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Number</em>, The id</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.core.uid = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">var</span> id = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
		<span class="hljs-keyword">return</span> id++;
	};
})();</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <h3 id="new-nurbsgeometry-">new NurbsGeometry()</h3>
<p>Constructor for Geometry</p>
<p>Geometry is the base class for all Geometry types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.Geometry = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ 

	verb.core.WatchObject.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">var</span> id = verb.core.uid();
	
	<span class="hljs-keyword">this</span>.uniqueId = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
		<span class="hljs-keyword">return</span> id;
	};

}.inherits(verb.core.WatchObject);</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <h3 id="new-nurbsgeometry-">new NurbsGeometry()</h3>
<p>Constructor for NurbsGeometry</p>
<p>NurbsGeometry is the base class for all NURBS types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.NurbsGeometry = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{

	verb.Geometry.call(<span class="hljs-keyword">this</span>);

}.inherits( verb.Geometry );</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <h3 id="new-nurbssurface-degree-controlpoints-weights-knots-">new NurbsSurface( degree, controlPoints, weights, knots )</h3>
<p>Constructor for a NurbsCurve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The degree of the curve</li>
<li><em>Array</em>, Array of arrays representing the control points</li>
<li><em>Array</em>, Array of numbers representing the control point weights</li>
<li><em>Array</em>, Array of numbers representing the knot structure</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsCurve = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, controlPoints, weights, knots )</span> </span>{

	verb.NurbsGeometry.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"controlPoints"</span>: controlPoints,
		<span class="hljs-string">"weights"</span>: weights,
		<span class="hljs-string">"knots"</span>: knots ? knots.slice(<span class="hljs-number">0</span>) : [],
		<span class="hljs-string">"degree"</span>: degree
	});

}.inherits( verb.NurbsGeometry );</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <h4 id="point-u-callback-">point( u [, callback] )</h4>
<p>Sample a point at the given parameter </p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The parameter to sample the curve</li>
<li><em>Function</em>, Optional callback to do it async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsCurve.prototype.point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, callback )</span> </span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_curve_point'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>), <span class="hljs-keyword">this</span>.homogenize(),  u ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <h4 id="derivatives-u-num_derivs-callback-">derivatives( u, num_derivs [, callback] )</h4>
<p>Get derivatives at a given parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The parameter to sample the curve</li>
<li><em>Number</em>, The number of derivatives to obtain</li>
<li><em>Function</em>, The callback, if you want this async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsCurve.prototype.derivatives = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, num_derivs, callback )</span> </span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_curve_derivs'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>), <span class="hljs-keyword">this</span>.homogenize(),  u, num_derivs || <span class="hljs-number">1</span>  ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <h4 id="closestpoint-point-callback-">closestPoint( point [, callback] )</h4>
<p>Determine the closest parameter on the curve to the given point</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, A length 3 array representing the point</li>
<li><em>Function</em>, The callback, if you want this async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Number</em>, The parameter of the closest point</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsCurve.prototype.closestPoint = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( point, callback )</span> </span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_curve_closest_point'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>), <span class="hljs-keyword">this</span>.homogenize(),  point  ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <h4 id="length-callback-">length( [callback] )</h4>
<p>Determine the arc length of the curve</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Number</em>, The length of the curve</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsCurve.prototype.length = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( callback )</span> </span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_curve_arc_length'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>), <span class="hljs-keyword">this</span>.homogenize()  ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <h4 id="lengthatparam-u-callback-">lengthAtParam( u [, callback] )</h4>
<p>Determine the arc length of the curve at the given parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Function</em>, The callback, if you want this async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Number</em>, The length of the curve at the given parameter</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsCurve.prototype.lengthAtParam = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, callback )</span> </span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_curve_arc_length'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>), <span class="hljs-keyword">this</span>.homogenize(), u  ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <h4 id="lengthatparam-len-callback-">lengthAtParam( len [, callback] )</h4>
<p>Determine the parameter of the curve at the given arc length</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The arc length at which to determine the parameter</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Number</em>, The length of the curve at the given parameter</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsCurve.prototype.paramAtLength = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( len, callback )</span> </span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_curve_param_at_arc_length'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>), <span class="hljs-keyword">this</span>.homogenize(), len  ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <h4 id="dividebyequalarclength-divisions-callback-">divideByEqualArcLength( divisions [, callback] )</h4>
<p>Determine the parameters necessary to divide the curve into equal arc length segments</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Number of divisions of the curve</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, A collection of parameters</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsCurve.prototype.divideByEqualArcLength = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( divisions, callback )</span> </span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_curve_divide_curve_equally_by_arc_length'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>), <span class="hljs-keyword">this</span>.homogenize(), divisions  ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <h4 id="dividebyarclength-divisions-callback-">divideByArcLength( divisions [, callback] )</h4>
<p>Given the distance to divide the curve, determine the parameters necessary to divide the curve into equal arc length segments</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Arc length of each segment</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, A collection of parameters</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsCurve.prototype.divideByArcLength = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( arcLength, callback )</span> </span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_curve_divide_curve_by_arc_length'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>), <span class="hljs-keyword">this</span>.homogenize(), arcLength  ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <h4 id="tessellate-options-callback-">tessellate(options [, callback] )</h4>
<p>Tessellate a curve at a given tolerance</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The parameter to sample the curve</li>
<li><em>Number</em>, The number of derivatives to obtain</li>
<li><em>Function</em>, The callback, if you want this async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsCurve.prototype.tessellate = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options, callback)</span></span>{

	<span class="hljs-keyword">var</span> options = options || {};
	options.tolerance = options.tolerance || verb.EPSILON;

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_curve_adaptive_sample'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>), <span class="hljs-keyword">this</span>.homogenize(), options.tolerance ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <h4 id="split-u-callback-">split( u [, callback] )</h4>
<p>Split the curve at the given parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The parameter at which to split the curve</li>
<li><em>Function</em>, Optional callback to do it async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, Two curves - one at the lower end of the parameter range and one at the higher end.  </li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsCurve.prototype.split = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, callback )</span> </span>{

	<span class="hljs-keyword">var</span> domain = <span class="hljs-keyword">this</span>.domain();

	<span class="hljs-keyword">if</span> ( u &lt;= domain[<span class="hljs-number">0</span>] || u &gt;= domain[<span class="hljs-number">1</span>] ) {
		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Cannot split outside of the domain of the curve!"</span>);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>transform the result from the engine into a valid pair of NurbsCurves</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asNurbsCurves</span><span class="hljs-params">(res)</span></span>{

		<span class="hljs-keyword">var</span> cpts0 = verb.eval.dehomogenize_1d( res[<span class="hljs-number">0</span>].control_points );
		<span class="hljs-keyword">var</span> wts0 = verb.eval.weight_1d( res[<span class="hljs-number">0</span>].control_points );

		<span class="hljs-keyword">var</span> c0 = <span class="hljs-keyword">new</span> verb.NurbsCurve( res[<span class="hljs-number">0</span>].degree, cpts0, wts0, res[<span class="hljs-number">0</span>].knots );

		<span class="hljs-keyword">var</span> cpts1 = verb.eval.dehomogenize_1d( res[<span class="hljs-number">1</span>].control_points );
		<span class="hljs-keyword">var</span> wts1 = verb.eval.weight_1d( res[<span class="hljs-number">1</span>].control_points );

		<span class="hljs-keyword">var</span> c1 = <span class="hljs-keyword">new</span> verb.NurbsCurve( res[<span class="hljs-number">1</span>].degree, cpts1, wts1, res[<span class="hljs-number">1</span>].knots );

		<span class="hljs-keyword">return</span> [c0, c1];
	}

	<span class="hljs-keyword">if</span> (callback){
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'curve_split'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>), <span class="hljs-keyword">this</span>.homogenize(), u ], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(res)</span></span>{
			<span class="hljs-keyword">return</span> callback( asNurbsCurves(res) );
		});
	} 

	<span class="hljs-keyword">return</span> asNurbsCurves( <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'curve_split'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>), <span class="hljs-keyword">this</span>.homogenize(), u ]));

};</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <h4 id="domain-">domain()</h4>
<p>Determine the valid domain of the curve</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array representing the high and end point of the domain of the curve </li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsCurve.prototype.domain = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{

	<span class="hljs-keyword">var</span> knots = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>);
	<span class="hljs-keyword">return</span> [ knots[<span class="hljs-number">0</span>], knots[knots.length-<span class="hljs-number">1</span>] ];

}</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <h4 id="transform-mat-">transform( mat )</h4>
<p>Transform a curve with the given matrix.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 4d array representing the transform</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsCurve.prototype.transform = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( mat )</span></span>{

	<span class="hljs-keyword">var</span> pts = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"controlPoints"</span>);

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pts.length; i++){
		<span class="hljs-keyword">var</span> homoPt = pts[<span class="hljs-number">1</span>].push(<span class="hljs-number">1</span>);
		pts[i] = numeric.mul( mat, homoPt ).slice( <span class="hljs-number">0</span>, homoPt.length-<span class="hljs-number">2</span> );
	}

	<span class="hljs-keyword">this</span>.set(<span class="hljs-string">'controlPoints'</span>, pts);

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <h4 id="clone-">clone()</h4>
<p>Obtain a copy of the curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 4d array representing the transform</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsCurve.prototype.clone = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>copy the control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> pts = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"controlPoints"</span>);

	<span class="hljs-keyword">var</span> pts_copy = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pts.length; i++){
		pts_copy.push( pts[i].slice(<span class="hljs-number">0</span>) );
	}

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> verb.NurbsCurve( <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), pts_copy, <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'weights'</span>).slice(<span class="hljs-number">0</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>).slice );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <h4 id="homogenize-">homogenize()</h4>
<p>Obtain the homogeneous representation of the control points</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, 2d array of homogenized control points</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsCurve.prototype.homogenize = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">return</span> verb.eval.homogenize_1d( <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'controlPoints'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'weights'</span>) );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <h4 id="update-">update()</h4>
<p>If this is a subtype of the NurbsCurve, this method will update the Nurbs representation
of the curve from those parameters.  This destroys any manual changes to the Nurbs rep.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.NurbsCurve.prototype.update = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.nurbsRep ){
		<span class="hljs-keyword">return</span>;
	}

	<span class="hljs-keyword">var</span> curve_props = <span class="hljs-keyword">this</span>.nurbsRep();

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"controlPoints"</span>: curve_props.control_points,
		<span class="hljs-string">"weights"</span>: curve_props.weights,
		<span class="hljs-string">"knots"</span>: curve_props.knots,
		<span class="hljs-string">"degree"</span>: curve_props.degree
	});

};</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <h3 id="new-nurbssurface-degreeu-knotsu-degreev-knotsv-controlpoints-weights-">new NurbsSurface( degreeU, knotsU, degreeV, knotsV, controlPoints, weights )</h3>
<p>Constructor for a NurbsSurface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The degree of the surface in the u direction</li>
<li><em>Array</em>, Array of numbers representing the knot positions in the u direction</li>
<li><em>Number</em>, The degree of the surface in the v direction</li>
<li><em>Array</em>, Array of numbers representing the knot positions in the v direction</li>
<li><em>Array</em>, 3d array representing the unweighted control points</li>
<li><em>Array</em>, 2d array representing the surface weight structure</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsSurface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degreeU, knotsU, degreeV, knotsV, controlPoints, weights )</span> </span>{

	verb.NurbsGeometry.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"controlPoints"</span>: controlPoints,
		<span class="hljs-string">"weights"</span>: weights,
		<span class="hljs-string">"knotsU"</span>: knotsU ? knotsU.slice(<span class="hljs-number">0</span>) : [],
		<span class="hljs-string">"knotsV"</span>: knotsV ? knotsV.slice(<span class="hljs-number">0</span>) : [],
		<span class="hljs-string">"degreeU"</span>: degreeU,
		<span class="hljs-string">"degreeV"</span>: degreeV
	});

}.inherits( verb.NurbsGeometry );</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <h4 id="point-u-v-callback-">point( u, v [, callback] )</h4>
<p>Sample a point at the given u, v parameter </p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The u parameter at which to sample</li>
<li><em>Number</em>, The v parameter at which to sample</li>
<li><em>Function</em>, Optional callback to do it async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsSurface.prototype.point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, v, callback )</span> </span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_surface_point'</span>, 
							[ 	<span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeV'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsV'</span>), <span class="hljs-keyword">this</span>.homogenize(), u, v ], callback );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <h4 id="derivatives-u-v-num_derivs-callback-">derivatives( u, v, num_derivs [, callback] )</h4>
<p>Get derivatives at a given u, v parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The u parameter to sample the curve</li>
<li><em>Number</em>, The v parameter to sample the curve</li>
<li><em>Number</em>, The number of derivatives to obtain</li>
<li><em>Function</em>, The callback, if you want this async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsSurface.prototype.derivatives = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, v, num_derivs, callback )</span> </span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_surface_derivs'</span>, 
			[	<span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeV'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsV'</span>), <span class="hljs-keyword">this</span>.homogenize(), num_derivs || <span class="hljs-number">1</span>, u, v ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <h4 id="closestpoint-point-callback-">closestPoint( point [, callback] )</h4>
<p>Determine the closest parameter on the Surface to the given point</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, A length 3 array representing the point</li>
<li><em>Function</em>, The callback, if you want this async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, The uv parameter of the closest point</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsSurface.prototype.closestPoint = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( point, callback )</span> </span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_surface_closest_point'</span>, 
		[	<span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeV'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsV'</span>), <span class="hljs-keyword">this</span>.homogenize(),  point  ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <h4 id="split-u-dir-callback-">split( u, dir [, callback] )</h4>
<p>Split the surface at the given parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The parameter at which to split the surface</li>
<li><em>Number</em>, 0 for the u direction and 1 for v</li>
<li><em>Function</em>, Optional callback to do it async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, Two surfaces - one at the lower end of the parameter range and one at the higher end.  </li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsSurface.prototype.split = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, dir, callback )</span> </span>{

	<span class="hljs-keyword">var</span> domain = <span class="hljs-keyword">this</span>.domain();
	
	<span class="hljs-keyword">var</span> dir = dir === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : dir;
	<span class="hljs-keyword">var</span> u = u === <span class="hljs-literal">undefined</span> ? (domain[dir][<span class="hljs-number">1</span>] - domain[dir][<span class="hljs-number">0</span>]) / <span class="hljs-number">2</span> : u;

	<span class="hljs-keyword">if</span> ( u &lt;= domain[dir][<span class="hljs-number">0</span>] || u &gt;= domain[dir][<span class="hljs-number">1</span>] ) {
		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Cannot split outside of the domain of the surface!"</span>);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>transform the result from the engine into a valid pair of NurbsSurfaces</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asNurbsSurfaces</span><span class="hljs-params">(res)</span></span>{

		<span class="hljs-keyword">var</span> cpts0 = verb.eval.dehomogenize_2d( res[<span class="hljs-number">0</span>].control_points );
		<span class="hljs-keyword">var</span> wts0 = verb.eval.weight_2d( res[<span class="hljs-number">0</span>].control_points );

		<span class="hljs-keyword">var</span> c0 = <span class="hljs-keyword">new</span> verb.NurbsSurface( res[<span class="hljs-number">0</span>].degree_u, res[<span class="hljs-number">0</span>].knots_u, res[<span class="hljs-number">0</span>].degree_v, res[<span class="hljs-number">0</span>].knots_v, cpts0, wts0 );

		<span class="hljs-keyword">var</span> cpts1 = verb.eval.dehomogenize_2d( res[<span class="hljs-number">1</span>].control_points );
		<span class="hljs-keyword">var</span> wts1 = verb.eval.weight_2d( res[<span class="hljs-number">1</span>].control_points );

		<span class="hljs-keyword">var</span> c1 = <span class="hljs-keyword">new</span> verb.NurbsSurface( res[<span class="hljs-number">1</span>].degree_u, res[<span class="hljs-number">1</span>].knots_u, res[<span class="hljs-number">1</span>].degree_v, res[<span class="hljs-number">1</span>].knots_v, cpts1, wts1 );

		<span class="hljs-keyword">return</span> [c0, c1];
	}

	<span class="hljs-keyword">if</span> (callback){
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'surface_split'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeV'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsV'</span>), <span class="hljs-keyword">this</span>.homogenize(), u, dir ], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(res)</span></span>{
			<span class="hljs-keyword">return</span> callback( asNurbsSurfaces(res) );
		});
	} 

	<span class="hljs-keyword">return</span> asNurbsSurfaces( <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'surface_split'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeV'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsV'</span>), <span class="hljs-keyword">this</span>.homogenize(), u, dir ]));

};</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <h4 id="tessellate-options-callback-">tessellate(options [, callback] )</h4>
<p>tessellate the surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Object</em>, tessellate the surface, given an options object including minDivsU, minDivsV, refine, normTol</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsSurface.prototype.tessellate = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options, callback)</span></span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'tessellate_rational_surface_adaptive'</span>, 
			[	<span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeV'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsV'</span>), <span class="hljs-keyword">this</span>.homogenize(), 
			options ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <h4 id="domain-">domain()</h4>
<p>Determine the valid domain of the surface</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An 2d array e.g. [[lowU, highU], [lowV, highV]]</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsSurface.prototype.domain = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{

	<span class="hljs-keyword">var</span> knotsU = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsU'</span>);
	<span class="hljs-keyword">var</span> knotsV = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsV'</span>);
	<span class="hljs-keyword">return</span> [ [ knotsU[<span class="hljs-number">0</span>], knotsU[knotsU.length-<span class="hljs-number">1</span>] ], [ knotsV[<span class="hljs-number">0</span>], knotsV[knotsV.length-<span class="hljs-number">1</span>] ] ];

}</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <h4 id="transform-mat-">transform( mat )</h4>
<p>Transform a curve with the given matrix.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 4d array representing the transform</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsSurface.prototype.transform = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( mat )</span></span>{

	<span class="hljs-keyword">var</span> pts = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"controlPoints"</span>);

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pts.length; i++){
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; pts[i].length; j++){
			<span class="hljs-keyword">var</span> homoPt = pts[<span class="hljs-number">1</span>].push(<span class="hljs-number">1</span>);
			pts[i] = numeric.mul( mat, homoPt ).slice( <span class="hljs-number">0</span>, homoPt.length-<span class="hljs-number">2</span> );
		}
	}

	<span class="hljs-keyword">this</span>.set(<span class="hljs-string">'controlPoints'</span>, pts);

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <h4 id="clone-">clone()</h4>
<p>Obtain a copy of the curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 4d array representing the transform</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsSurface.prototype.clone = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>copy the control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> pts = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"controlPoints"</span>);
	<span class="hljs-keyword">var</span> pts_copy = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pts.length; i++){
		pts_copy.push([]);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; pts[i].length; j++){
			pts_copy[i].push( pts[i][j].slice( <span class="hljs-number">0</span> ) );
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>copy the weights</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> weights = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"weights"</span>);
	<span class="hljs-keyword">var</span> weights_copy = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; weights.length; i++){
		weights_copy.push( weights[i].slice( <span class="hljs-number">0</span> ) );
	}

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> verb.NurbsSurface( <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsU'</span>).slice(<span class="hljs-number">0</span>), 
		<span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeV'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsV'</span>).slice(<span class="hljs-number">0</span>), pts_copy, weights_copy );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <h4 id="homogenize-">homogenize()</h4>
<p>Obtain the homogeneous representation of the control points</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, 3d array of homogenized control points</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsSurface.prototype.homogenize = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">return</span> verb.eval.homogenize_2d( <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'controlPoints'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'weights'</span>) );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <h4 id="update-">update()</h4>
<p>If this is a subtype of the NurbsSurface, this method will update the Nurbs representation
of the curve from those parameters.  This destroys any manual changes to the Nurbs rep.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.NurbsSurface.prototype.update = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.nurbsRep ){
		<span class="hljs-keyword">return</span>;
	}

	<span class="hljs-keyword">var</span> curve_props = <span class="hljs-keyword">this</span>.nurbsRep();

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"controlPoints"</span>: curve_props.control_points,
		<span class="hljs-string">"weights"</span>: curve_props.weights,
		<span class="hljs-string">"knotsU"</span>: curve_props.knots_u,
		<span class="hljs-string">"knotsV"</span>: curve_props.knots_v,
		<span class="hljs-string">"degreeU"</span>: curve_props.degree_u,
		<span class="hljs-string">"degreeV"</span>: curve_props.degree_v
	});

};</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <h3 id="new-arc-center-xaxis-yaxis-radius-interval-">new Arc(center, xaxis, yaxis, radius, interval)</h3>
<p>Constructor for Arc</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the center of the arc</li>
<li><em>Array</em>, Length 3 array representing the xaxis</li>
<li><em>Array</em>, Length 3 array representing the perpendicular yaxis</li>
<li><em>Number</em>, Radius of the arc</li>
<li><em>Interval</em>, Interval object representing the interval of the arc</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.Arc = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(center, xaxis, yaxis, radius, interval)</span> </span>{

	verb.NurbsCurve.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll( {
		<span class="hljs-string">"center"</span>: center,
		<span class="hljs-string">"xaxis"</span>: xaxis,
		<span class="hljs-string">"yaxis"</span>: yaxis,
		<span class="hljs-string">"radius"</span>: radius,
		<span class="hljs-string">"interval"</span>: interval 
	});

	<span class="hljs-keyword">this</span>.update();
	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'center'</span>, <span class="hljs-string">'xaxis'</span>, <span class="hljs-string">'yaxis'</span>, <span class="hljs-string">'radius'</span>, <span class="hljs-string">'interval'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.Arc.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_arc'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"center"</span>), 
													 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xaxis"</span>), 
													 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"yaxis"</span>), 
													 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"radius"</span>), 
													 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"interval"</span>).get(<span class="hljs-string">"min"</span>), 
													 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"interval"</span>).get(<span class="hljs-string">"max"</span>)] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <h3 id="new-beziercurve-control_points-weights-">new BezierCurve( control_points [, weights] )</h3>
<p>Constructor for BezierCurve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Array of Length 3 arrays representing the control pts of the bezier curve</li>
<li><em>Array</em>, Array of numbers representing the weights of the bezier curve, omit if you don’t want this to be a rational curve</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.BezierCurve = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( control_points, weights )</span> </span>{

	verb.NurbsCurve.call(<span class="hljs-keyword">this</span>);
	
	<span class="hljs-keyword">this</span>.setAll( {
		<span class="hljs-string">"controlPoints"</span>: control_points ? control_points.slice(<span class="hljs-number">0</span>) : [],
		<span class="hljs-string">"weights"</span>: weights ? weights.slice(<span class="hljs-number">0</span>) : <span class="hljs-literal">undefined</span>
	});

	<span class="hljs-keyword">this</span>.update();

}.inherits( verb.NurbsCurve );</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.BezierCurve.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">var</span> control_points = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'controlPoints'</span>);
	<span class="hljs-keyword">var</span> weights = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'weights'</span>);
	<span class="hljs-keyword">var</span> degree = control_points.length - <span class="hljs-number">1</span>;

	<span class="hljs-keyword">var</span> knots = [];
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; degree + <span class="hljs-number">1</span>; i++){ knots.push(<span class="hljs-number">0</span>); }
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; degree + <span class="hljs-number">1</span>; i++){ knots.push(<span class="hljs-number">1</span>); }</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>if weights aren’t provided, build uniform weights</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (weights === <span class="hljs-literal">undefined</span>){
		weights = [];
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; control_points.length; i++){
			weights.push(<span class="hljs-number">1</span>);
		}
	}

	<span class="hljs-keyword">return</span> {
		degree: degree,
		knots: knots, 
		control_points: control_points,
		weights: weights
	};

};</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <h3 id="new-boundingbox-points-">new BoundingBox([ points ])</h3>
<p>BoundingBox Constructor</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Points to add, if desired.  Otherwise, will not be initialized until add is called.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.BoundingBox = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( pts )</span> </span>{

	<span class="hljs-keyword">this</span>.initialized = <span class="hljs-literal">false</span>;

	<span class="hljs-keyword">this</span>.dim = <span class="hljs-number">3</span>;
	<span class="hljs-keyword">this</span>.min = <span class="hljs-literal">null</span>;
	<span class="hljs-keyword">this</span>.max = <span class="hljs-literal">null</span>;

 	<span class="hljs-keyword">if</span> ( pts ) {
 		<span class="hljs-keyword">this</span>.addRange( pts );
 	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <h4 id="frompoint-point-">fromPoint( point )</h4>
<p>Create a bounding box initialized with a single element</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, A array of numbers </li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Object</em>, This BoundingBox for chaining</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.BoundingBox.fromPoint = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( pt )</span></span>{
	<span class="hljs-keyword">var</span> bb = <span class="hljs-keyword">new</span> verb.BoundingBox();
	bb.add( pt );
	<span class="hljs-keyword">return</span> bb;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <h4 id="add-point-">add( point )</h4>
<p>Adds a point to the bounding box, expanding the bounding box if the point is outside of it.
If the bounding box is not initialized, this method has that side effect.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, A length-n array of numbers </li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Object</em>, This BoundingBox for chaining</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.BoundingBox.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( point )</span> 
</span>{
	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.initialized )
	{
		<span class="hljs-keyword">this</span>.dim = point.length;
		<span class="hljs-keyword">this</span>.min = point.slice(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">this</span>.max = point.slice(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">this</span>.initialized = <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	}

	<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = <span class="hljs-keyword">this</span>.dim;

	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; l; i++){
		<span class="hljs-keyword">if</span> (point[i] &gt; <span class="hljs-keyword">this</span>.max[i] ) 
			<span class="hljs-keyword">this</span>.max[i] = point[i];
	}

	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; l; i++){
		<span class="hljs-keyword">if</span> (point[i] &lt; <span class="hljs-keyword">this</span>.min[i] )
			<span class="hljs-keyword">this</span>.min[i] = point[i];
	}

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <h4 id="addrange-points-callback-">addRange( points, callback )</h4>
<p>Asynchronously add an array of points to the bounding box</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, An array of length-n array of numbers </li>
<li><em>Function</em>, Function to call when all of the points in array have been added.  The only parameter to this
callback is this bounding box.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.BoundingBox.prototype.addRange = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points, callback )</span> 
</span>{
	<span class="hljs-keyword">var</span> l = points.length;

	<span class="hljs-keyword">if</span> (callback){
		setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) {
				<span class="hljs-keyword">this</span>.add(points[i]);
			}
			callback(<span class="hljs-keyword">this</span>);
		}.bind(<span class="hljs-keyword">this</span>), <span class="hljs-number">0</span>);
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) {
			<span class="hljs-keyword">this</span>.add(points[i]);
		}
	}

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <h4 id="contains-point-">contains( point )</h4>
<p>Determines if two intervals on the real number line intersect</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Beginning of first interval</li>
<li><em>Number</em>, End of first interval</li>
<li><em>Number</em>, Beginning of second interval</li>
<li><em>Number</em>, End of second interval</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Boolean</em>, true if the two intervals overlap, otherwise false</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.BoundingBox.prototype.contains = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(point, tol)</span> </span>{

	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.initialized )
	{
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	}

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.intersects( <span class="hljs-keyword">new</span> verb.BoundingBox([point]), tol );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <h4 id="tolerance">TOLERANCE</h4>
<p>Defines the tolerance for bounding box operations</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.BoundingBox.prototype.TOLERANCE = <span class="hljs-number">1e-4</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <h4 id="intervalsoverlap-a1-a2-b1-b2-">intervalsOverlap( a1, a2, b1, b2 )</h4>
<p>Determines if two intervals on the real number line intersect</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Beginning of first interval</li>
<li><em>Number</em>, End of first interval</li>
<li><em>Number</em>, Beginning of second interval</li>
<li><em>Number</em>, End of second interval</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Boolean</em>, true if the two intervals overlap, otherwise false</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.BoundingBox.prototype.intervalsOverlap = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( a1, a2, b1, b2, tol )</span> </span>{

	<span class="hljs-keyword">var</span> tol = tol || verb.BoundingBox.prototype.TOLERANCE
		, x1 = <span class="hljs-built_in">Math</span>.min(a1, a2) - tol
		, x2 = <span class="hljs-built_in">Math</span>.max(a1, a2) + tol
		, y1 = <span class="hljs-built_in">Math</span>.min(b1, b2) - tol
		, y2 = <span class="hljs-built_in">Math</span>.max(b1, b2) + tol;

	<span class="hljs-keyword">if</span> ( (x1 &gt;= y1 &amp;&amp; x1 &lt;= y2) || (x2 &gt;= y1 &amp;&amp; x2 &lt;= y2) || (y1 &gt;= x1 &amp;&amp; y1 &lt;= x2) || (y2 &gt;= x1 &amp;&amp; y2 &lt;= x2) )
	{
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	}
	<span class="hljs-keyword">else</span> 
	{
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	}

}</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <h4 id="intersects-bb-">intersects( bb )</h4>
<p>Determines if this bounding box intersects with another</p>
<p><strong>params</strong></p>
<ul>
<li><em>Object</em>, BoundingBox to check for intersection with this one</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Boolean</em>, true if the two bounding boxes intersect, otherwise false</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.BoundingBox.prototype.intersects = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( bb, tol )</span> </span>{

	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.initialized || !bb.initialized )
	{
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	}

	<span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">this</span>.min
		, a2 = <span class="hljs-keyword">this</span>.max
		, b1 = bb.min
		, b2 = bb.max;

	<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.intervalsOverlap(a1[<span class="hljs-number">0</span>], a2[<span class="hljs-number">0</span>], b1[<span class="hljs-number">0</span>], b2[<span class="hljs-number">0</span>], tol ) 
			&amp;&amp; <span class="hljs-keyword">this</span>.intervalsOverlap(a1[<span class="hljs-number">1</span>], a2[<span class="hljs-number">1</span>], b1[<span class="hljs-number">1</span>], b2[<span class="hljs-number">1</span>], tol ) 
			&amp;&amp; <span class="hljs-keyword">this</span>.intervalsOverlap(a1[<span class="hljs-number">2</span>], a2[<span class="hljs-number">2</span>], b1[<span class="hljs-number">2</span>], b2[<span class="hljs-number">2</span>], tol ) )
	{
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	}

	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <h4 id="clear-bb-">clear( bb )</h4>
<p>Clear the bounding box, leaving it in an uninitialized state.  Call add, addRange in order to 
initialize</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Object</em>, this BoundingBox for chaining</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.BoundingBox.prototype.clear = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( bb )</span> </span>{

	<span class="hljs-keyword">this</span>.initialized = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <h4 id="getlongestaxis-bb-">getLongestAxis( bb )</h4>
<p>Get longest axis of bounding box</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Number</em>, Index of longest axis</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.BoundingBox.prototype.getLongestAxis = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( bb )</span> </span>{

	<span class="hljs-keyword">var</span> axisLengths = [];
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.dim; i++){
		axisLengths.push( <span class="hljs-keyword">this</span>.getAxisLength(i) );
	}

	<span class="hljs-keyword">return</span> axisLengths.indexOf(<span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-built_in">Math</span>, axisLengths));

};</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <h4 id="getaxislength-i-">getAxisLength( i )</h4>
<p>Get length of given axis. </p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Index of axis to inspect (between 0 and 2)</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Number</em>, Length of the given axis.  If axis is out of bounds, returns 0.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.BoundingBox.prototype.getAxisLength = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( i )</span> </span>{

	<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; <span class="hljs-keyword">this</span>.dim-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

	<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs( <span class="hljs-keyword">this</span>.min[i] - <span class="hljs-keyword">this</span>.max[i] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <h4 id="intersect-bb-">intersect( bb )</h4>
<p>Compute the boolean intersection of this with another axis-aligned bounding box.  If the two
bounding boxes do not intersect, returns null.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Object</em>, BoundingBox to intersect with</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Object</em>, The bounding box formed by the intersection or null if there is no intersection.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.BoundingBox.prototype.intersect = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( bb, tol )</span> </span>{

	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.initialized )
	{
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">this</span>.min
		, a2 = <span class="hljs-keyword">this</span>.max
		, b1 = bb.min
		, b2 = bb.max;

	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.intersects( bb, tol ) )
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

	<span class="hljs-keyword">var</span> maxbb = []
		, minbb = [];
		
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.dim; i++){
		maxbb.push( <span class="hljs-built_in">Math</span>.min( a2[i], b2[i] ) );
		minbb.push( <span class="hljs-built_in">Math</span>.max( a1[i], b1[i] ) );
	}

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> verb.BoundingBox([minbb, maxbb]);

}</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <h3 id="new-circle-center-xaxis-yaxis-xradius-yradius-">new Circle(center, xaxis, yaxis, xradius, yradius)</h3>
<p>Constructor for Circle</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the center of the circle</li>
<li><em>Array</em>, Length 3 array representing the xaxis</li>
<li><em>Array</em>, Length 3 array representing the perpendicular yaxis</li>
<li><em>Number</em>, Radius</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.Circle = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(center, xaxis, yaxis, radius)</span> </span>{

	verb.NurbsCurve.call(<span class="hljs-keyword">this</span>);
	
	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"center"</span>: center,
		<span class="hljs-string">"xaxis"</span>: xaxis,
		<span class="hljs-string">"yaxis"</span>: yaxis,
		<span class="hljs-string">"radius"</span>: radius 
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'center'</span>, <span class="hljs-string">'xaxis'</span>, <span class="hljs-string">'yaxis'</span>, <span class="hljs-string">'radius'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.Circle.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_arc'</span>, [  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"center"</span>), 
																									 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xaxis"</span>), 
																									 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"yaxis"</span>), 
																									 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"radius"</span>), 
																									 <span class="hljs-number">0</span>, 
																									 <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <h3 id="new-cone-axis-xaxis-base-height-radius-">new Cone(axis, xaxis, base, height, radius )</h3>
<p>Constructor for Cone</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the axis of the cone</li>
<li><em>Array</em>, Length 3 array representing the x axis, perpendicular to the axis</li>
<li><em>Array</em>, Length 3 array representing the base of the cone</li>
<li><em>Number</em>, Height of the cone</li>
<li><em>Number</em>, Radius of the cone</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.Cone = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(axis, xaxis, base, height, radius )</span> </span>{

	verb.NurbsSurface.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"axis"</span>: axis,
		<span class="hljs-string">"xaxis"</span>: xaxis,
		<span class="hljs-string">"base"</span>: base,
		<span class="hljs-string">"height"</span>: height,
		<span class="hljs-string">"radius"</span>: radius 
	});

	<span class="hljs-keyword">var</span> surface_props = <span class="hljs-keyword">this</span>.nurbsRep();

	verb.NurbsSurface.call(<span class="hljs-keyword">this</span>, surface_props.degree_u, surface_props.knots_u, surface_props.degree_v, surface_props.knots_v, surface_props.control_points, surface_props.weights );

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'axis'</span>, <span class="hljs-string">'xaxis'</span>, <span class="hljs-string">'base'</span>, <span class="hljs-string">'height'</span>, <span class="hljs-string">'radius'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.Cone.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_cone_surface'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"axis"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xaxis"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"base"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"height"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"radius"</span>) ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <h3 id="new-cylinder-center-xaxis-yaxis-xradius-yradius-">new Cylinder(center, xaxis, yaxis, xradius, yradius)</h3>
<p>Constructor for Cylinder</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the axis of the cylinder</li>
<li><em>Array</em>, Length 3 array representing the x axis, perpendicular to the axis</li>
<li><em>Array</em>, Length 3 array representing the base of the cylinder</li>
<li><em>Number</em>, Height of the cylinder</li>
<li><em>Number</em>, Radius of the cylinder</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.Cylinder = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(axis, xaxis, base, height, radius )</span> </span>{

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"axis"</span>: axis,
		<span class="hljs-string">"xaxis"</span>: xaxis,
		<span class="hljs-string">"base"</span>: base,
		<span class="hljs-string">"height"</span>: height,
		<span class="hljs-string">"radius"</span>: radius 
	});

	<span class="hljs-keyword">var</span> surface_props = <span class="hljs-keyword">this</span>.nurbsRep();

	verb.NurbsSurface.call(<span class="hljs-keyword">this</span>, surface_props.degree_u, surface_props.knots_u, surface_props.degree_v, surface_props.knots_v, surface_props.control_points, surface_props.weights );

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'axis'</span>, <span class="hljs-string">'xaxis'</span>, <span class="hljs-string">'base'</span>, <span class="hljs-string">'height'</span>, <span class="hljs-string">'radius'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.Cylinder.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_cylinder_surface'</span>, 
						  												 [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"axis"</span>), 
						  												 	 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xaxis"</span>), 
						  													 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"base"</span>), 
																				 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"height"</span>), 
																				 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"radius"</span>) ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <h3 id="new-ellipse-center-xaxis-yaxis-xradius-yradius-">new Ellipse(center, xaxis, yaxis, xradius, yradius)</h3>
<p>Constructor for EllipseArc</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the center of the arc</li>
<li><em>Array</em>, Length 3 array representing the xaxis</li>
<li><em>Array</em>, Length 3 array representing the perpendicular yaxis</li>
<li><em>Number</em>, Radius of the arc in the x direction</li>
<li><em>Number</em>, Radius of the arc in the y direction</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.Ellipse = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(center, xaxis, yaxis, xradius, yradius)</span> </span>{

	verb.NurbsCurve.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"center"</span>: center,
		<span class="hljs-string">"xaxis"</span>: xaxis,
		<span class="hljs-string">"yaxis"</span>: yaxis,
		<span class="hljs-string">"xradius"</span>: xradius,
		<span class="hljs-string">"yradius"</span>: yradius
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'center'</span>, <span class="hljs-string">'xaxis'</span>, <span class="hljs-string">'yaxis'</span>, <span class="hljs-string">'xradius'</span>, <span class="hljs-string">'yradius'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.Ellipse.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_ellipse_arc'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"center"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xaxis"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"yaxis"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xradius"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"yradius"</span>), 
															 <span class="hljs-number">0</span>, 
															 <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <h3 id="new-ellipsearc-center-xaxis-yaxis-xradius-yradius-interval-">new EllipseArc(center, xaxis, yaxis, xradius, yradius, interval)</h3>
<p>Constructor for EllipseArc</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the center of the arc</li>
<li><em>Array</em>, Length 3 array representing the xaxis</li>
<li><em>Array</em>, Length 3 array representing the perpendicular yaxis</li>
<li><em>Number</em>, Radius of the arc in the x direction</li>
<li><em>Number</em>, Radius of the arc in the y direction</li>
<li><em>Interval</em>, Interval object representing the interval of the arc</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.EllipseArc = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(center, xaxis, yaxis, xradius, yradius, interval)</span> </span>{

	verb.NurbsCurve.call(<span class="hljs-keyword">this</span>);
	
	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"center"</span>: center,
		<span class="hljs-string">"xaxis"</span>: xaxis,
		<span class="hljs-string">"yaxis"</span>: yaxis,
		<span class="hljs-string">"xradius"</span>: xradius,
		<span class="hljs-string">"yradius"</span>: yradius,
		<span class="hljs-string">"interval"</span>: interval
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'center'</span>, <span class="hljs-string">'xaxis'</span>, <span class="hljs-string">'yaxis'</span>, <span class="hljs-string">'xradius'</span>, <span class="hljs-string">'yradius'</span>, <span class="hljs-string">'interval'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.EllipseArc.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_ellipse_arc'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"center"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xaxis"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"yaxis"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xradius"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"yradius"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"interval"</span>).get(<span class="hljs-string">"min"</span>), 
													 		 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"interval"</span>).get(<span class="hljs-string">"max"</span>)] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <h3 id="new-extrusion-p1-p2-p3-pt-">new Extrusion(p1, p2, p3, pt)</h3>
<p>Constructor for Extrusion</p>
<p><strong>params</strong></p>
<ul>
<li><em>NurbsCurve</em>, The curve to extrude</li>
<li><em>Array</em>, Length 3 representing the direction to extrude</li>
<li><em>Number</em>, The distance to extrude</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.Extrusion = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(profile, axis, length )</span> </span>{

	verb.NurbsSurface.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({ 
		  <span class="hljs-string">"profile"</span>: profile,
		  <span class="hljs-string">"axis"</span>: axis,
	      <span class="hljs-string">"length"</span>: length 
	  });

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'axis'</span>, <span class="hljs-string">'length'</span> ], <span class="hljs-keyword">this</span>.update );
	profile.watchAll( [<span class="hljs-string">'knots'</span>, <span class="hljs-string">'degree'</span>, <span class="hljs-string">'controlPoints'</span>, <span class="hljs-string">'weights'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.Extrusion.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_extruded_surface'</span>, 
									[ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"axis"</span>), 
								 	  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"length"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"knots"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"degree"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"controlPoints"</span>),
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"weights"</span>)] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <h3 id="new-fourpointsurface-p1-p2-p3-pt-">new FourPointSurface(p1, p2, p3, pt)</h3>
<p>Constructor for FourPointSurface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the first position in ccw direction</li>
<li><em>Array</em>, Length 3 array representing the second position in ccw direction</li>
<li><em>Array</em>, Length 3 array representing the third position in ccw direction</li>
<li><em>Array</em>, Length 3 array representing the fourth position in ccw direction, repeat the third position to get a triangle</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.FourPointSurface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(p1, p2, p3, p4)</span> </span>{

	verb.NurbsSurface.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll( {
		<span class="hljs-string">"p1"</span>: p1,
		<span class="hljs-string">"p2"</span>: p2,
		<span class="hljs-string">"p3"</span>: p3,
		<span class="hljs-string">"p4"</span>: p4
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'p1'</span>, <span class="hljs-string">'p2'</span>, <span class="hljs-string">'p3'</span>, <span class="hljs-string">'p4'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.FourPointSurface.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_4pt_surface'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"p1"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"p2"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"p3"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"p4"</span>) ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <h3 id="new-interpcurve-pts-degree-starttangent-endtangent-">new InterpCurve(pts [, degree, startTangent, endTangent])</h3>
<p>Constructor for InterpCurve</p>
<p>Note that you must supply both start and end tangent if you do include this parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Array of Length 3 arrays representing the points to interpolate (must be &gt; degree + 1)</li>
<li><em>Number</em>, Default of 3. Expected degree of curve.</li>
<li><em>Array</em>, No default. The tangent vector (first derivative) at the start of the curve.</li>
<li><em>Array</em>, No default. The tangent vector (second derivative) at the end of the curve.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.InterpCurve = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(points, degree, startTangent, endTangent )</span> </span>{

	verb.NurbsCurve.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">var</span> atts = {
		<span class="hljs-string">"pts"</span>: points ? points.slice(<span class="hljs-number">0</span>) : [],
		<span class="hljs-string">"degree"</span> : degree ? degree : <span class="hljs-number">3</span>
	};

	<span class="hljs-keyword">if</span> (startTangent &amp;&amp; endTangent){
		atts.startTangent = startTangent;
		atts.endTangent = endTangent;
	}

	<span class="hljs-keyword">this</span>.setAll( atts );

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">var</span> watchList = [<span class="hljs-string">'pts'</span>, <span class="hljs-string">'degree'</span>];

	<span class="hljs-keyword">if</span> (startTangent &amp;&amp; endTangent){
		watchList.push( <span class="hljs-string">"startTangent"</span> );
		watchList.push( <span class="hljs-string">"endTangent"</span> );
	}

	<span class="hljs-keyword">this</span>.watchAll( watchList, <span class="hljs-keyword">this</span>.update );

}.inherits(verb.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.InterpCurve.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_interp_curve'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"pts"</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'startTangent'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'endTangent'</span>)]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <h3 id="new-interval-min-max-">new Interval(min, max)</h3>
<p>Constructor for Interval</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Start of interval </li>
<li><em>Number</em>, End of the interval </li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.Interval = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(min, max)</span> </span>{

	verb.core.WatchObject.call(<span class="hljs-keyword">this</span>);
	
	<span class="hljs-keyword">this</span>.setAll({ 
		<span class="hljs-string">"min"</span>: min,
		<span class="hljs-string">"max"</span>: max 
	});

}.inherits(verb.core.WatchObject);</pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <h3 id="new-interval2-minu-maxu-minv-maxv-">new Interval2(minu, maxu, minv, maxv)</h3>
<p>Constructor for Interval2</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Start of interval in the u direction</li>
<li><em>Number</em>, End of the interval in the u direction</li>
<li><em>Number</em>, Start of interval in the v direction</li>
<li><em>Number</em>, End of the interval in the v direction</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.Interval2 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(minu, maxu, minv, maxv)</span> </span>{

	verb.core.WatchObject.call(<span class="hljs-keyword">this</span>);
	
	<span class="hljs-keyword">this</span>.setAll({ 
		<span class="hljs-string">"uinterval"</span>: <span class="hljs-keyword">new</span> verb.Interval(minu, maxu),
		<span class="hljs-string">"vinterval"</span>: <span class="hljs-keyword">new</span> verb.Interval(minv, maxv)
	});

}.inherits(verb.core.WatchObject);</pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <h3 id="new-line-start-end-">new Line(start, end)</h3>
<p>Constructor for a Line</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the start point</li>
<li><em>Array</em>, Length 3 array representing the end point</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.Line = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(start, end)</span> </span>{

	verb.NurbsCurve.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({ 
		<span class="hljs-string">"start"</span>: start,
		<span class="hljs-string">"end"</span>: end
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll([<span class="hljs-string">'start'</span>, <span class="hljs-string">'end'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.Line.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">return</span> {
			knots: [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], 
			control_points: [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"start"</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"end"</span>) ],
			weights: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],
			degree: <span class="hljs-number">1</span>
	};

};</pre></div></div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>
              <h3 id="new-planarsurface-base-uaxis-vaxis-ulength-vlength-">new PlanarSurface( base, uaxis, vaxis, ulength, vlength )</h3>
<p>Constructor for PlanarSurface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the base point</li>
<li><em>Array</em>, Length 3 array representing the uaxis, defines the one axis of the planar surface</li>
<li><em>Array</em>, Length 3 array representing the vaxis, defines the one second axis of the planar surface</li>
<li><em>Number</em>, Length in the u direction </li>
<li><em>Number</em>, Length in the v direction</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.PlanarSurface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( base, uaxis, vaxis, ulength, vlength )</span> </span>{

	verb.NurbsSurface.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"base"</span>: base,
		<span class="hljs-string">"uaxis"</span>: uaxis,
		<span class="hljs-string">"vaxis"</span>: vaxis,
		<span class="hljs-string">"ulength"</span>: ulength,
		<span class="hljs-string">"vlength"</span>: vlength
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'base'</span>, <span class="hljs-string">'uaxis'</span>, <span class="hljs-string">'vaxis'</span>, <span class="hljs-string">'ulength'</span>, <span class="hljs-string">'vlength'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.PlanarSurface.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'base'</span>)
		, uedge = numeric.mul( <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'uaxis'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'ulength'</span>))
		, vedge = numeric.mul( <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'vaxis'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'vlength'</span>))
		, p2 = numeric.add( p1, uedge )
		, p3 = numeric.add( p1, vedge, uedge )
		, p4 = numeric.add( p1, vedge );

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_4pt_surface'</span>, [ p1, p2, p3, p4 ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <h3 id="new-polyline-points-">new PolyLine( points )</h3>
<p>Constructor for a PolyLine</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Array of length-3 arrays representing the points</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.PolyLine = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points )</span> </span>{

	verb.NurbsCurve.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll( {
		<span class="hljs-string">"control_points"</span>: points ? points.slice(<span class="hljs-number">0</span>) : []
	});

	<span class="hljs-keyword">this</span>.update();

}.inherits(verb.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.PolyLine.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_polyline_curve'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"control_points"</span>) ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>
              <h3 id="new-revolvedsurface-points-">new RevolvedSurface( points )</h3>
<p>Constructor for a RevolvedSurface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing a point on the revolve axis</li>
<li><em>Array</em>, The axis of the revolve</li>
<li><em>Array</em>, The angle to revolve on</li>
<li><em>NurbsCurve</em>, The curve to revolve</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.RevolvedSurface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( center, axis, angle, profile )</span> </span>{

	verb.NurbsSurface.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"center"</span>: center,
		<span class="hljs-string">"axis"</span>: axis,
		<span class="hljs-string">"angle"</span>: angle,
		<span class="hljs-string">"profile"</span>: profile
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'center'</span>, <span class="hljs-string">'axis'</span>, <span class="hljs-string">'angle'</span>, <span class="hljs-string">'profile'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.RevolvedSurface.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

	  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_revolved_surface'</span>, 
									[ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"center"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"axis"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"angle"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"knots"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"degree"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"controlPoints"</span>),
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"weights"</span>)] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <h3 id="new-sphere-center-radius-">new Sphere( center, radius )</h3>
<p>Constructor for a Sphere</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the center</li>
<li><em>Number</em>, Radius of the sphere</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.Sphere = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( center, radius )</span> </span>{

	verb.NurbsSurface.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"center"</span>: center,
		<span class="hljs-string">"radius"</span>: radius
	});

	<span class="hljs-keyword">this</span>.update();
	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'center'</span>, <span class="hljs-string">'radius'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.Sphere.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_sphere_surface'</span>, 
										[ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"center"</span>), 
										  [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],
										  [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"radius"</span>)] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <h3 id="new-sweeponerail-rail-profile-">new SweepOneRail( rail, profile )</h3>
<p>Constructor for a SweepOneRail</p>
<p><strong>params</strong></p>
<ul>
<li><em>NurbsCurve</em>, The path to sweep on</li>
<li><em>NurbsCurve</em>, The profile to sweep</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.SweepOneRail = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( rail, profile )</span> </span>{

	verb.NurbsSurface.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"rail"</span>: rail,
		<span class="hljs-string">"profile"</span>: profile
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'rail'</span>, <span class="hljs-string">'profile'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.SweepOneRail.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
	
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_sweep1_surface'</span>, 
										[ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"knots"</span>), 
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"degree"</span>),
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"controlPoints"</span>),
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"weights"</span>),
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"rail"</span>).get(<span class="hljs-string">"knots"</span>),
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"rail"</span>).get(<span class="hljs-string">"degree"</span>),
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"rail"</span>).get(<span class="hljs-string">"controlPoints"</span>),
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"rail"</span>).get(<span class="hljs-string">"weights"</span>)] );

};
verb.intersectCurves = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( curve1, curve2, callback )</span></span>{

	<span class="hljs-keyword">return</span> verb.nurbsEngine.eval( <span class="hljs-string">'intersect_rational_curves_by_aabb_refine'</span>, 
							[ 	curve1.get(<span class="hljs-string">'degree'</span>), curve1.get(<span class="hljs-string">'knots'</span>), curve1.homogenize(), 
							curve2.get(<span class="hljs-string">'degree'</span>), curve2.get(<span class="hljs-string">'knots'</span>), 
							curve2.homogenize(), verb.TOLERANCE, verb.TOLERANCE ], callback );
}
verb.intersectCurveSurface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( curve, surface, options, callback )</span></span>{

	options = options || { tolerance: verb.TOLERANCE, sampleTolerance: verb.TOLERANCE, uDivs: <span class="hljs-number">20</span>, vDivs: <span class="hljs-number">20</span> };

	<span class="hljs-keyword">return</span> verb.nurbsEngine.eval( <span class="hljs-string">'intersect_rational_curve_surface_by_aabb_refine'</span>, 
																[ surface.get(<span class="hljs-string">'degreeU'</span>), 
																	surface.get(<span class="hljs-string">'knotsU'</span>), 
																	surface.get(<span class="hljs-string">'degreeV'</span>), 
																	surface.get(<span class="hljs-string">'knotsV'</span>), 
																	surface.homogenize(), 
																	curve.get(<span class="hljs-string">'degree'</span>), 
																	curve.get(<span class="hljs-string">'knots'</span>), 
																	curve.homogenize(), 
																	options.sampleTolerance, 
																	options.tolerance, 
																	options.uDivs,
																	options.vDivs ], callback );
};</pre></div></div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>
              <h4 id="intersect_rational_curve_surface_by_aabb-degree_u-knots_u-degree_v-knots_v-homo_control_points-degree_crv-knots_crv-homo_control_points_crv-sample_tol-tol-">intersect_rational_curve_surface_by_aabb( degree_u, knots_u, degree_v, knots_v, homo_control_points, degree_crv, knots_crv, homo_control_points_crv, sample_tol, tol )</h4>
<p>Get the intersection of a NURBS curve and a NURBS surface by axis-aligned bounding box intersection and refinement</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of homogeneous control points, top to bottom is increasing u direction, left to right is increasing v direction,
and where each control point is an array of length (dim+1)</li>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi)</li>
<li><em>Number</em>, the sample tolerance of the curve</li>
<li><em>Number</em>, tolerance for the curve intersection</li>
<li><em>Number</em>, integer number of divisions of the surface in the U direction for initial approximation (placeholder until adaptive tess of surfaces)</li>
<li><em>Number</em>, integer number of divisions of the surface in the V direction for initial approximation (placeholder until adaptive tess of surfaces)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, array of intersection objects, each holding:<ul>
<li>a “point” property where intersections took place</li>
<li>a “p” the parameter on the curve</li>
</ul>
</li>
<li>a “uv” the parameter on the surface<ul>
<li>a “face” the index of the face where the intersection took place</li>
</ul>
</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.intersect_rational_curve_surface_by_aabb_refine = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, 
	knots_v, homo_control_points_srf, degree_crv, knots_crv, homo_control_points_crv, sample_tol, tol, 
	divs_u, divs_v )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <p>get the approximate intersections</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> ints = verb.eval.intersect_rational_curve_surface_by_aabb( degree_u, knots_u, degree_v, 
		knots_v, homo_control_points_srf, degree_crv, knots_crv, homo_control_points_crv, sample_tol, tol, 
		divs_u, divs_v );</pre></div></div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>
              <p>refine them</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> ints.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( inter )</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-152">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-152">&#182;</a>
              </div>
              <p>get intersection params</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> start_params = [inter.p, inter.uv[<span class="hljs-number">0</span>], inter.uv[<span class="hljs-number">1</span>] ]</pre></div></div>
            
        </li>
        
        
        <li id="section-153">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-153">&#182;</a>
              </div>
              <p>refine the parameters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			, refined_params = verb.eval.refine_rational_curve_surface_intersection( degree_u, knots_u, degree_v, knots_v, homo_control_points_srf, degree_crv, knots_crv, homo_control_points_crv, start_params );</pre></div></div>
            
        </li>
        
        
        <li id="section-154">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-154">&#182;</a>
              </div>
              <p>update the inter object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		inter.p = refined_params[<span class="hljs-number">0</span>];
		inter.uv[<span class="hljs-number">0</span>] = refined_params[<span class="hljs-number">1</span>];
		inter.uv[<span class="hljs-number">1</span>] = refined_params[<span class="hljs-number">2</span>];
		inter.distance = refined_params[<span class="hljs-number">3</span>];
		<span class="hljs-keyword">delete</span> inter.face;

		<span class="hljs-keyword">return</span> inter;

	});

}</pre></div></div>
            
        </li>
        
        
        <li id="section-155">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-155">&#182;</a>
              </div>
              <h4 id="refine_rational_curve_surface_intersection-degree_u-knots_u-degree_v-knots_v-homo_control_points_srf-degree_crv-knots_crv-homo_control_points_crv-start_params-">refine_rational_curve_surface_intersection( degree_u, knots_u, degree_v, knots_v, homo_control_points_srf, degree_crv, knots_crv, homo_control_points_crv, start_params )</h4>
<p>Refine an intersection pair for a surface and curve given an initial guess.  This is an unconstrained minimization,
so the caller is responsible for providing a very good initial guess.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of homogeneous control points, top to bottom is increasing u direction, left to right is increasing v direction,
and where each control point is an array of length (dim+1)</li>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi)</li>
<li><em>Array</em>, array of initial parameter values [ u_crv, u_srf, v_srf ]</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a length 3 array containing the [ u_crv, u_srf, v_srf, final_distance ]</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.refine_rational_curve_surface_intersection = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points_srf, degree_crv, knots_crv, homo_control_points_crv, start_params )</span> </span>{

	<span class="hljs-keyword">var</span> objective = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span> </span>{ 

		<span class="hljs-keyword">var</span> p1 = verb.eval.rational_curve_point(degree_crv, knots_crv, homo_control_points_crv, x[<span class="hljs-number">0</span>])
			, p2 = verb.eval.rational_surface_point( degree_u, knots_u,  degree_v, knots_v, homo_control_points_srf, x[<span class="hljs-number">1</span>], x[<span class="hljs-number">2</span>] )
			, p1_p2 = numeric.sub(p1, p2);

		<span class="hljs-keyword">return</span> numeric.dot(p1_p2, p1_p2);
	}

	<span class="hljs-keyword">var</span> sol_obj = numeric.uncmin( objective, start_params);
	<span class="hljs-keyword">return</span> sol_obj.solution.concat( sol_obj.f );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-156">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-156">&#182;</a>
              </div>
              <h4 id="intersect_rational_curve_surface_by_aabb-degree_u-knots_u-degree_v-knots_v-homo_control_points-degree_crv-knots_crv-homo_control_points_crv-sample_tol-tol-">intersect_rational_curve_surface_by_aabb( degree_u, knots_u, degree_v, knots_v, homo_control_points, degree_crv, knots_crv, homo_control_points_crv, sample_tol, tol )</h4>
<p>Approximate the intersection of two nurbs surface by axis-aligned bounding box intersection.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of homogeneous control points, top to bottom is increasing u direction, left to right is increasing v direction,
and where each control point is an array of length (dim+1)</li>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi)</li>
<li><em>Array</em>, array of initial parameter values [ u_crv, u_srf, v_srf ]</li>
<li><em>Number</em>, the sample tolerance of the curve</li>
<li><em>Number</em>, tolerance for the curve intersection</li>
<li><em>Number</em>, integer number of divisions of the surface in the U direction</li>
<li><em>Number</em>, integer number of divisions of the surface in the V direction</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, array of intersection objects, each holding:<ul>
<li>a “point” property where intersections took place</li>
<li>a “p” the parameter on the polyline</li>
</ul>
</li>
<li>a “uv” the parameter on the mesh<ul>
<li>a “face” the index of the face where the intersection took place</li>
</ul>
</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.intersect_rational_curve_surface_by_aabb = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points_srf, degree_crv, knots_crv, homo_control_points_crv, sample_tol, tol, divs_u, divs_v )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-157">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-157">&#182;</a>
              </div>
              <p>tessellate the curve</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> crv = verb.eval.rational_curve_adaptive_sample( degree_crv, knots_crv, homo_control_points_crv, sample_tol, <span class="hljs-literal">true</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-158">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-158">&#182;</a>
              </div>
              <p>tessellate the surface</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		, mesh = verb.eval.tessellate_rational_surface_naive( degree_u, knots_u, degree_v, knots_v, homo_control_points_srf, divs_u, divs_v )</pre></div></div>
            
        </li>
        
        
        <li id="section-159">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-159">&#182;</a>
              </div>
              <p>separate parameters from points in the polyline (params are the first index in the array)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		, u1 = crv.map( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el)</span> </span>{ <span class="hljs-keyword">return</span> el[<span class="hljs-number">0</span>]; })
		, p1 = crv.map( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el)</span> </span>{ <span class="hljs-keyword">return</span> el.slice(<span class="hljs-number">1</span>) })</pre></div></div>
            
        </li>
        
        
        <li id="section-160">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-160">&#182;</a>
              </div>
              <p>perform intersection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		, res = verb.eval.intersect_parametric_polyline_mesh_by_aabb( p1, u1, mesh, verb.range(mesh.faces.length), tol );</pre></div></div>
            
        </li>
        
        
        <li id="section-161">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-161">&#182;</a>
              </div>
              <p>eliminate duplicate intersections</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> verb.unique( res, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span></span>{
		<span class="hljs-keyword">return</span> numeric.norm2( numeric.sub( a.point, b.point ) ) &lt; tol &amp;&amp; <span class="hljs-built_in">Math</span>.abs( a.p - b.p ) &lt; tol &amp;&amp; numeric.norm2( numeric.sub( a.uv, b.uv ) ) &lt; tol
	});

}</pre></div></div>
            
        </li>
        
        
        <li id="section-162">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-162">&#182;</a>
              </div>
              <h4 id="intersect_parametric_polyline_mesh_by_aabb-crv_points-crv_param_points-mesh-included_faces-tol-">intersect_parametric_polyline_mesh_by_aabb( crv_points, crv_param_points, mesh, included_faces, tol )</h4>
<p>Approximate the intersection of a polyline and mesh while maintaining parameter information</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of 3d points on the curve</li>
<li><em>Array</em>, array of parameters corresponding to the parameters on the curve</li>
<li><em>Object</em>, a triangular mesh with a “faces” attribute and “points” attribute</li>
<li><em>Array</em>, an array of indices, representing the faces to include in the intersection operation</li>
<li><em>Number</em>, tolerance for the intersection</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, array of intersection objects (with potential duplicates ) each holding:<ul>
<li>a “point” property where intersections took place</li>
<li>a “p” the parameter on the polyline</li>
</ul>
</li>
<li>a “uv” the parameter on the mesh<ul>
<li>a “face” the index of the face where the intersection took place</li>
</ul>
</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.intersect_parametric_polyline_mesh_by_aabb = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( crv_points, crv_param_points, mesh, included_faces, tol )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-163">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-163">&#182;</a>
              </div>
              <p>check if two bounding boxes intersect</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> pl_bb = <span class="hljs-keyword">new</span> verb.BoundingBox( crv_points )
		, mesh_bb = verb.eval.make_mesh_aabb( mesh.points, mesh.faces, included_faces )
		, rec = verb.eval.intersect_parametric_polyline_mesh_by_aabb;</pre></div></div>
            
        </li>
        
        
        <li id="section-164">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-164">&#182;</a>
              </div>
              <p>if bounding boxes do not intersect, return empty array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> ( !pl_bb.intersects( mesh_bb, tol ) ) {
		<span class="hljs-keyword">return</span> [];
	}

	<span class="hljs-keyword">if</span> ( crv_points.length === <span class="hljs-number">2</span> &amp;&amp; included_faces.length === <span class="hljs-number">1</span> ){</pre></div></div>
            
        </li>
        
        
        <li id="section-165">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-165">&#182;</a>
              </div>
              <p>intersect segment and triangle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
			<span class="hljs-keyword">var</span> inter = verb.eval.intersect_segment_with_tri( crv_points[<span class="hljs-number">0</span>], crv_points[<span class="hljs-number">1</span>], mesh.points, mesh.faces[ included_faces[<span class="hljs-number">0</span>] ] );

			<span class="hljs-keyword">if</span> ( inter != <span class="hljs-literal">null</span> ){</pre></div></div>
            
        </li>
        
        
        <li id="section-166">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-166">&#182;</a>
              </div>
              <p>map the parameters of the segment to the parametric space of the entire polyline</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			 	<span class="hljs-keyword">var</span> p = inter.p * ( crv_param_points[<span class="hljs-number">1</span>]-crv_param_points[<span class="hljs-number">0</span>] ) + crv_param_points[<span class="hljs-number">0</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-167">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-167">&#182;</a>
              </div>
              <p>map the parameters of the single triangle to the entire parametric space of the triangle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			 	<span class="hljs-keyword">var</span> index_v0 = mesh.faces[ included_faces ][<span class="hljs-number">0</span>]
			 		, index_v1 = mesh.faces[ included_faces ][<span class="hljs-number">1</span>]
			 		, index_v2 = mesh.faces[ included_faces ][<span class="hljs-number">2</span>]
			 		, uv_v0 = mesh.uvs[ index_v0 ]
			 		, uv_v1 = mesh.uvs[ index_v1 ]
			 		, uv_v2 = mesh.uvs[ index_v2 ]
			 		, uv_s_diff = numeric.sub( uv_v1, uv_v0 )
			 		, uv_t_diff = numeric.sub( uv_v2, uv_v0 )
			 		, uv = numeric.add( uv_v0, numeric.mul( inter.s, uv_s_diff ), numeric.mul( inter.t, uv_t_diff ) );</pre></div></div>
            
        </li>
        
        
        <li id="section-168">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-168">&#182;</a>
              </div>
              <p>a pair representing the param on the polyline and the param on the mesh</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			 	<span class="hljs-keyword">return</span> [ { point: inter.point, p: p, uv: uv, face: included_faces[<span class="hljs-number">0</span>] } ]; 

			}

	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( included_faces.length === <span class="hljs-number">1</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-169">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-169">&#182;</a>
              </div>
              <p>intersect triangle and polyline</p>

            </div>
            
        </li>
        
        
        <li id="section-170">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-170">&#182;</a>
              </div>
              <p>divide polyline in half, rightside includes the pivot</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> crv_points_a = verb.left( crv_points )
			, crv_points_b = verb.rightWithPivot( crv_points )
			, crv_param_points_a = verb.left( crv_param_points )
			, crv_param_points_b = verb.rightWithPivot( crv_param_points );

		<span class="hljs-keyword">return</span> 	 rec( crv_points_a, crv_param_points_a, mesh, included_faces, tol )
		.concat( rec( crv_points_b, crv_param_points_b, mesh, included_faces, tol ) );

	
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( crv_points.length === <span class="hljs-number">2</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-171">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-171">&#182;</a>
              </div>
              <p>intersect mesh &gt;2 faces and line</p>

            </div>
            
        </li>
        
        
        <li id="section-172">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-172">&#182;</a>
              </div>
              <p>divide mesh in “half” by first sorting then dividing array in half</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> sorted_included_faces = verb.eval.sort_tris_on_longest_axis( mesh_bb, mesh.points, mesh.faces, included_faces )
			, included_faces_a = verb.left( sorted_included_faces )
			, included_faces_b = verb.right( sorted_included_faces );

		<span class="hljs-keyword">return</span> 		 rec( crv_points, crv_param_points, mesh, included_faces_a, tol )
			.concat( rec( crv_points, crv_param_points, mesh, included_faces_b, tol ));


	} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-173">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-173">&#182;</a>
              </div>
              <p>intersect mesh with &gt;2 faces and polyline</p>

            </div>
            
        </li>
        
        
        <li id="section-174">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-174">&#182;</a>
              </div>
              <p>divide mesh in “half”</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> sorted_included_faces = verb.eval.sort_tris_on_longest_axis( mesh_bb, mesh.points, mesh.faces, included_faces )
			, included_faces_a = verb.left( sorted_included_faces )
			, included_faces_b = verb.right( sorted_included_faces );</pre></div></div>
            
        </li>
        
        
        <li id="section-175">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-175">&#182;</a>
              </div>
              <p>divide polyline in half, rightside includes the pivot</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> crv_points_a = verb.left( crv_points )
			, crv_points_b = verb.rightWithPivot( crv_points )
			, crv_param_points_a = verb.left( crv_param_points )
			, crv_param_points_b = verb.rightWithPivot( crv_param_points );

		<span class="hljs-keyword">return</span> 	 	 rec( crv_points_a, crv_param_points_a, mesh, included_faces_a, tol )
			.concat( rec( crv_points_a, crv_param_points_a, mesh, included_faces_b, tol ) )
			.concat( rec( crv_points_b, crv_param_points_b, mesh, included_faces_a, tol ) )
			.concat( rec( crv_points_b, crv_param_points_b, mesh, included_faces_b, tol ) );

	}

	<span class="hljs-keyword">return</span> [];

}</pre></div></div>
            
        </li>
        
        
        <li id="section-176">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-176">&#182;</a>
              </div>
              <h4 id="intersect_segment_with_tri-p1-p0-points-tri-">intersect_segment_with_tri(  p1, p0, points, tri )</h4>
<p> Intersect segment with triangle (from <a href="http://geomalgorithms.com/a06-_intersect-2.html">http://geomalgorithms.com/a06-_intersect-2.html</a>)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 representing first point of the segment</li>
<li><em>Array</em>, array of length 3 representing second point of the segment</li>
<li><em>Array</em>, array of length 3 arrays representing the points of the triangle</li>
<li><em>Array</em>, array of length 3 containing int indices in the array of points, this allows passing a full mesh</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with an “intersects” property that is true or false and if true, a 
“s” property giving the param on u, and “t” is the property on v, where u is the 
axis from v0 to v1, and v is v0 to v1, a “point” property
where the intersection took place, and “p” property representing the parameter along the segment</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.intersect_segment_with_tri = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( p0, p1, points, tri )</span> </span>{

	<span class="hljs-keyword">var</span> v0 = points[ tri[<span class="hljs-number">0</span>] ]
		, v1 = points[ tri[<span class="hljs-number">1</span>] ]
		, v2 = points[ tri[<span class="hljs-number">2</span>] ]
		, u = numeric.sub( v1, v0 )
		, v = numeric.sub( v2, v0 )
		, n = numeric.cross( u, v );

	<span class="hljs-keyword">var</span> dir = numeric.sub( p1, p0 )
		, w0 = numeric.sub( p0, v0 )
		, a = -numeric.dot( n, w0 )
		, b = numeric.dot( n, dir )</pre></div></div>
            
        </li>
        
        
        <li id="section-177">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-177">&#182;</a>
              </div>
              <p>is ray is parallel to triangle plane?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> ( <span class="hljs-built_in">Math</span>.abs( b ) &lt; verb.EPSILON ){ 
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">var</span> r = a / b;</pre></div></div>
            
        </li>
        
        
        <li id="section-178">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-178">&#182;</a>
              </div>
              <p>segment goes away from triangle or is beyond segment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> ( r &lt; <span class="hljs-number">0</span> || r &gt; <span class="hljs-number">1</span> ){
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-179">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-179">&#182;</a>
              </div>
              <p>get proposed intersection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> pt = numeric.add( p0, numeric.mul( r, dir ) );</pre></div></div>
            
        </li>
        
        
        <li id="section-180">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-180">&#182;</a>
              </div>
              <p>is I inside T?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> uv = numeric.dot(u,v)
		, uu = numeric.dot(u,u)
		, vv = numeric.dot(v,v)
		, w = numeric.sub( pt, v0 )
		, wu = numeric.dot( w, u )
		, wv = numeric.dot( w, v )
		, denom = uv * uv - uu * vv
		, s = ( uv * wv - vv * wu ) / denom
		, t = ( uv * wu - uu * wv ) / denom;

	<span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">1.0</span> + verb.EPSILON || t &gt; <span class="hljs-number">1.0</span> + verb.EPSILON || t &lt; -verb.EPSILON || s &lt; -verb.EPSILON || s + t &gt; <span class="hljs-number">1.0</span> + verb.EPSILON){
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">return</span> { point: pt, s: s, t: t, p: r };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-181">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-181">&#182;</a>
              </div>
              <h4 id="intersect_segment_with_plane-p0-p1-v0-n-">intersect_segment_with_plane( p0, p1, v0, n )</h4>
<p> Intersect ray/segment with plane (from <a href="http://geomalgorithms.com/a06-_intersect-2.html">http://geomalgorithms.com/a06-_intersect-2.html</a>)</p>
<p> If intersecting a ray, the param needs to be between 0 and 1 and the caller is responsible
 for making that check</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 representing first point of the segment</li>
<li><em>Array</em>, array of length 3 representing second point of the segment</li>
<li><em>Array</em>, array of length 3 representing an origin point on the plane</li>
<li><em>Array</em>, array of length 3 representing the normal of the plane</li>
</ul>
<p><strong>returns</strong> 
null or an object with a p property representing the param on the segment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.intersect_segment_with_plane = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( p0, p1, v0, n )</span> </span>{

	<span class="hljs-keyword">var</span> denom = numeric.dot( n, numeric.sub(p0,p1) );</pre></div></div>
            
        </li>
        
        
        <li id="section-182">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-182">&#182;</a>
              </div>
              <p>parallel case</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> ( abs( denom ) &lt; EPSILON ) { 
   	<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
 	}

 	<span class="hljs-keyword">var</span> numer = numeric.dot( n, numeric.sub(v0,p0) );

	<span class="hljs-keyword">return</span> { p: numer / denom };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-183">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-183">&#182;</a>
              </div>
              <h4 id="intersect_aabb_trees-points1-tris1-points2-tris2-aabb_tree1-aabb_tree2-">intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1, aabb_tree2 )</h4>
<p> Intersect two aabb trees - a recursive function</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points of mesh1</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles of mesh1</li>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points of mesh2</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles of mesh2</li>
<li><em>Object</em>, nested object representing the aabb tree of the first mesh</li>
<li><em>Object</em>, nested object representing the aabb tree of the second mesh</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a list of pairs of triangle indices for mesh1 and mesh2 that are intersecting</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.intersect_aabb_trees = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points1, tris1, points2, tris2, aabb_tree1, aabb_tree2 )</span> </span>{

  <span class="hljs-keyword">var</span> intersects = aabb_tree1.bounding_box.intersects( aabb_tree2.bounding_box );

  <span class="hljs-keyword">var</span> recur = verb.eval.intersect_aabb_trees;

  <span class="hljs-keyword">if</span> (!intersects){
  	<span class="hljs-keyword">return</span> [];
  }

  <span class="hljs-keyword">if</span> (aabb_tree1.children.length === <span class="hljs-number">0</span> &amp;&amp; aabb_tree2.children.length === <span class="hljs-number">0</span>){ 

  	<span class="hljs-keyword">return</span> [ [aabb_tree1.triangle, aabb_tree2.triangle ] ]; 

  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aabb_tree1.children.length === <span class="hljs-number">0</span> &amp;&amp; aabb_tree2.children.length != <span class="hljs-number">0</span>){

  	<span class="hljs-keyword">return</span>     recur( points1, tris1, points2, tris2, aabb_tree1, aabb_tree2.children[<span class="hljs-number">0</span>] )
  		.concat( recur( points1, tris1, points2, tris2, aabb_tree1, aabb_tree2.children[<span class="hljs-number">1</span>] ) );

  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aabb_tree1.children.length != <span class="hljs-number">0</span> &amp;&amp; aabb_tree2.children.length === <span class="hljs-number">0</span>){

  	<span class="hljs-keyword">return</span>     recur( points1, tris1, points2, tris2, aabb_tree1.children[<span class="hljs-number">0</span>], aabb_tree2 )
  		.concat( recur( points1, tris1, points2, tris2, aabb_tree1.children[<span class="hljs-number">1</span>], aabb_tree2 ) );

  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aabb_tree1.children.length != <span class="hljs-number">0</span> &amp;&amp; aabb_tree2.children.length != <span class="hljs-number">0</span>){

  	<span class="hljs-keyword">return</span>     recur( points1, tris1, points2, tris2, aabb_tree1.children[<span class="hljs-number">0</span>], aabb_tree2.children[<span class="hljs-number">0</span>] )
  		.concat( recur( points1, tris1, points2, tris2, aabb_tree1.children[<span class="hljs-number">0</span>], aabb_tree2.children[<span class="hljs-number">1</span>] ) )
  		.concat( recur( points1, tris1, points2, tris2, aabb_tree1.children[<span class="hljs-number">1</span>], aabb_tree2.children[<span class="hljs-number">0</span>] ) )
  		.concat( recur( points1, tris1, points2, tris2, aabb_tree1.children[<span class="hljs-number">1</span>], aabb_tree2.children[<span class="hljs-number">1</span>] ) );

  }

}</pre></div></div>
            
        </li>
        
        
        <li id="section-184">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-184">&#182;</a>
              </div>
              <h4 id="make_mesh_aabb_tree-points-tris-tri_indices-">make_mesh_aabb_tree( points, tris, tri_indices )</h4>
<p>Make tree of axis aligned bounding boxes </p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles</li>
<li><em>Array</em>, array of numbers representing the relevant triangles to use to form aabb</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.make_mesh_aabb_tree = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points, tris, tri_indices )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-185">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-185">&#182;</a>
              </div>
              <p>build bb</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> aabb = { 	bounding_box: verb.eval.make_mesh_aabb( points, tris, tri_indices ), 
								children: [] };</pre></div></div>
            
        </li>
        
        
        <li id="section-186">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-186">&#182;</a>
              </div>
              <p>if only one ele, terminate recursion and store the triangles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (tri_indices.length === <span class="hljs-number">1</span>){
		aabb.triangle = tri_indices[<span class="hljs-number">0</span>];
		<span class="hljs-keyword">return</span> aabb;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-187">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-187">&#182;</a>
              </div>
              <p>sort triangles in sub mesh</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> sorted_tri_indices = verb.eval.sort_tris_on_longest_axis( aabb.bounding_box, points, tris, tri_indices )
		, tri_indices_a = sorted_tri_indices.slice( <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.floor( sorted_tri_indices.length / <span class="hljs-number">2</span> ) )
		, tri_indices_b = sorted_tri_indices.slice( <span class="hljs-built_in">Math</span>.floor( sorted_tri_indices.length / <span class="hljs-number">2</span> ), sorted_tri_indices.length );</pre></div></div>
            
        </li>
        
        
        <li id="section-188">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-188">&#182;</a>
              </div>
              <p>recurse </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	aabb.children = [ verb.eval.make_mesh_aabb_tree(points, tris, tri_indices_a), 
										verb.eval.make_mesh_aabb_tree(points, tris, tri_indices_b) ];</pre></div></div>
            
        </li>
        
        
        <li id="section-189">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-189">&#182;</a>
              </div>
              <p>return result</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> aabb;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-190">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-190">&#182;</a>
              </div>
              <h4 id="make_mesh_aabb-points-tris-tri_indices-">make_mesh_aabb( points, tris, tri_indices )</h4>
<p>Form axis-aligned bounding box from triangles of mesh</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles</li>
<li><em>Array</em>, array of numbers representing the relevant triangles</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.make_mesh_aabb = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points, tris, tri_indices )</span> </span>{

	<span class="hljs-keyword">var</span> bb = <span class="hljs-keyword">new</span> verb.BoundingBox();

	tri_indices.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span>{
		bb.add( points[ tris[ x ][<span class="hljs-number">0</span>] ] );
		bb.add( points[ tris[ x ][<span class="hljs-number">1</span>] ] );
		bb.add( points[ tris[ x ][<span class="hljs-number">2</span>] ] );
	});

	<span class="hljs-keyword">return</span> bb;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-191">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-191">&#182;</a>
              </div>
              <h4 id="sort_tris_on_longest_axis-container_bb-points-tris-tri_indices-">sort_tris_on_longest_axis( container_bb, points, tris, tri_indices )</h4>
<p>Sort triangles on longest axis</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.sort_tris_on_longest_axis = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( container_bb, points, tris, tri_indices )</span> </span>{

	<span class="hljs-keyword">var</span> long_axis = container_bb.getLongestAxis();

	<span class="hljs-keyword">var</span> axis_position_map = [];
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = tri_indices.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {

		<span class="hljs-keyword">var</span> tri_i = tri_indices[i],
			tri_min = verb.eval.get_min_coordinate_on_axis( points, tris[ tri_i ], long_axis );

		axis_position_map.push( [ tri_min, tri_i ] );

	}

	axis_position_map.sort(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b)</span> </span>{ <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>] } );

	<span class="hljs-keyword">var</span> sorted_tri_indices = [];
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = axis_position_map.length; i &lt; l; i++) {
		sorted_tri_indices.push( axis_position_map[i][<span class="hljs-number">1</span>] );
	}

	<span class="hljs-keyword">return</span> sorted_tri_indices;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-192">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-192">&#182;</a>
              </div>
              <h4 id="get_min_coordinate_on_axis-points-tri-axis-">get_min_coordinate_on_axis( points, tri, axis )</h4>
<p>Get min coordinate on axis</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points</li>
<li><em>Array</em>, length 3 array of point indices for the triangle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, a point represented by an array of length 3</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.get_min_coordinate_on_axis = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points, tri, axis )</span> </span>{

	<span class="hljs-keyword">var</span> axis_coords = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++){
		axis_coords.push( points[ tri[i] ][ axis ] );
	}

	<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-built_in">Math</span>, axis_coords);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-193">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-193">&#182;</a>
              </div>
              <h4 id="get_tri_centroid-points-tri-">get_tri_centroid( points, tri )</h4>
<p>Get triangle centroid</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points</li>
<li><em>Array</em>, length 3 array of point indices for the triangle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length 3</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.get_tri_centroid = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points, tri )</span> </span>{

	<span class="hljs-keyword">var</span> centroid = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++){
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++){
			centroid[j] += points[ tri[i] ][j];
		}
	}

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++){
		centroid[i] /= <span class="hljs-number">3</span>;
	}

	<span class="hljs-keyword">return</span> centroid;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-194">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-194">&#182;</a>
              </div>
              <h4 id="get_tri_norm-points-tri-">get_tri_norm( points, tri )</h4>
<p>Get triangle normal</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points</li>
<li><em>Array</em>, length 3 array of point indices for the triangle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a normal vector represented by an array of length 3</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.get_tri_norm = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points, tri )</span> </span>{

	<span class="hljs-keyword">var</span> v0 = points[ tri[<span class="hljs-number">0</span>] ]
		, v1 = points[ tri[<span class="hljs-number">1</span>] ]
		, v2 = points[ tri[<span class="hljs-number">2</span>] ]
		, u = numeric.sub( v1, v0 )
		, v = numeric.sub( v2, v0 )
		, n = numeric.cross( u, v );

	<span class="hljs-keyword">return</span> numeric.mul( <span class="hljs-number">1</span> / numeric.norm2( n ), n );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-195">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-195">&#182;</a>
              </div>
              <h4 id="intersect_rational_curves_by_aabb_refine-degree1-knots1-homo_control_points1-degree2-knots2-homo_control_points2-sample_tol-tol-">intersect_rational_curves_by_aabb_refine( degree1, knots1, homo_control_points1, degree2, knots2, homo_control_points2, sample_tol, tol )</h4>
<p>Approximate the intersection of two nurbs surface by axis-aligned bounding box intersection and then refine all solutions.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve1</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 1</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) for curve 1</li>
<li><em>Number</em>, integer degree of curve2</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 2</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) for curve 2</li>
<li><em>Number</em>, tolerance for the intersection</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a 2d array specifying the intersections on u params of intersections on curve 1 and cruve 2</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.intersect_rational_curves_by_aabb_refine = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree1, knots1, homo_control_points1, degree2, knots2, homo_control_points2, sample_tol, tol )</span> </span>{

	<span class="hljs-keyword">var</span> ints = verb.eval.intersect_rational_curves_by_aabb( degree1, knots1, homo_control_points1, degree2, knots2, homo_control_points2, sample_tol, tol );

	<span class="hljs-keyword">return</span> ints.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(start_params)</span></span>{
		<span class="hljs-keyword">return</span> verb.eval.refine_rational_curve_intersection( degree1, knots1, homo_control_points1, degree2, knots2, homo_control_points2, start_params )
	});

}</pre></div></div>
            
        </li>
        
        
        <li id="section-196">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-196">&#182;</a>
              </div>
              <h4 id="rational_curve_curve_bb_intersect_refine-degree1-knots1-control_points1-degree2-knots2-control_points2-start_params-">rational_curve_curve_bb_intersect_refine( degree1, knots1, control_points1, degree2, knots2, control_points2, start_params )</h4>
<p>Refine an intersection pair for two curves given an initial guess.  This is an unconstrained minimization,
so the caller is responsible for providing a very good initial guess.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve1</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 1</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi) for curve 1</li>
<li><em>Number</em>, integer degree of curve2</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 2</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi) for curve 2</li>
<li><em>Array</em>, length 2 array with first param guess in first position and second param guess in second position</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a length 3 array containing the [ distance// distance, u1, u2 ]</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.refine_rational_curve_intersection = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree1, knots1, control_points1, degree2, knots2, control_points2, start_params )</span> </span>{

	<span class="hljs-keyword">var</span> objective = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span> </span>{ 

		<span class="hljs-keyword">var</span> p1 = verb.eval.rational_curve_point(degree1, knots1, control_points1, x[<span class="hljs-number">0</span>])
			, p2 = verb.eval.rational_curve_point(degree2, knots2, control_points2, x[<span class="hljs-number">1</span>])
			, p1_p2 = numeric.sub(p1, p2);

		<span class="hljs-keyword">return</span> numeric.dot(p1_p2, p1_p2);
	}

	<span class="hljs-keyword">var</span> sol_obj = numeric.uncmin( objective, start_params);
	<span class="hljs-keyword">return</span> sol_obj.solution.concat( sol_obj.f );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-197">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-197">&#182;</a>
              </div>
              <h4 id="intersect_rational_curves_by_aabb-degree1-knots1-homo_control_points1-degree2-knots2-homo_control_points2-sample_tol-tol-">intersect_rational_curves_by_aabb( degree1, knots1, homo_control_points1, degree2, knots2, homo_control_points2, sample_tol, tol )</h4>
<p>Approximate the intersection of two nurbs surface by axis-aligned bounding box intersection.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve1</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 1</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) for curve 1</li>
<li><em>Number</em>, integer degree of curve2</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 2</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) for curve 2</li>
<li><em>Number</em>, tolerance for the intersection</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, array of parameter pairs representing the intersection of the two parameteric polylines</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.intersect_rational_curves_by_aabb = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree1, knots1, homo_control_points1, degree2, knots2, homo_control_points2, sample_tol, tol )</span> </span>{

	<span class="hljs-keyword">var</span> up1 = verb.eval.rational_curve_adaptive_sample( degree1, knots1, homo_control_points1, sample_tol, <span class="hljs-literal">true</span>)
		, up2 = verb.eval.rational_curve_adaptive_sample( degree2, knots2, homo_control_points2, sample_tol, <span class="hljs-literal">true</span>)
		, u1 = up1.map( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el)</span> </span>{ <span class="hljs-keyword">return</span> el[<span class="hljs-number">0</span>]; })
		, u2 = up2.map( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el)</span> </span>{ <span class="hljs-keyword">return</span> el[<span class="hljs-number">0</span>]; })
		, p1 = up1.map( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el)</span> </span>{ <span class="hljs-keyword">return</span> el.slice(<span class="hljs-number">1</span>) })
		, p2 = up2.map( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el)</span> </span>{ <span class="hljs-keyword">return</span> el.slice(<span class="hljs-number">1</span>) });

	<span class="hljs-keyword">return</span> verb.eval.intersect_parametric_polylines_by_aabb( p1, p2, u1, u2, tol );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-198">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-198">&#182;</a>
              </div>
              <h4 id="intersect_parametric_polylines_by_aabb-p1-p2-u1-u2-tol-">intersect_parametric_polylines_by_aabb( p1, p2, u1, u2, tol )</h4>
<p>Intersect two polyline curves, keeping track of parameterization on each</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of point values for curve 1</li>
<li><em>Array</em>, array of parameter values for curve 1, same length as first arg</li>
<li><em>Array</em>, array of point values for curve 2</li>
<li><em>Array</em>, array of parameter values for curve 2, same length as third arg</li>
<li><em>Number</em>, tolerance for the intersection</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, array of parameter pairs representing the intersection of the two parameteric polylines</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.intersect_parametric_polylines_by_aabb = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( p1, p2, u1, u2, tol )</span> </span>{

	<span class="hljs-keyword">var</span> bb1 = <span class="hljs-keyword">new</span> verb.BoundingBox(p1)
		, bb2 = <span class="hljs-keyword">new</span> verb.BoundingBox(p2);

	<span class="hljs-keyword">if</span> ( !bb1.intersects(bb2, tol) ) {
		<span class="hljs-keyword">return</span> [];
	}

	<span class="hljs-keyword">if</span> (p1.length === <span class="hljs-number">2</span> &amp;&amp; p2.length === <span class="hljs-number">2</span> ){

			<span class="hljs-keyword">var</span> inter = verb.eval.intersect_segments(p1[<span class="hljs-number">0</span>],p1[<span class="hljs-number">1</span>], p2[<span class="hljs-number">0</span>], p2[<span class="hljs-number">1</span>], tol);

			<span class="hljs-keyword">if</span> ( inter != <span class="hljs-literal">null</span> ){</pre></div></div>
            
        </li>
        
        
        <li id="section-199">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-199">&#182;</a>
              </div>
              <p>map the parameters of the segment to the parametric space of the entire polyline</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			 	inter[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = inter[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] * ( u1[<span class="hljs-number">1</span>]-u1[<span class="hljs-number">0</span>] ) + u1[<span class="hljs-number">0</span>];
			 	inter[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = inter[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] * ( u2[<span class="hljs-number">1</span>]-u2[<span class="hljs-number">0</span>] ) + u2[<span class="hljs-number">0</span>];

			 	<span class="hljs-keyword">return</span> [ [ inter[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], inter[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] ] ];

			} 

	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1.length === <span class="hljs-number">2</span>) {

		<span class="hljs-keyword">var</span> p2_mid = <span class="hljs-built_in">Math</span>.ceil( p2.length / <span class="hljs-number">2</span> ),
				p2_a = p2.slice( <span class="hljs-number">0</span>, p2_mid ),
				p2_b = p2.slice( p2_mid-<span class="hljs-number">1</span> ),
				u2_a = u2.slice( <span class="hljs-number">0</span>, p2_mid ),
				u2_b = u2.slice( p2_mid-<span class="hljs-number">1</span> );

		<span class="hljs-keyword">return</span> 	 verb.eval.intersect_parametric_polylines_by_aabb(p1, p2_a, u1, u2_a, tol)
		.concat( verb.eval.intersect_parametric_polylines_by_aabb(p1, p2_b, u1, u2_b, tol) );

	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2.length === <span class="hljs-number">2</span>) {

		<span class="hljs-keyword">var</span> p1_mid = <span class="hljs-built_in">Math</span>.ceil( p1.length / <span class="hljs-number">2</span> ),
				p1_a = p1.slice( <span class="hljs-number">0</span>, p1_mid ),
				p1_b = p1.slice( p1_mid-<span class="hljs-number">1</span> ),
				u1_a = u1.slice( <span class="hljs-number">0</span>, p1_mid ),
				u1_b = u1.slice( p1_mid-<span class="hljs-number">1</span> );

		<span class="hljs-keyword">return</span> 		 verb.eval.intersect_parametric_polylines_by_aabb(p1_a, p2, u1_a, u2, tol)
			.concat( verb.eval.intersect_parametric_polylines_by_aabb(p1_b, p2, u1_b, u2, tol) );

	} <span class="hljs-keyword">else</span> {

		<span class="hljs-keyword">var</span> p1_mid = <span class="hljs-built_in">Math</span>.ceil( p1.length / <span class="hljs-number">2</span> ),
				p1_a = p1.slice( <span class="hljs-number">0</span>, p1_mid ),
				p1_b = p1.slice( p1_mid-<span class="hljs-number">1</span> ),
				u1_a = u1.slice( <span class="hljs-number">0</span>, p1_mid ),
				u1_b = u1.slice( p1_mid-<span class="hljs-number">1</span> ),

				p2_mid = <span class="hljs-built_in">Math</span>.ceil( p2.length / <span class="hljs-number">2</span> ),
				p2_a = p2.slice( <span class="hljs-number">0</span>, p2_mid ),
				p2_b = p2.slice( p2_mid-<span class="hljs-number">1</span> ),
				u2_a = u2.slice( <span class="hljs-number">0</span>, p2_mid ),
				u2_b = u2.slice( p2_mid-<span class="hljs-number">1</span> );

		<span class="hljs-keyword">return</span> 		 verb.eval.intersect_parametric_polylines_by_aabb(p1_a, p2_a, u1_a, u2_a, tol)
			.concat( verb.eval.intersect_parametric_polylines_by_aabb(p1_a, p2_b, u1_a, u2_b, tol) )
			.concat( verb.eval.intersect_parametric_polylines_by_aabb(p1_b, p2_a, u1_b, u2_a, tol) )
			.concat( verb.eval.intersect_parametric_polylines_by_aabb(p1_b, p2_b, u1_b, u2_b, tol) );

	}

	<span class="hljs-keyword">return</span> [];

}</pre></div></div>
            
        </li>
        
        
        <li id="section-200">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-200">&#182;</a>
              </div>
              <h4 id="intersect_segments-a0-a1-b0-b1-tol-">intersect_segments( a0, a1, b0, b1, tol )</h4>
<p>Find the closest parameter on two rays, see <a href="http://geomalgorithms.com/a07-_distance.html">http://geomalgorithms.com/a07-_distance.html</a></p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, first point on a</li>
<li><em>Array</em>, second point on a</li>
<li><em>Array</em>, first point on b</li>
<li><em>Array</em>, second point on b</li>
<li><em>Number</em>, tolerance for the intersection</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a 2d array specifying the intersections on u params of intersections on curve 1 and cruve 2</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.intersect_segments = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( a0, a1, b0, b1, tol )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-201">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-201">&#182;</a>
              </div>
              <p>get axis and length of segments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> a1ma0 = numeric.sub(a1, a0),
			aN = <span class="hljs-built_in">Math</span>.sqrt( numeric.dot(a1ma0, a1ma0) ),
			a = numeric.mul( <span class="hljs-number">1</span>/ aN, a1ma0 ),
			b1mb0 = numeric.sub(b1, b0),
			bN = <span class="hljs-built_in">Math</span>.sqrt( numeric.dot(b1mb0, b1mb0) ),
			b = numeric.mul( <span class="hljs-number">1</span> / bN, b1mb0 ),
			int_params = verb.eval.intersect_rays(a0, a, b0, b);

	<span class="hljs-keyword">if</span> ( int_params != <span class="hljs-literal">null</span> ) {

		<span class="hljs-keyword">var</span> u1 = <span class="hljs-built_in">Math</span>.min( <span class="hljs-built_in">Math</span>.max( <span class="hljs-number">0</span>, int_params[<span class="hljs-number">0</span>] / aN ), <span class="hljs-number">1.0</span>),
				u2 = <span class="hljs-built_in">Math</span>.min( <span class="hljs-built_in">Math</span>.max( <span class="hljs-number">0</span>, int_params[<span class="hljs-number">1</span>] / bN ), <span class="hljs-number">1.0</span>),
				int_a = numeric.add( numeric.mul( u1, a1ma0 ), a0 ),
				int_b = numeric.add( numeric.mul( u2, b1mb0 ), b0 ),
				dist = numeric.norm2Squared( numeric.sub(int_a, int_b) );

		<span class="hljs-keyword">if</span> (  dist &lt; tol*tol ) {
			<span class="hljs-keyword">return</span> [ [u1].concat(int_a), [u2].concat(int_b) ] ;
		} 

	}
	
	<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

 }</pre></div></div>
            
        </li>
        
        
        <li id="section-202">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-202">&#182;</a>
              </div>
              <h4 id="closest_param_on_segment-pt-segpt0-segpt1-">closest_param_on_segment( pt, segpt0, segpt1 )</h4>
<p>Find the closest point on a ray</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, point to project</li>
<li><em>Array</em>, first point of segment</li>
<li><em>Array</em>, second point of segment</li>
<li><em>Number</em>, first param of segment</li>
<li><em>Number</em>, second param of segment</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em> with u and pt properties</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.closest_point_on_segment = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( pt, segpt0, segpt1, u0, u1 )</span> </span>{

	<span class="hljs-keyword">var</span> dif = numeric.sub( segpt1, segpt0 )
		, l = numeric.norm2( dif );

	<span class="hljs-keyword">if</span> (l &lt; verb.EPSILON ) {
		<span class="hljs-keyword">return</span> { 	u: u0, 
							pt : segpt0 };
	}		

	<span class="hljs-keyword">var</span> o = segpt0
		, r = numeric.mul( <span class="hljs-number">1</span> / l, dif )
		, o2pt = numeric.sub(pt, o)
		, do2ptr = numeric.dot(o2pt, r);

	<span class="hljs-keyword">if</span> (do2ptr &lt; <span class="hljs-number">0</span>){

		<span class="hljs-keyword">return</span> { 	u: u0, 
							pt : segpt0 };

	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (do2ptr &gt; l){

		<span class="hljs-keyword">return</span> { 	u: u1, 
							pt : segpt1 };

	}

	<span class="hljs-keyword">return</span> { 	u: u0 + (u1 - u0) * do2ptr / l, 
						pt : numeric.add(o, numeric.mul( do2ptr, r ) ) };

 }</pre></div></div>
            
        </li>
        
        
        <li id="section-203">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-203">&#182;</a>
              </div>
              <h4 id="closest_point_on_ray-pt-o-r-">closest_point_on_ray( pt, o, r )</h4>
<p>Find the closest point on a ray</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, point to project</li>
<li><em>Array</em>, origin for ray</li>
<li><em>Array</em>, direction of ray 1, assumed normalized</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, pt</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.closest_point_on_ray = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( pt, o, r )</span> </span>{

		<span class="hljs-keyword">var</span> o2pt = numeric.sub(pt,o)
			, do2ptr = numeric.dot(o2pt, r)
			, proj = numeric.add(o, numeric.mul(do2ptr, r));

		<span class="hljs-keyword">return</span> proj;

 }</pre></div></div>
            
        </li>
        
        
        <li id="section-204">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-204">&#182;</a>
              </div>
              <h4 id="dist_to_ray-pt-o-r-">dist_to_ray( pt, o, r )</h4>
<p>Find the distance of a point to a ray</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, point to project</li>
<li><em>Array</em>, origin for ray</li>
<li><em>Array</em>, direction of ray 1, assumed normalized</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, the distance</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.dist_to_ray = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( pt, o, r )</span> </span>{

	<span class="hljs-keyword">var</span> d = verb.eval.closest_point_on_ray( pt, o, r );
	<span class="hljs-keyword">var</span> dif = numeric.sub( d, pt );

	<span class="hljs-keyword">return</span> numeric.norm2( dif );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-205">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-205">&#182;</a>
              </div>
              <h4 id="intersect_rays-a0-a-b0-b-">intersect_rays( a0, a, b0, b )</h4>
<p>Find the closest parameter on two rays, see <a href="http://geomalgorithms.com/a07-_distance.html">http://geomalgorithms.com/a07-_distance.html</a></p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, origin for ray 1</li>
<li><em>Array</em>, direction of ray 1, assumed normalized</li>
<li><em>Array</em>, origin for ray 1</li>
<li><em>Array</em>, direction of ray 1, assumed normalized</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a 2d array specifying the intersections on u params of intersections on curve 1 and curve 2</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.intersect_rays = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( a0, a, b0, b )</span> </span>{

   <span class="hljs-keyword">var</span> dab = numeric.dot( a, b ),
		   dab0 = numeric.dot( a, b0 ),
		   daa0 = numeric.dot( a, a0 ),
		   dbb0 = numeric.dot( b, b0 ),
		   dba0 = numeric.dot( b, a0 ),
		   daa = numeric.dot( a, a ),
		   dbb = numeric.dot( b, b ),
		   div = daa*dbb - dab*dab;</pre></div></div>
            
        </li>
        
        
        <li id="section-206">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-206">&#182;</a>
              </div>
              <p>parallel case</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>   <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">Math</span>.abs( div ) &lt; verb.EPSILON ) { 
	   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
   }

   <span class="hljs-keyword">var</span> num = dab * (dab0-daa0) - daa * (dbb0-dba0),
   		 w = num / div,
			 t = (dab0 - daa0 + w * dab)/daa;

		<span class="hljs-keyword">return</span> [t, w];

}

verb.eval.intersect_3_planes = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n0, d0, n1, d1, n2, d2)</span></span>{

	<span class="hljs-keyword">var</span> u = numeric.cross( n1, n2 );
	<span class="hljs-keyword">var</span> den = numeric.dot( n0, u );

	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(den) &lt; verb.EPSILON) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

	<span class="hljs-keyword">var</span> num = numeric.add(
							numeric.mul( d0, u ), 
							numeric.cross( n0, 
								numeric.sub( 	numeric.mul( d2, n1 ), numeric.mul( d1, n2 ) )));

	<span class="hljs-keyword">return</span> numeric.mul( <span class="hljs-number">1</span> / den, num );

}

verb.eval.refine_rational_surface_intersect_point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(uv1, uv2, degree_u1, knots_u1, degree_v1, knots_v1, homo_control_points1, degree_u2, knots_u2, degree_v2, knots_v2, homo_control_points2, tol)</span></span>{

 <span class="hljs-keyword">var</span> pds, p, pn, pu, pv, pd, qds, q, qn, qu, qv, qd, dist;
 <span class="hljs-keyword">var</span> maxits = <span class="hljs-number">1</span>;
 <span class="hljs-keyword">var</span> its = <span class="hljs-number">0</span>;

 <span class="hljs-keyword">var</span> r = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(u, v)</span></span>{
 	<span class="hljs-keyword">return</span> verb.eval.rational_surface_derivs( degree_u1, knots_u1, degree_v1, knots_v1, 
			homo_control_points1, <span class="hljs-number">1</span>, u, v );
 }

 <span class="hljs-keyword">var</span> s = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(u, v)</span></span>{
 	<span class="hljs-keyword">return</span> verb.eval.rational_surface_derivs( degree_u2, knots_u2, degree_v2, knots_v2, 
			homo_control_points2, <span class="hljs-number">1</span>, u, v );
 }

 <span class="hljs-keyword">do</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-207">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-207">&#182;</a>
              </div>
              <p>1) eval normals, pts on respective surfaces (p, q, pn, qn)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		pds = r( uv1[<span class="hljs-number">0</span>], uv1[<span class="hljs-number">1</span>] );
		p = pds[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
		pu = pds[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
		pv = pds[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];
		pn = numeric.normalized( numeric.cross( pu, pv ) );
		pd = numeric.dot( pn, p );
		
		qds = s( uv2[<span class="hljs-number">0</span>], uv2[<span class="hljs-number">1</span>] );
		q = qds[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
		qu = qds[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
		qv = qds[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];
		qn = numeric.normalized( numeric.cross( qu, qv ) );
		qd = numeric.dot( qn, q );</pre></div></div>
            
        </li>
        
        
        <li id="section-208">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-208">&#182;</a>
              </div>
              <p>if tolerance is met, exit loop</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		dist = numeric.norm2( numeric.sub(p, q) );

		
		<span class="hljs-keyword">if</span> (dist &lt; tol) {
			<span class="hljs-keyword">break</span>;
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-209">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-209">&#182;</a>
              </div>
              <p>2) construct plane perp to both that passes through p (fn)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-keyword">var</span> fn = numeric.normalized( numeric.cross( pn, qn ) );
		<span class="hljs-keyword">var</span> fd = numeric.dot( fn, p );</pre></div></div>
            
        </li>
        
        
        <li id="section-210">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-210">&#182;</a>
              </div>
              <p>3) x = intersection of all 3 planes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> x = verb.eval.intersect_3_planes( pn, pd, qn, qd, fn, fd );

		<span class="hljs-keyword">if</span> (x === <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"panic!"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-211">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-211">&#182;</a>
              </div>
              <p>4) represent the difference vectors (pd = x - p, qd = x - q) in the partial 
        derivative vectors of the respective surfaces (pu, pv, qu, qv)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-keyword">var</span> pdif = numeric.sub( x, p );
		<span class="hljs-keyword">var</span> qdif = numeric.sub( x, q );

		<span class="hljs-keyword">var</span> rw = numeric.cross( pu, pn ); 
		<span class="hljs-keyword">var</span> rt = numeric.cross( pv, pn );

		<span class="hljs-keyword">var</span> su = numeric.cross( qu, qn );
		<span class="hljs-keyword">var</span> sv = numeric.cross( qv, qn );

		<span class="hljs-keyword">var</span> dw = numeric.dot( rt, pdif ) / numeric.dot( rt, pu );
		<span class="hljs-keyword">var</span> dt = numeric.dot( rw, pdif ) / numeric.dot( rw, pv );

		<span class="hljs-keyword">var</span> du = numeric.dot( sv, qdif ) / numeric.dot( sv, qu );
		<span class="hljs-keyword">var</span> dv = numeric.dot( su, qdif ) / numeric.dot( su, qv );

		uv1 = numeric.add( [dw, dt], uv1 );
		uv2 = numeric.add( [du, dv], uv2 );</pre></div></div>
            
        </li>
        
        
        <li id="section-212">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-212">&#182;</a>
              </div>
              <p>repeat</p>

            </div>
            
            <div class="content"><div class='highlight'><pre> 		its++;

 } <span class="hljs-keyword">while</span>( its &lt; maxits ) <span class="hljs-comment">// tolerance is not met? not sure what this should be</span>

 <span class="hljs-keyword">return</span> {uv1: uv1, uv2: uv2, pt: p, d: dist };

}

verb.eval.intersect_rational_surface_surface_by_aabb_refine = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u1, knots_u1, degree_v1, knots_v1, homo_control_points_srf1, degree_u2, knots_u2, degree_v2, knots_v2, homo_control_points_srf2, tol )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-213">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-213">&#182;</a>
              </div>
              <p>1) tessellate the meshes to get the approximate intersections</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> srfObj1 = {
		degree_u : degree_u1,
		degree_v : degree_v1,
		knots_u : knots_u1,
		knots_v : knots_v1,
		homo_control_points : homo_control_points_srf1
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-214">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-214">&#182;</a>
              </div>
              <p>todo: need to be able to predict the number of divisions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">var</span> tess1 = verb.eval.tessellate_rational_surface_adaptive( srfObj1.degree_u,
		srfObj1.knots_u,
		srfObj1.degree_v,
		srfObj1.knots_v, 
		srfObj1.homo_control_points);

	<span class="hljs-keyword">var</span> srfObj2 = {
		degree_u : degree_u2,
		degree_v : degree_v2,
		knots_u : knots_u2,
		knots_v : knots_v2,
		homo_control_points : homo_control_points_srf2
	};

	<span class="hljs-keyword">var</span> tess2 = verb.eval.tessellate_rational_surface_adaptive( srfObj2.degree_u,
		srfObj2.knots_u,
		srfObj2.degree_v,
		srfObj2.knots_v, 
		srfObj2.homo_control_points);

	<span class="hljs-keyword">var</span> resApprox = verb.eval.intersect_meshes_by_aabb( tess1.points, tess1.faces, tess1.uvs, tess2.points, tess2.faces, tess2.uvs );</pre></div></div>
            
        </li>
        
        
        <li id="section-215">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-215">&#182;</a>
              </div>
              <p>2) refine the intersection points so that they lie on both surfaces</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> exactPls = resApprox.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(pl)</span></span>{
		<span class="hljs-keyword">return</span> pl.map( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(inter)</span></span>{
			<span class="hljs-keyword">return</span> verb.eval.refine_rational_surface_intersect_point(inter.uvtri1, inter.uvtri2, degree_u1, knots_u1, degree_v1, knots_v1, homo_control_points_srf1, 
				degree_u2, knots_u2, degree_v2, knots_v2, homo_control_points_srf2, tol );
		});
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-216">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-216">&#182;</a>
              </div>
              <p>3) perform cubic interpolation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> exactPls.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span>{
		<span class="hljs-keyword">return</span> verb.eval.rational_interp_curve( x.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span>{ <span class="hljs-keyword">return</span> x.pt; }), <span class="hljs-number">3</span> ); 
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-217">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-217">&#182;</a>
              </div>
              <p>TODO: represent this in uv space
TODO: refine between initial points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
}

verb.eval.intersect_meshes_by_aabb = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points1, tris1, uvs1, points2, tris2, uvs2 )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-218">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-218">&#182;</a>
              </div>
              <p>build aabb for each mesh</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> tri_indices1 = verb.range(tris1.length)
	  , tri_indices2 = verb.range(tris2.length)
	  , aabb1 = verb.eval.make_mesh_aabb_tree( points1, tris1, tri_indices1 )
	  , aabb2 = verb.eval.make_mesh_aabb_tree( points2, tris2, tri_indices2 );</pre></div></div>
            
        </li>
        
        
        <li id="section-219">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-219">&#182;</a>
              </div>
              <p>intersect and get the pairs of triangle intersctions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> bbints = verb.eval.intersect_aabb_trees( points1, tris1, points2, tris2, aabb1, aabb2 );</pre></div></div>
            
        </li>
        
        
        <li id="section-220">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-220">&#182;</a>
              </div>
              <p>get the segments of the intersection crv with uvs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> segments = bbints.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ids)</span></span>{
													<span class="hljs-keyword">var</span> res = verb.eval.intersect_tris( points1, tris1[ ids[<span class="hljs-number">0</span>] ], uvs1, points2, tris2[ ids[<span class="hljs-number">1</span>] ], uvs2 );
													<span class="hljs-keyword">if</span> (!res) <span class="hljs-keyword">return</span> res;

													res[<span class="hljs-number">0</span>].tri1id = ids[<span class="hljs-number">0</span>];
													res[<span class="hljs-number">1</span>].tri1id = ids[<span class="hljs-number">0</span>];
													res[<span class="hljs-number">0</span>].tri2id = ids[<span class="hljs-number">1</span>];
													res[<span class="hljs-number">1</span>].tri2id = ids[<span class="hljs-number">1</span>];

													<span class="hljs-keyword">return</span> res;
												}).filter(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span>{ <span class="hljs-keyword">return</span> x; })
												.filter(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span>{ 
													<span class="hljs-keyword">var</span> dif = numeric.sub( x[<span class="hljs-number">0</span>].pt, x[<span class="hljs-number">1</span>].pt );
													<span class="hljs-keyword">return</span> numeric.dot( dif, dif ) &gt; verb.EPSILON 
												});</pre></div></div>
            
        </li>
        
        
        <li id="section-221">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-221">&#182;</a>
              </div>
              <p>TODO: this is too expensive and this only occurs when the intersection
             line is on an edge.  we should mark these to avoid doing all of 
         these computations</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	segments = verb.unique( segments, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span></span>{

		<span class="hljs-keyword">var</span> s1 = numeric.sub( a[<span class="hljs-number">0</span>].uvtri1, b[<span class="hljs-number">0</span>].uvtri1 );
		<span class="hljs-keyword">var</span> d1 = numeric.dot( s1, s1 );

		<span class="hljs-keyword">var</span> s2 = numeric.sub( a[<span class="hljs-number">1</span>].uvtri1, b[<span class="hljs-number">1</span>].uvtri1 );
		<span class="hljs-keyword">var</span> d2 = numeric.dot( s2, s2 );

		<span class="hljs-keyword">var</span> s3 = numeric.sub( a[<span class="hljs-number">0</span>].uvtri1, b[<span class="hljs-number">1</span>].uvtri1 );
		<span class="hljs-keyword">var</span> d3 = numeric.dot( s3, s3 );

		<span class="hljs-keyword">var</span> s4 = numeric.sub( a[<span class="hljs-number">1</span>].uvtri1, b[<span class="hljs-number">0</span>].uvtri1 );
		<span class="hljs-keyword">var</span> d4 = numeric.dot( s4, s4 );

		<span class="hljs-keyword">return</span> ( d1 &lt; verb.EPSILON &amp;&amp; d2 &lt; verb.EPSILON ) || 
			( d3 &lt; verb.EPSILON &amp;&amp; d4 &lt; verb.EPSILON );

	});

	<span class="hljs-keyword">if</span> (segments.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];

	<span class="hljs-keyword">return</span> verb.eval.make_intersect_polylines( segments );

}


verb.eval.make_intersect_polylines = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( segments )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-222">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-222">&#182;</a>
              </div>
              <p>debug (return all segments)
return segments;</p>

            </div>
            
        </li>
        
        
        <li id="section-223">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-223">&#182;</a>
              </div>
              <p>we need to be able to traverse from one end of a segment to the other</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	segments.forEach( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(s)</span></span>{
		s[<span class="hljs-number">1</span>].opp = s[<span class="hljs-number">0</span>];
		s[<span class="hljs-number">0</span>].opp = s[<span class="hljs-number">1</span>];
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-224">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-224">&#182;</a>
              </div>
              <p>construct a tree for fast lookup </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> tree = verb.eval.kdtree_from_segs( segments );</pre></div></div>
            
        </li>
        
        
        <li id="section-225">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-225">&#182;</a>
              </div>
              <p>flatten everything, we no longer need the segments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> ends = segments.flatten();</pre></div></div>
            
        </li>
        
        
        <li id="section-226">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-226">&#182;</a>
              </div>
              <p>step 1: assigning the vertices to the segment ends </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	ends.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(segEnd)</span></span>{

			<span class="hljs-keyword">if</span> (segEnd.adj) <span class="hljs-keyword">return</span>;

			<span class="hljs-keyword">var</span> adjEnd = verb.eval.lookup_adj_segment( segEnd, tree, segments.length );

			<span class="hljs-keyword">if</span> (adjEnd &amp;&amp; !adjEnd.adj){

				segEnd.adj = adjEnd;
				adjEnd.adj = segEnd;

			} 

		});</pre></div></div>
            
        </li>
        
        
        <li id="section-227">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-227">&#182;</a>
              </div>
              <p>step 2: traversing the topology to construct the pls</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> freeEnds = ends.filter(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span>{
		<span class="hljs-keyword">return</span> !x.adj;
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-228">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-228">&#182;</a>
              </div>
              <p>if you cant find one, youve got a loop (or multiple), we run through all</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (freeEnds.length === <span class="hljs-number">0</span>) {
		freeEnds = ends;
	}

	<span class="hljs-keyword">var</span> pls = [];
	
	freeEnds.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(end)</span></span>{

		<span class="hljs-keyword">if</span> (end.v) <span class="hljs-keyword">return</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-229">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-229">&#182;</a>
              </div>
              <p>traverse to end</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> pl = [];
		<span class="hljs-keyword">var</span> curEnd = end;

		<span class="hljs-keyword">while</span> (curEnd) {</pre></div></div>
            
        </li>
        
        
        <li id="section-230">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-230">&#182;</a>
              </div>
              <p>debug</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (curEnd.v) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Segment end encountered twice!'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-231">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-231">&#182;</a>
              </div>
              <p>technically we consume both ends of the segment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			curEnd.v = <span class="hljs-literal">true</span>;
			curEnd.opp.v = <span class="hljs-literal">true</span>;

			pl.push(curEnd);

			curEnd = curEnd.opp.adj;</pre></div></div>
            
        </li>
        
        
        <li id="section-232">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-232">&#182;</a>
              </div>
              <p>loop condition</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (curEnd === end) <span class="hljs-keyword">break</span>;

		}

		<span class="hljs-keyword">if</span> (pl.length &gt; <span class="hljs-number">0</span>) {
			pl.push( pl[pl.length-<span class="hljs-number">1</span>].opp );
			pls.push( pl );
		}

	})

	<span class="hljs-keyword">return</span> pls;

}

verb.eval.pt_dist = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span></span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(a.x - b.x, <span class="hljs-number">2</span>) + <span class="hljs-built_in">Math</span>.pow(a.y - b.y, <span class="hljs-number">2</span>) + <span class="hljs-built_in">Math</span>.pow(a.z - b.z, <span class="hljs-number">2</span>);
};

verb.eval.kdtree_from_segs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( segments )</span></span>{

	<span class="hljs-keyword">var</span> treePoints = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-233">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-233">&#182;</a>
              </div>
              <p>for each segment, transform into two elements, each keyed by pt1 and pt2</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	segments.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(seg)</span></span>{
		treePoints.push({ <span class="hljs-string">"x"</span>: seg[<span class="hljs-number">0</span>].pt[<span class="hljs-number">0</span>], <span class="hljs-string">"y"</span>: seg[<span class="hljs-number">0</span>].pt[<span class="hljs-number">1</span>], <span class="hljs-string">"z"</span>: seg[<span class="hljs-number">0</span>].pt[<span class="hljs-number">2</span>], ele: seg[<span class="hljs-number">0</span>] });
		treePoints.push({ <span class="hljs-string">"x"</span>: seg[<span class="hljs-number">1</span>].pt[<span class="hljs-number">0</span>], <span class="hljs-string">"y"</span>: seg[<span class="hljs-number">1</span>].pt[<span class="hljs-number">1</span>], <span class="hljs-string">"z"</span>: seg[<span class="hljs-number">1</span>].pt[<span class="hljs-number">2</span>], ele: seg[<span class="hljs-number">1</span>] });
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-234">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-234">&#182;</a>
              </div>
              <p>make our tree</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> KdTree(treePoints, verb.eval.pt_dist, [<span class="hljs-string">"x"</span>, <span class="hljs-string">"y"</span>, <span class="hljs-string">"z"</span>]);

}

verb.eval.lookup_adj_segment = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( segEnd, tree, numSegments )</span> </span>{

	<span class="hljs-keyword">var</span> numResults = numSegments ? <span class="hljs-built_in">Math</span>.min( numSegments, <span class="hljs-number">3</span> ) : <span class="hljs-number">3</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-235">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-235">&#182;</a>
              </div>
              <p>we look up 3 elements because we need to find the unique adj ele
we expect one result to be self, one to be neighbor and no more</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> adj = tree.nearest({ x: segEnd.pt[<span class="hljs-number">0</span>], y: segEnd.pt[<span class="hljs-number">1</span>], z: segEnd.pt[<span class="hljs-number">2</span>] }, numResults)
								.filter(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(r)</span></span>{ 
									<span class="hljs-keyword">return</span> segEnd != r[<span class="hljs-number">0</span>].ele &amp;&amp; r[<span class="hljs-number">1</span>] &lt; verb.EPSILON;
								})
								.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(r)</span></span>{ <span class="hljs-keyword">return</span> r[<span class="hljs-number">0</span>].ele; });</pre></div></div>
            
        </li>
        
        
        <li id="section-236">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-236">&#182;</a>
              </div>
              <p>there may be as many as 1 duplicate pt</p>

            </div>
            
        </li>
        
        
        <li id="section-237">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-237">&#182;</a>
              </div>
              <p>if its not unique (i.e. were at a branching point) we dont return it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> (adj.length === <span class="hljs-number">1</span>) ? adj[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-238">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-238">&#182;</a>
              </div>
              <h4 id="intersect_tris-points1-tri1-uvs1-points2-tri2-uvs2-">intersect_tris( points1, tri1, uvs1, points2, tri2, uvs2 )</h4>
<p>Intersect two triangles</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points of mesh1</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles of mesh1</li>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points of mesh2</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles of mesh2</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.intersect_tris = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points1, tri1, uvs1, points2, tri2, uvs2 )</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-239">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-239">&#182;</a>
              </div>
              <p>0) get the plane rep of the two triangles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> n0 = verb.eval.get_tri_norm( points1, tri1 );
	<span class="hljs-keyword">var</span> n1 = verb.eval.get_tri_norm( points2, tri2 );
	<span class="hljs-keyword">var</span> o0 = points1[ tri1[<span class="hljs-number">0</span>] ];
	<span class="hljs-keyword">var</span> o1 = points2[ tri2[<span class="hljs-number">0</span>] ];</pre></div></div>
            
        </li>
        
        
        <li id="section-240">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-240">&#182;</a>
              </div>
              <p>TODO: fail early if all of the points of tri1 are on the same side of plane of tri2
TODO: mark appropriately if the intersection is along an edge</p>

            </div>
            
        </li>
        
        
        <li id="section-241">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-241">&#182;</a>
              </div>
              <p>1) intersect with planes to yield ray of intersection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> ray = verb.eval.intersect_planes(o0, n0, o1, n1);
	<span class="hljs-keyword">if</span> (!ray.intersects) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-242">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-242">&#182;</a>
              </div>
              <p>2) clip the ray within tri1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> clip1 = verb.eval.clip_ray_in_coplanar_tri( ray.origin, ray.dir, points1, tri1, uvs1 );
	<span class="hljs-keyword">if</span> (clip1 === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-243">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-243">&#182;</a>
              </div>
              <p>3) clip the ray within tri2</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> clip2 = verb.eval.clip_ray_in_coplanar_tri( ray.origin, ray.dir, points2, tri2, uvs2 );
	<span class="hljs-keyword">if</span> (clip2 === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-244">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-244">&#182;</a>
              </div>
              <p>4) find the interval that overlaps</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> merged = verb.eval.merge_tri_clip_intervals(clip1, clip2, points1, tri1, uvs1, points2, tri2, uvs2 );
	<span class="hljs-keyword">if</span> (merged === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

	<span class="hljs-keyword">return</span> [ 	{ uvtri1 : merged.uv1tri1, uvtri2: merged.uv1tri2, pt: merged.pt1 }, 
						{ uvtri1 : merged.uv2tri1, uvtri2: merged.uv2tri2, pt: merged.pt2 } ];

}

verb.eval.clip_ray_in_coplanar_tri = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o1, d1, points, tri, uvs )</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-245">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-245">&#182;</a>
              </div>
              <p>0) construct rays for each edge of the triangle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> o = [ points[ tri[<span class="hljs-number">0</span>] ], points[ tri[<span class="hljs-number">1</span>] ], points[ tri[<span class="hljs-number">2</span>] ] ]

		, uvs = [ uvs[ tri[<span class="hljs-number">0</span>] ], uvs[ tri[<span class="hljs-number">1</span>] ], uvs[ tri[<span class="hljs-number">2</span>] ] ]

		, uvd = [ numeric.sub(uvs[<span class="hljs-number">1</span>], uvs[<span class="hljs-number">0</span>]), numeric.sub(uvs[<span class="hljs-number">2</span>], uvs[<span class="hljs-number">1</span>]), numeric.sub(uvs[<span class="hljs-number">0</span>], uvs[<span class="hljs-number">2</span>]) ] 

		, s = [ numeric.sub( o[<span class="hljs-number">1</span>], o[<span class="hljs-number">0</span>] ), numeric.sub( o[<span class="hljs-number">2</span>], o[<span class="hljs-number">1</span>] ), numeric.sub( o[<span class="hljs-number">0</span>], o[<span class="hljs-number">2</span>] ) ]

		, d = s.map( numeric.normalized )
		, l = s.map( numeric.norm2 )</pre></div></div>
            
        </li>
        
        
        <li id="section-246">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-246">&#182;</a>
              </div>
              <p>1) for each tri ray, if intersects and in segment interval, store minU, maxU</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> minU = <span class="hljs-literal">null</span>;
	<span class="hljs-keyword">var</span> maxU = <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-247">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-247">&#182;</a>
              </div>
              <p>need to clip in order to maximize the width of the intervals</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++){

		<span class="hljs-keyword">var</span> o0 = o[i];
		<span class="hljs-keyword">var</span> d0 = d[i];

		<span class="hljs-keyword">var</span> res = verb.eval.intersect_rays( o0, d0, o1, d1 );</pre></div></div>
            
        </li>
        
        
        <li id="section-248">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-248">&#182;</a>
              </div>
              <p>the rays are parallel</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (res === <span class="hljs-literal">null</span>) {
			<span class="hljs-keyword">continue</span>;
		}

		<span class="hljs-keyword">var</span> useg = res[<span class="hljs-number">0</span>];
		<span class="hljs-keyword">var</span> uray = res[<span class="hljs-number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-249">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-249">&#182;</a>
              </div>
              <p>if outside of triangle edge interval, discard</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (useg &lt; -verb.EPSILON || useg &gt; l[i] + verb.EPSILON) <span class="hljs-keyword">continue</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-250">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-250">&#182;</a>
              </div>
              <p>if inside interval</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (minU === <span class="hljs-literal">null</span> || uray &lt; minU.u){
			minU = { 	u: uray, 
								pt: verb.eval.point_on_ray( o1, d1, uray ),
								uv: numeric.add( uvs[i], numeric.mul( useg / l[i], uvd[i] ) ) };

		}

		<span class="hljs-keyword">if</span> (maxU === <span class="hljs-literal">null</span> || uray &gt; maxU.u){
			maxU = { 	u: uray, 
								pt: verb.eval.point_on_ray( o1, d1, uray ),
								uv: numeric.add( uvs[i], numeric.mul( useg / l[i], uvd[i] ) ) };

		}
	}

	<span class="hljs-keyword">if</span> (maxU === <span class="hljs-literal">null</span> || minU === <span class="hljs-literal">null</span>) {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-251">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-251">&#182;</a>
              </div>
              <p>3) otherwise, return minU maxU along with uv info</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> { min : minU, max: maxU };
	
}

verb.eval.point_on_ray = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o, d, u)</span></span>{

	<span class="hljs-keyword">return</span> numeric.add( o, numeric.mul( u, d ));

}

verb.eval.merge_tri_clip_intervals = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(clip1, clip2, points1, tri1, uvs1, points2, tri2, uvs2)</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-252">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-252">&#182;</a>
              </div>
              <p>if the intervals dont overlap, fail</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (clip2.min.u &gt; clip1.max.u + verb.EPSILON 
		|| clip1.min.u &gt; clip2.max.u + verb.EPSILON) {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-253">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-253">&#182;</a>
              </div>
              <p>label each clip to indicate which triangle it came from</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	clip1.min.tri = <span class="hljs-number">0</span>;
	clip1.max.tri = <span class="hljs-number">0</span>;
	clip2.min.tri = <span class="hljs-number">1</span>;
	clip2.max.tri = <span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-254">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-254">&#182;</a>
              </div>
              <p>are these assigned properly?  </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">var</span> min = (clip1.min.u &gt; clip2.min.u) ? clip1.min : clip2.min;
	<span class="hljs-keyword">var</span> max = (clip1.max.u &lt; clip2.max.u) ? clip1.max : clip2.max;

	<span class="hljs-keyword">var</span> res = {};

	<span class="hljs-keyword">if</span> (min.tri === <span class="hljs-number">0</span>){

		res.uv1tri1 = min.uv;
		res.uv1tri2 = verb.eval.tri_uv_from_point( points2, tri2, uvs2, min.pt );

	} <span class="hljs-keyword">else</span> {

		res.uv1tri1 = verb.eval.tri_uv_from_point( points1, tri1, uvs1, min.pt );
		res.uv1tri2 = min.uv;

	}

	res.pt1 = min.pt;

	<span class="hljs-keyword">if</span> (max.tri === <span class="hljs-number">0</span>){

		res.uv2tri1 = max.uv;
		res.uv2tri2 = verb.eval.tri_uv_from_point( points2, tri2, uvs2, max.pt );

	} <span class="hljs-keyword">else</span> {

		res.uv2tri1 = verb.eval.tri_uv_from_point( points1, tri1, uvs1, max.pt );
		res.uv2tri2 = max.uv;

	}

	res.pt2 = max.pt;

	<span class="hljs-keyword">return</span> res;

}

verb.eval.intersect_planes = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(o1, n1, o2, n2)</span></span>{

	<span class="hljs-keyword">var</span> d = numeric.cross(n1, n2);

	<span class="hljs-keyword">if</span> (numeric.dot(d, d) &lt; verb.EPSILON) <span class="hljs-keyword">return</span> { intersects: <span class="hljs-literal">false</span> };</pre></div></div>
            
        </li>
        
        
        <li id="section-255">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-255">&#182;</a>
              </div>
              <p>find the largest index of d</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> li = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> mi = <span class="hljs-built_in">Math</span>.abs( d[<span class="hljs-number">0</span>] );
	<span class="hljs-keyword">var</span> m1 = <span class="hljs-built_in">Math</span>.abs( d[<span class="hljs-number">1</span>] );
	<span class="hljs-keyword">var</span> m2 = <span class="hljs-built_in">Math</span>.abs( d[<span class="hljs-number">2</span>] );

	<span class="hljs-keyword">if</span> ( m1 &gt; mi ){
		li = <span class="hljs-number">1</span>;
		mi = m1;
	}

	<span class="hljs-keyword">if</span> ( m2 &gt; mi ){
		li = <span class="hljs-number">2</span>;
		mi = m2;
	}

	<span class="hljs-keyword">var</span> a1, b1, a2, b2;

	<span class="hljs-keyword">if</span> ( li === <span class="hljs-number">0</span> ){
		a1 = n1[<span class="hljs-number">1</span>];
		b1 = n1[<span class="hljs-number">2</span>];
		a2 = n2[<span class="hljs-number">1</span>];
		b2 = n2[<span class="hljs-number">2</span>];
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( li === <span class="hljs-number">1</span> ){
		a1 = n1[<span class="hljs-number">0</span>];
		b1 = n1[<span class="hljs-number">2</span>];
		a2 = n2[<span class="hljs-number">0</span>];
		b2 = n2[<span class="hljs-number">2</span>];
	} <span class="hljs-keyword">else</span> {
		a1 = n1[<span class="hljs-number">0</span>];
		b1 = n1[<span class="hljs-number">1</span>];
		a2 = n2[<span class="hljs-number">0</span>];
		b2 = n2[<span class="hljs-number">1</span>];
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-256">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-256">&#182;</a>
              </div>
              <p>n dot X = d</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> d1 = -numeric.dot( o1, n1 );
	<span class="hljs-keyword">var</span> d2 = -numeric.dot( o2, n2 );

	<span class="hljs-keyword">var</span> den = a1 * b2 - b1 * a2;

	<span class="hljs-keyword">var</span> x = (b1 * d2 - d1 * b2) / den;
	<span class="hljs-keyword">var</span> y = (d1 * a2 - a1 * d2) / den;
	<span class="hljs-keyword">var</span> p;

	<span class="hljs-keyword">if</span> ( li === <span class="hljs-number">0</span> ){
		p = [<span class="hljs-number">0</span>,x,y];
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( li === <span class="hljs-number">1</span> ){
		p = [x,<span class="hljs-number">0</span>,y];
	} <span class="hljs-keyword">else</span> {
		p = [x,y,<span class="hljs-number">0</span>];
	}

	<span class="hljs-keyword">return</span> { intersects: <span class="hljs-literal">true</span>, origin: p, dir : numeric.normalized( d ) };

}

verb.eval.tri_uv_from_point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points, tri, uvs, f )</span></span>{

	<span class="hljs-keyword">var</span> p1 = points[ tri[<span class="hljs-number">0</span>] ];
	<span class="hljs-keyword">var</span> p2 = points[ tri[<span class="hljs-number">1</span>] ];
	<span class="hljs-keyword">var</span> p3 = points[ tri[<span class="hljs-number">2</span>] ];

	<span class="hljs-keyword">var</span> uv1 = uvs[ tri[<span class="hljs-number">0</span>] ];
	<span class="hljs-keyword">var</span> uv2 = uvs[ tri[<span class="hljs-number">1</span>] ];
	<span class="hljs-keyword">var</span> uv3 = uvs[ tri[<span class="hljs-number">2</span>] ];

	<span class="hljs-keyword">var</span> f1 = numeric.sub(p1, f);
	<span class="hljs-keyword">var</span> f2 = numeric.sub(p2, f);
	<span class="hljs-keyword">var</span> f3 = numeric.sub(p3, f);</pre></div></div>
            
        </li>
        
        
        <li id="section-257">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-257">&#182;</a>
              </div>
              <p>calculate the areas and factors (order of parameters doesn’t matter):</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> a = numeric.norm2( numeric.cross( numeric.sub(p1, p2), numeric.sub(p1, p3) ) ); <span class="hljs-comment">// main triangle area a</span>
	<span class="hljs-keyword">var</span> a1 = numeric.norm2( numeric.cross(f2, f3) ) / a; <span class="hljs-comment">// p1's triangle area / a</span>
	<span class="hljs-keyword">var</span> a2 = numeric.norm2( numeric.cross(f3, f1) ) / a; <span class="hljs-comment">// p2's triangle area / a </span>
	<span class="hljs-keyword">var</span> a3 = numeric.norm2( numeric.cross(f1, f2) ) / a; <span class="hljs-comment">// p3's triangle area / a</span></pre></div></div>
            
        </li>
        
        
        <li id="section-258">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-258">&#182;</a>
              </div>
              <p>find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> numeric.add( numeric.mul( a1, uv1), numeric.mul( a2, uv2), numeric.mul( a3, uv3) );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-259">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-259">&#182;</a>
              </div>
              <h4 id="tessellate_rational_surface_naive-degree_u-knots_u-degree_v-knots_v-homo_control_points-divs_u-divs_v-">tessellate_rational_surface_naive( degree_u, knots_u, degree_v, knots_v, homo_control_points, divs_u, divs_v )</h4>
<p>Tessellate a nurbs surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, top to bottom is increasing u direction, left to right is increasing v direction,
and where each control point is an array of length (dim+1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, first element of array is an array of positions, second element are 3-tuple of triangle windings, third element is the 
uvs</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.tessellate_rational_surface_naive = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points, divs_u, divs_v )</span> </span>{

	<span class="hljs-keyword">if</span> ( divs_u &lt; <span class="hljs-number">1</span> ) {
		divs_u = <span class="hljs-number">1</span>;
	}

	<span class="hljs-keyword">if</span> ( divs_v &lt; <span class="hljs-number">1</span> ) {
		divs_v = <span class="hljs-number">1</span>;
	}

	<span class="hljs-keyword">var</span> u_span = knots_u[knots_u.length-<span class="hljs-number">1</span>] - knots_u[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">var</span> v_span = knots_v[knots_v.length-<span class="hljs-number">1</span>] - knots_v[<span class="hljs-number">0</span>];

	<span class="hljs-keyword">var</span> span_u = u_span / divs_u,
		span_v = v_span / divs_v;
  
  <span class="hljs-keyword">var</span> points = [];
  <span class="hljs-keyword">var</span> uvs = [];
  <span class="hljs-keyword">var</span> normals = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; divs_u + <span class="hljs-number">1</span>; i++) {
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; divs_v + <span class="hljs-number">1</span>; j++) {

			<span class="hljs-keyword">var</span> pt_u = i * span_u, 
				pt_v = j * span_v;

			uvs.push( [pt_u, pt_v] );

			<span class="hljs-keyword">var</span> derivs = verb.eval.rational_surface_derivs( degree_u, knots_u, degree_v, knots_v, homo_control_points, <span class="hljs-number">1</span>, pt_u, pt_v );
			<span class="hljs-keyword">var</span> pt = derivs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];

			points.push( pt );

			<span class="hljs-keyword">var</span> normal = numeric.normalized( numeric.cross(  derivs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], derivs[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] ) );
			normals.push( normal );

		}
	}

  	<span class="hljs-keyword">var</span> faces = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; divs_u ; i++) {
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; divs_v ; j++) {

			<span class="hljs-keyword">var</span> a_i = i * (divs_v + <span class="hljs-number">1</span>) + j,
				b_i = (i + <span class="hljs-number">1</span>) * (divs_v + <span class="hljs-number">1</span>) + j,
				c_i = b_i + <span class="hljs-number">1</span>,
				d_i = a_i + <span class="hljs-number">1</span>,
				abc = [a_i, b_i, c_i],
				acd = [a_i, c_i, d_i];

			faces.push(abc);
			faces.push(acd);

		}
	}

	<span class="hljs-keyword">return</span> { points: points, faces : faces, uvs: uvs, normals: normals };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-260">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-260">&#182;</a>
              </div>
              <h4 id="rational_curve_regular_sample-degree-knots-control_points-num_samples-include_u-">rational_curve_regular_sample( degree, knots, control_points, num_samples [, include_u] )</h4>
<p>Sample a NURBS curve, corresponds to <a href="http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf">http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf</a></p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values </li>
<li><em>Array</em>, 1d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) </li>
<li><em>Number</em>, integer number of samples</li>
<li><em>Boolean</em>, whether to prefix the point with the parameter</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an array of points, prepended by the point param</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.rational_curve_regular_sample = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, num_samples, include_u )</span> </span>{

	<span class="hljs-keyword">return</span> verb.eval.rational_curve_regular_sample_range( degree, knots, control_points, knots[<span class="hljs-number">0</span>], verb.last(knots), num_samples, include_u);

}</pre></div></div>
            
        </li>
        
        
        <li id="section-261">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-261">&#182;</a>
              </div>
              <h4 id="rational_curve_regular_sample_range-degree-knots-control_points-start_u-end_u-num_samples-include_u-">rational_curve_regular_sample_range( degree, knots, control_points, start_u, end_u, num_samples, include_u )</h4>
<p>Sample a NURBS curve assuming parameterization 0 to 1, corresponds to <a href="http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf">http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf</a></p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values </li>
<li><em>Array</em>, 1d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) </li>
<li><em>Number</em>, start parameter for sampling</li>
<li><em>Number</em>, end parameter for sampling</li>
<li><em>Number</em>, integer number of samples</li>
<li><em>Boolean</em>, whether to prefix the point with the parameter</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an dictionary of parameter - point pairs</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.rational_curve_regular_sample_range = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, start_u, end_u, num_samples, include_u )</span> </span>{

	<span class="hljs-keyword">if</span> (num_samples &lt; <span class="hljs-number">1</span>){
		num_samples = <span class="hljs-number">2</span>;
	}

	<span class="hljs-keyword">var</span> p = [],
		span = (end_u - start_u) / (num_samples - <span class="hljs-number">1</span>),
		u = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; num_samples; i++){

		u = start_u + span * i;
		<span class="hljs-keyword">if</span> ( include_u ){
			p.push( [u].concat( verb.eval.rational_curve_point(degree, knots, control_points, u) ) );
		} <span class="hljs-keyword">else</span> {
			p.push( verb.eval.rational_curve_point(degree, knots, control_points, u) );
		}
	
	}

	<span class="hljs-keyword">return</span> p;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-262">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-262">&#182;</a>
              </div>
              <h4 id="rational_curve_adaptive_sample-degree-knots-control_points-tol-include_u-">rational_curve_adaptive_sample( degree, knots, control_points, tol, include_u )</h4>
<p>Sample a NURBS curve assuming parameterization 0 to 1, corresponds to <a href="http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf">http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf</a></p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values </li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi) </li>
<li><em>Number</em>, tol for the adaptive scheme</li>
<li><em>Boolean</em>, whether to prefix the point with the parameter</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an array of dim + 1 length where the first element is the param where it was sampled and the remaining the pt</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.rational_curve_adaptive_sample = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, tol, include_u )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-263">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-263">&#182;</a>
              </div>
              <p>if degree is 1, just return the dehomogenized control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (degree === <span class="hljs-number">1</span>){ 
		<span class="hljs-keyword">if</span> ( !include_u ) {
			<span class="hljs-keyword">return</span> control_points.map( verb.eval.dehomogenize );
		} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-264">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-264">&#182;</a>
              </div>
              <p>the first element of each array is the parameter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> control_points.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x, i)</span></span>{
				<span class="hljs-keyword">return</span> [ knots[i+<span class="hljs-number">1</span>] ].concat( verb.eval.dehomogenize( x ) );
			});
		}
	}

	<span class="hljs-keyword">return</span> verb.eval.rational_curve_adaptive_sample_range( degree, knots, control_points, knots[<span class="hljs-number">0</span>], knots[knots.length-<span class="hljs-number">1</span>], tol, include_u );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-265">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-265">&#182;</a>
              </div>
              <h4 id="rational_curve_adaptive_sample_range-degree-knots-control_points-start_u-end_u-tol-include_u-">rational_curve_adaptive_sample_range( degree, knots, control_points, start_u, end_u, tol, include_u )</h4>
<p>Sample a NURBS curve at 3 points, facilitating adaptive sampling</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values </li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi) </li>
<li><em>Number</em>, start parameter for sampling</li>
<li><em>Number</em>, end parameter for sampling</li>
<li><em>Boolean</em>, whether to prefix the point with the parameter</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an array of dim + 1 length where the first element is the param where it was sampled and the remaining the pt</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.rational_curve_adaptive_sample_range = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, start_u, end_u, tol, include_u )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-266">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-266">&#182;</a>
              </div>
              <p>sample curve at three pts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> p1 = verb.eval.rational_curve_point(degree, knots, control_points, start_u),
		p3 = verb.eval.rational_curve_point(degree, knots, control_points, end_u),
		t = <span class="hljs-number">0.5</span> + <span class="hljs-number">0.2</span> * <span class="hljs-built_in">Math</span>.random(),
		mid_u = start_u + (end_u - start_u) * t,
		p2 = verb.eval.rational_curve_point(degree, knots, control_points, mid_u);</pre></div></div>
            
        </li>
        
        
        <li id="section-267">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-267">&#182;</a>
              </div>
              <p>if the two end control points are coincident, the three point test will always return 0, let’s split the curve</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> diff = numeric.sub( p1, p3);
	<span class="hljs-keyword">var</span> diff2 = numeric.sub( p1, p2);</pre></div></div>
            
        </li>
        
        
        <li id="section-268">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-268">&#182;</a>
              </div>
              <p>the first condition checks if the curve makes up a loop, if so, we will need to continue evaluation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> ( ( numeric.dot( diff, diff ) &lt; tol &amp;&amp; numeric.dot( diff2, diff2 ) &gt; tol ) || !verb.eval.three_points_are_flat( p1, p2, p3, tol ) ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-269">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-269">&#182;</a>
              </div>
              <p>get the exact middle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> exact_mid_u = start_u + (end_u - start_u) * <span class="hljs-number">0.5</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-270">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-270">&#182;</a>
              </div>
              <p>recurse on the two halves</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> left_pts = verb.eval.rational_curve_adaptive_sample_range( degree, knots, control_points, start_u, exact_mid_u, tol, include_u )
			, right_pts = verb.eval.rational_curve_adaptive_sample_range( degree, knots, control_points, exact_mid_u, end_u, tol, include_u );</pre></div></div>
            
        </li>
        
        
        <li id="section-271">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-271">&#182;</a>
              </div>
              <p>concatenate the two        </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">return</span> left_pts.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>).concat(right_pts);

	} <span class="hljs-keyword">else</span> {

		<span class="hljs-keyword">if</span> (include_u){
			<span class="hljs-keyword">return</span> [ 	[ start_u ].concat(p1) , [end_u].concat(p3) ];
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> [ 	p1, p3 ];
		}
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-272">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-272">&#182;</a>
              </div>
              <h4 id="three_points_are_flat-p1-p2-p3-tol-">three_points_are_flat( p1, p2, p3, tol )</h4>
<p>Determine if three points form a straight line within a given tolerance for their 2 * squared area</p>
<pre><code>     * p2
    / \
   /   \
  /     \ 
 /       \
* p1 ---- * p3
</code></pre><p>The area metric is 2 * the squared norm of the cross product of two edges, requiring no square roots and no divisions</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, p1</li>
<li><em>Array</em>, p2</li>
<li><em>Array</em>, p3</li>
<li><em>Number</em>, The tolerance for whether the three points form a line</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, Whether the triangle passes the test</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.three_points_are_flat = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( p1, p2, p3, tol )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-273">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-273">&#182;</a>
              </div>
              <p>find the area of the triangle without using a square root</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> p2mp1 = numeric.sub( p2, p1 )
		, p3mp1 = numeric.sub( p3, p1 )
		, norm = crossprod( p2mp1, p3mp1 )
		, area = numeric.dot( norm, norm );

	<span class="hljs-keyword">return</span> area &lt; tol;

}

verb.eval.divide_rational_surface_adaptive = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points, options )</span> </span>{

	<span class="hljs-keyword">var</span> i, j, li, lj;

	<span class="hljs-keyword">var</span> srf = {
		degree_u: degree_u,
		knots_u: knots_u,
		degree_v: degree_v,
		knots_v: knots_v,
		homo_control_points: homo_control_points
	};

	options = options || {};
	options.minDivsU = options.minDivsU || <span class="hljs-number">1</span>;
	options.minDivsV = options.minDivsV || <span class="hljs-number">1</span>;
	options.refine = options.refine != <span class="hljs-literal">undefined</span> ? options.refine : <span class="hljs-literal">true</span>;

	<span class="hljs-keyword">var</span> divsU = options.minDivsU = <span class="hljs-built_in">Math</span>.max( options.minDivsU, (homo_control_points.length - <span class="hljs-number">1</span>) * <span class="hljs-number">3</span> );
	<span class="hljs-keyword">var</span> divsV = options.minDivsV = <span class="hljs-built_in">Math</span>.max( options.minDivsV, (homo_control_points.length - <span class="hljs-number">1</span>) * <span class="hljs-number">3</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-274">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-274">&#182;</a>
              </div>
              <p>get necessary intervals</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> umax = verb.last(knots_u);
	<span class="hljs-keyword">var</span> umin = knots_u[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">var</span> vmax = verb.last(knots_v);
	<span class="hljs-keyword">var</span> vmin = knots_v[<span class="hljs-number">0</span>];

	<span class="hljs-keyword">var</span> du = (umax - umin) / divsU
		, dv = (vmax - vmin) / divsV;

	<span class="hljs-keyword">var</span> divs = [];
	<span class="hljs-keyword">var</span> pts = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-275">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-275">&#182;</a>
              </div>
              <p>1) evaluate all of the corners</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, li = divsV + <span class="hljs-number">1</span>; i &lt; li; i++){
		<span class="hljs-keyword">var</span> ptrow = [];
		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>, lj = divsU + <span class="hljs-number">1</span>; j &lt; lj; j++){

			<span class="hljs-keyword">var</span> u = umin + du * j
				, v = vmin + dv * i;</pre></div></div>
            
        </li>
        
        
        <li id="section-276">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-276">&#182;</a>
              </div>
              <p>todo: make this faster by specifying n,m</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> ds = verb.eval.rational_surface_derivs( degree_u, 
																												knots_u, 
																												degree_v, 
																												knots_v, 
																												homo_control_points, 
																												<span class="hljs-number">1</span>, 
																												u, 
																												v );

			<span class="hljs-keyword">var</span> norm = numeric.normalized( numeric.cross(  ds[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], ds[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] ) );
		  ptrow.push( <span class="hljs-keyword">new</span> verb.SurfacePoint( ds[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], 
		  																				norm, 
		  																				[u,v],
		  																				<span class="hljs-literal">null</span>, 
		  																				verb.isZero( norm ) ) );
		}
		pts.push( ptrow );
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-277">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-277">&#182;</a>
              </div>
              <p>2) make all of the nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; divsV; i++){
		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; divsU; j++){
			<span class="hljs-keyword">var</span> corners = [ pts[divsV - i - <span class="hljs-number">1</span>][j],
											pts[divsV - i - <span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>],
											pts[divsV - i][j+<span class="hljs-number">1</span>],
											pts[divsV - i][j] ];

		  divs.push( <span class="hljs-keyword">new</span> verb.eval.AdaptiveRefinementNode( srf, corners ) );
		}
	}

	<span class="hljs-keyword">if</span> (!options.refine) <span class="hljs-keyword">return</span> divs;</pre></div></div>
            
        </li>
        
        
        <li id="section-278">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-278">&#182;</a>
              </div>
              <p>3) assign all of the neighbors and divide</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; divsV; i++){
		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; divsU; j++){

			<span class="hljs-keyword">var</span> ci = i * divsU + j
				, n = verb.north( ci, i, j, divsU, divsV, divs )
				, e = verb.east( ci, i, j, divsU, divsV, divs  )
				, s = verb.south( ci, i, j, divsU, divsV, divs )
				, w = verb.west( ci, i, j, divsU, divsV, divs  );

		  divs[ci].neighbors = [ s, e, n, w ];
			divs[ci].divide( options );
		}
	}

	<span class="hljs-keyword">return</span> divs;

}

verb.north = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index, i, j, divsU, divsV, divs)</span></span>{
	<span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	<span class="hljs-keyword">return</span> divs[ index - divsU ];
}

verb.south = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index, i, j, divsU, divsV, divs)</span></span>{
	<span class="hljs-keyword">if</span> (i === divsV - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	<span class="hljs-keyword">return</span> divs[ index + divsU ];
}

verb.east = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index, i, j, divsU, divsV, divs)</span></span>{
	<span class="hljs-keyword">if</span> (j === divsU - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	<span class="hljs-keyword">return</span> divs[ index + <span class="hljs-number">1</span> ];
}

verb.west = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index, i, j, divsU, divsV, divs)</span></span>{
	<span class="hljs-keyword">if</span> (j === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;		
	<span class="hljs-keyword">return</span> divs[ index - <span class="hljs-number">1</span> ];
}

verb.eval.triangulate_adaptive_refinement_node_tree = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( arrTree )</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-279">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-279">&#182;</a>
              </div>
              <p>triangulate all of the nodes of the tree</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> mesh = verb.TriMesh.empty();
	arrTree.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span>{  x.triangulate( mesh ); });
	<span class="hljs-keyword">return</span> mesh;

}

verb.eval.tessellate_rational_surface_adaptive = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points, options )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-280">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-280">&#182;</a>
              </div>
              <p>adaptive divide</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> arrTrees = verb.eval.divide_rational_surface_adaptive( degree_u, knots_u, degree_v, knots_v, homo_control_points, options );</pre></div></div>
            
        </li>
        
        
        <li id="section-281">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-281">&#182;</a>
              </div>
              <p>triangulation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> verb.eval.triangulate_adaptive_refinement_node_tree( arrTrees );
}

verb.eval.dist_to_seg = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b, c)</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-282">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-282">&#182;</a>
              </div>
              <p>check if ac is zero length</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> acv = numeric.sub( c, a );
	<span class="hljs-keyword">var</span> acl = numeric.norm2( acv );</pre></div></div>
            
        </li>
        
        
        <li id="section-283">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-283">&#182;</a>
              </div>
              <p>subtract b from a</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> bma = numeric.sub(b, a);

	<span class="hljs-keyword">if</span> ( acl &lt; verb.TOLERANCE ){
		<span class="hljs-keyword">return</span> numeric.norm2( bma ); 
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-284">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-284">&#182;</a>
              </div>
              <p>normalized ac</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> ac = numeric.mul( <span class="hljs-number">1</span> / acl, acv );</pre></div></div>
            
        </li>
        
        
        <li id="section-285">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-285">&#182;</a>
              </div>
              <p>project b - a to ac = p</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> p = numeric.dot( bma, ac );</pre></div></div>
            
        </li>
        
        
        <li id="section-286">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-286">&#182;</a>
              </div>
              <p>multiply ac by d = acd</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> acd = numeric.add( a, numeric.mul( p, ac ) );</pre></div></div>
            
        </li>
        
        
        <li id="section-287">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-287">&#182;</a>
              </div>
              <p>subtract acd from adp</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> numeric.norm2( numeric.sub( acd, b ) );

}

verb.SurfacePoint = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(point, normal, uv, id, degen)</span></span>{
	<span class="hljs-keyword">this</span>.uv = uv;
	<span class="hljs-keyword">this</span>.point = point;
	<span class="hljs-keyword">this</span>.normal = normal;
	<span class="hljs-keyword">this</span>.id = id;
	<span class="hljs-keyword">this</span>.degen = degen;
}

verb.SurfacePoint.fromUv = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(u,v)</span></span>{
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> verb.SurfacePoint(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, [u,v], <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
}

verb.TriMesh = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(faces, points, uvs, normals)</span></span>{
	<span class="hljs-keyword">this</span>.faces = faces;
	<span class="hljs-keyword">this</span>.points = points;
	<span class="hljs-keyword">this</span>.uvs = uvs;
	<span class="hljs-keyword">this</span>.normals = normals;
}

verb.TriMesh.empty = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> verb.TriMesh([],[],[],[]);
}

verb.eval.AdaptiveRefinementNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( srf, corners, parentNode, neighbors )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-288">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-288">&#182;</a>
              </div>
              <p>Structure of the child nodes
in the adaptive refinement tree</p>
<p> v
 ^
 | 
 +—&gt; u</p>
<pre><code>                   neighbors[<span class="hljs-number">2</span>]

           (u0,v1)---(u05,v1)---(u1,v1)
             |           |          |
             |     <span class="hljs-number">3</span>     |     <span class="hljs-number">2</span>    |
             |           |          |
</code></pre><p>neighbors[3]   (u0,v05)—(u05,v05)—(u1,v05)   neighbors[1] 
                 |           |          | 
                 |     0     |     1    |
                 |           |          |
               (u0,v0)—-(u05,v0)—-(u1,v0)</p>
<pre><code>                   neighbors[<span class="hljs-number">0</span>]
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">this</span>.srf = srf;

	<span class="hljs-keyword">this</span>.parentNode = parentNode;
	<span class="hljs-keyword">this</span>.neighbors = neighbors || [<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-289">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-289">&#182;</a>
              </div>
              <p>if no corners, we need to construct initial corners from the surface</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (!corners){
		<span class="hljs-keyword">var</span> u0 = srf ? srf.knots_u[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>;
		<span class="hljs-keyword">var</span> u1 = srf ? verb.last( srf.knots_u ) : <span class="hljs-literal">null</span>;
		<span class="hljs-keyword">var</span> v0 = srf ? srf.knots_v[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>;
		<span class="hljs-keyword">var</span> v1 = srf ? verb.last( srf.knots_v ) : <span class="hljs-literal">null</span>;

		corners = [ verb.SurfacePoint.fromUv( u0, v0 ),
								verb.SurfacePoint.fromUv( u1, v0 ),
								verb.SurfacePoint.fromUv( u1, v1 ),
								verb.SurfacePoint.fromUv( u0, v1 ) ];

	}

	<span class="hljs-keyword">this</span>.corners = corners;

}

verb.eval.AdaptiveRefinementNode.prototype.isLeaf = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.children === <span class="hljs-literal">undefined</span>;
};

verb.eval.AdaptiveRefinementNode.prototype.center = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.centerPoint || <span class="hljs-keyword">this</span>.evalSrf( <span class="hljs-keyword">this</span>.u05, <span class="hljs-keyword">this</span>.v05 );
}

verb.eval.AdaptiveRefinementNode.prototype.evalCorners = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-290">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-290">&#182;</a>
              </div>
              <p>eval the center</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.u05 = <span class="hljs-keyword">this</span>.u05 || (<span class="hljs-keyword">this</span>.corners[<span class="hljs-number">0</span>].uv[<span class="hljs-number">0</span>] + <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">2</span>].uv[<span class="hljs-number">0</span>]) / <span class="hljs-number">2</span>;
	<span class="hljs-keyword">this</span>.v05 = <span class="hljs-keyword">this</span>.v05 || (<span class="hljs-keyword">this</span>.corners[<span class="hljs-number">0</span>].uv[<span class="hljs-number">1</span>] + <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">2</span>].uv[<span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-291">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-291">&#182;</a>
              </div>
              <p>eval all of the corners</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-292">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-292">&#182;</a>
              </div>
              <p>if it’s not already evaluated</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.corners[i].point ){</pre></div></div>
            
        </li>
        
        
        <li id="section-293">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-293">&#182;</a>
              </div>
              <p>evaluate it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">this</span>.corners[i];
			<span class="hljs-keyword">this</span>.evalSrf( c.uv[<span class="hljs-number">0</span>], c.uv[<span class="hljs-number">1</span>], c )
		} 
	}
}

verb.eval.AdaptiveRefinementNode.prototype.evalSrf = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, v, srfPt )</span></span>{

	<span class="hljs-keyword">var</span> derivs = verb.eval.rational_surface_derivs( <span class="hljs-keyword">this</span>.srf.degree_u, 
																												<span class="hljs-keyword">this</span>.srf.knots_u, 
																												<span class="hljs-keyword">this</span>.srf.degree_v, 
																												<span class="hljs-keyword">this</span>.srf.knots_v, 
																												<span class="hljs-keyword">this</span>.srf.homo_control_points, 
																												<span class="hljs-number">1</span>, 
																												u, 
																												v );
	<span class="hljs-keyword">var</span> pt = derivs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
	<span class="hljs-keyword">var</span> norm = numeric.cross(  derivs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], derivs[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] );
	<span class="hljs-keyword">var</span> degen = verb.isZero( norm );
	
	<span class="hljs-keyword">if</span> (!degen) norm = numeric.normalized( norm );

	<span class="hljs-keyword">if</span> (srfPt){
		srfPt.degen = degen;
		srfPt.point = pt;
		srfPt.normal = norm;
		<span class="hljs-keyword">return</span> srfPt;
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> verb.SurfacePoint( pt, norm, [u,v], <span class="hljs-literal">null</span>, degen );
	}

};

verb.eval.AdaptiveRefinementNode.prototype.getEdgeCorners = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( edgeIndex )</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-294">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-294">&#182;</a>
              </div>
              <p>if its a leaf, there are no children to obtain uvs from</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.isLeaf() ) <span class="hljs-keyword">return</span> [ <span class="hljs-keyword">this</span>.corners[ edgeIndex ] ]

	<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.horizontal ){

		<span class="hljs-keyword">switch</span> (edgeIndex){
			<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.children[<span class="hljs-number">0</span>].getEdgeCorners( <span class="hljs-number">0</span> );
			<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.children[<span class="hljs-number">0</span>].getEdgeCorners( <span class="hljs-number">1</span> ).concat( <span class="hljs-keyword">this</span>.children[<span class="hljs-number">1</span>].getEdgeCorners( <span class="hljs-number">1</span> ) );
			<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.children[<span class="hljs-number">1</span>].getEdgeCorners( <span class="hljs-number">2</span> );
			<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.children[<span class="hljs-number">1</span>].getEdgeCorners( <span class="hljs-number">3</span> ).concat( <span class="hljs-keyword">this</span>.children[<span class="hljs-number">0</span>].getEdgeCorners( <span class="hljs-number">3</span> ) );
		}

	}</pre></div></div>
            
        </li>
        
        
        <li id="section-295">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-295">&#182;</a>
              </div>
              <p>vertical case</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">switch</span> (edgeIndex) {
		<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.children[<span class="hljs-number">0</span>].getEdgeCorners( <span class="hljs-number">0</span> ).concat( <span class="hljs-keyword">this</span>.children[<span class="hljs-number">1</span>].getEdgeCorners( <span class="hljs-number">0</span> ) );
		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.children[<span class="hljs-number">1</span>].getEdgeCorners( <span class="hljs-number">1</span> );
		<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.children[<span class="hljs-number">1</span>].getEdgeCorners( <span class="hljs-number">2</span> ).concat( <span class="hljs-keyword">this</span>.children[<span class="hljs-number">0</span>].getEdgeCorners( <span class="hljs-number">2</span> ) );
		<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.children[<span class="hljs-number">0</span>].getEdgeCorners( <span class="hljs-number">3</span> );
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-296">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-296">&#182;</a>
              </div>
              <p>get the uvs owned by the children along this edge
return this.children[ edgeIndex ]
                        .getEdgeCorners( edgeIndex )
                        .concat( this.children[ (edgeIndex + 1) % 4 ].getEdgeCorners( edgeIndex ));</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
};

verb.eval.AdaptiveRefinementNode.prototype.getAllCorners = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( edgeIndex )</span></span>{

	<span class="hljs-keyword">var</span> baseArr = [ <span class="hljs-keyword">this</span>.corners[edgeIndex] ];

	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.neighbors[edgeIndex] ) {
		<span class="hljs-keyword">return</span> baseArr;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-297">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-297">&#182;</a>
              </div>
              <p>get opposite edges uvs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> corners = <span class="hljs-keyword">this</span>.neighbors[edgeIndex].getEdgeCorners( ( edgeIndex + <span class="hljs-number">2</span> ) % <span class="hljs-number">4</span> );

	<span class="hljs-keyword">var</span> funcIndex = edgeIndex % <span class="hljs-number">2</span>;

	<span class="hljs-keyword">var</span> e = verb.EPSILON;
	<span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-298">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-298">&#182;</a>
              </div>
              <p>range clipping functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> rangeFuncMap = [
		<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(c)</span></span>{ <span class="hljs-keyword">return</span> c.uv[<span class="hljs-number">0</span>] &gt; that.corners[<span class="hljs-number">0</span>].uv[<span class="hljs-number">0</span>] + e &amp;&amp; c.uv[<span class="hljs-number">0</span>] &lt; that.corners[<span class="hljs-number">2</span>].uv[<span class="hljs-number">0</span>] - e;  },
		<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(c)</span></span>{ <span class="hljs-keyword">return</span> c.uv[<span class="hljs-number">1</span>] &gt; that.corners[<span class="hljs-number">0</span>].uv[<span class="hljs-number">1</span>] + e &amp;&amp; c.uv[<span class="hljs-number">1</span>] &lt; that.corners[<span class="hljs-number">2</span>].uv[<span class="hljs-number">1</span>] - e;  },
	];</pre></div></div>
            
        </li>
        
        
        <li id="section-299">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-299">&#182;</a>
              </div>
              <p>clip the range of uvs to match this one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> baseArr.concat( corners.filter( rangeFuncMap[ funcIndex ] ).reverse() ) ;

};

verb.eval.AdaptiveRefinementNode.prototype.midpoint = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( index )</span></span>{

	<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.midPoints) <span class="hljs-keyword">this</span>.midpoints = [<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>];
	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.midpoints[index]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.midpoints[index];

	<span class="hljs-keyword">switch</span> (index){
		<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: 
			<span class="hljs-keyword">this</span>.midpoints[<span class="hljs-number">0</span>] = <span class="hljs-keyword">this</span>.evalSrf( <span class="hljs-keyword">this</span>.u05, <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">0</span>].uv[<span class="hljs-number">1</span>] );
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: 
			<span class="hljs-keyword">this</span>.midpoints[<span class="hljs-number">1</span>] = <span class="hljs-keyword">this</span>.evalSrf( <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">1</span>].uv[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.v05 );
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: 
			<span class="hljs-keyword">this</span>.midpoints[<span class="hljs-number">2</span>] = <span class="hljs-keyword">this</span>.evalSrf( <span class="hljs-keyword">this</span>.u05, <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">2</span>].uv[<span class="hljs-number">1</span>] );
			<span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: 
			<span class="hljs-keyword">this</span>.midpoints[<span class="hljs-number">3</span>] = <span class="hljs-keyword">this</span>.evalSrf( <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">0</span>].uv[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.v05 );
			<span class="hljs-keyword">break</span>;
	}

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.midpoints[index];

} 

verb.eval.AdaptiveRefinementNode.prototype.hasBadNormals = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( vec )</span></span>{
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">0</span>].degen || <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">1</span>].degen || <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">2</span>].degen || <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">3</span>].degen;
} 

verb.eval.AdaptiveRefinementNode.prototype.fixNormals = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = <span class="hljs-keyword">this</span>.corners.length; i &lt; l; i++){
		
		<span class="hljs-keyword">var</span> corn = <span class="hljs-keyword">this</span>.corners[i];

		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.corners[i].degen) {</pre></div></div>
            
        </li>
        
        
        <li id="section-300">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-300">&#182;</a>
              </div>
              <p>get neighbors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> v1 = <span class="hljs-keyword">this</span>.corners[(i + <span class="hljs-number">1</span>) % l];
			<span class="hljs-keyword">var</span> v2 = <span class="hljs-keyword">this</span>.corners[(i + <span class="hljs-number">3</span>) % l];</pre></div></div>
            
        </li>
        
        
        <li id="section-301">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-301">&#182;</a>
              </div>
              <p>correct the normal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">this</span>.corners[i].normal = v1.degen ? v2.normal : v1.normal;

		}

	}
} 

verb.eval.AdaptiveRefinementNode.prototype.shouldDivide = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( options, currentDepth )</span></span>{

	<span class="hljs-keyword">if</span> ( currentDepth &lt; options.minDepth ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	<span class="hljs-keyword">if</span> ( currentDepth &gt;= options.maxDepth ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

	<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.hasBadNormals() ) {
		<span class="hljs-keyword">this</span>.fixNormals();</pre></div></div>
            
        </li>
        
        
        <li id="section-302">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-302">&#182;</a>
              </div>
              <p>don’t divide any further when encountering a degenerate normal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; 
	}

	<span class="hljs-keyword">this</span>.splitVert = numeric.norm2Squared( numeric.sub( <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">0</span>].normal, <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">1</span>].normal ) ) &gt; options.normTol || 
		numeric.norm2Squared( numeric.sub( <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">2</span>].normal, <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">3</span>].normal ) ) &gt; options.normTol;

	<span class="hljs-keyword">this</span>.splitHoriz = numeric.norm2Squared( numeric.sub( <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">1</span>].normal, <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">2</span>].normal ) ) &gt; options.normTol || 
		numeric.norm2Squared( numeric.sub( <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">3</span>].normal, <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">0</span>].normal ) ) &gt; options.normTol;

	<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.splitVert || <span class="hljs-keyword">this</span>.splitHoriz ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

	<span class="hljs-keyword">var</span> center = <span class="hljs-keyword">this</span>.center();

	<span class="hljs-keyword">return</span> numeric.norm2Squared( numeric.sub( center.normal, <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">0</span>].normal ) ) &gt; options.normTol ||
				 numeric.norm2Squared( numeric.sub( center.normal, <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">1</span>].normal ) ) &gt; options.normTol || 
				 numeric.norm2Squared( numeric.sub( center.normal, <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">2</span>].normal ) ) &gt; options.normTol || 
				 numeric.norm2Squared( numeric.sub( center.normal, <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">3</span>].normal ) ) &gt; options.normTol;
}

verb.eval.AdaptiveRefinementNode.prototype.divide = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( options )</span></span>{

	options = options || {};
	options.normTol = options.normTol || <span class="hljs-number">8.5e-2</span>;
	options.minDepth = options.minDepth != <span class="hljs-literal">undefined</span> ? options.minDepth : <span class="hljs-number">0</span>;
	options.maxDepth = options.maxDepth != <span class="hljs-literal">undefined</span> ? options.maxDepth : <span class="hljs-number">10</span>;

	<span class="hljs-keyword">this</span>._divide( options, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span> );

};

verb.eval.AdaptiveRefinementNode.prototype._divide = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( options, currentDepth, horiz )</span></span>{

	<span class="hljs-keyword">this</span>.evalCorners();

	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.shouldDivide( options, currentDepth )  ) <span class="hljs-keyword">return</span>;
	
	currentDepth++;</pre></div></div>
            
        </li>
        
        
        <li id="section-303">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-303">&#182;</a>
              </div>
              <p>is the quad flat in one dir and curved in the other?  </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.splitVert &amp;&amp; !<span class="hljs-keyword">this</span>.splitHoriz) {
		horiz = <span class="hljs-literal">false</span>;
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.splitVert &amp;&amp; <span class="hljs-keyword">this</span>.splitHoriz){
		horiz = <span class="hljs-literal">true</span>;
	 }

	<span class="hljs-keyword">this</span>.horizontal = horiz;

	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.horizontal){

		<span class="hljs-keyword">var</span> bott = 	[ <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>.midpoint(<span class="hljs-number">1</span>), <span class="hljs-keyword">this</span>.midpoint(<span class="hljs-number">3</span>)  ];
		<span class="hljs-keyword">var</span> top = 	[ <span class="hljs-keyword">this</span>.midpoint(<span class="hljs-number">3</span>), <span class="hljs-keyword">this</span>.midpoint(<span class="hljs-number">1</span>), <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">2</span>], <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">3</span>]  ];

		<span class="hljs-keyword">this</span>.children = [ 	<span class="hljs-keyword">new</span> verb.eval.AdaptiveRefinementNode( <span class="hljs-keyword">this</span>.srf, bott, <span class="hljs-keyword">this</span> ),
												<span class="hljs-keyword">new</span> verb.eval.AdaptiveRefinementNode( <span class="hljs-keyword">this</span>.srf, top, <span class="hljs-keyword">this</span> ) ];</pre></div></div>
            
        </li>
        
        
        <li id="section-304">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-304">&#182;</a>
              </div>
              <p>assign neighbors to bottom node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">this</span>.children[<span class="hljs-number">0</span>].neighbors = [ <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>.children[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">3</span>] ];</pre></div></div>
            
        </li>
        
        
        <li id="section-305">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-305">&#182;</a>
              </div>
              <p>assign neighbors to top node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">this</span>.children[<span class="hljs-number">1</span>].neighbors = [ <span class="hljs-keyword">this</span>.children[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">2</span>], <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">3</span>] ];

	} <span class="hljs-keyword">else</span> {

		<span class="hljs-keyword">var</span> left = [ <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.midpoint(<span class="hljs-number">0</span>), <span class="hljs-keyword">this</span>.midpoint(<span class="hljs-number">2</span>), <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">3</span>]  ];
		<span class="hljs-keyword">var</span> right = [ <span class="hljs-keyword">this</span>.midpoint(<span class="hljs-number">0</span>), <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>.corners[<span class="hljs-number">2</span>], <span class="hljs-keyword">this</span>.midpoint(<span class="hljs-number">2</span>)  ];

		<span class="hljs-keyword">this</span>.children = [ 	<span class="hljs-keyword">new</span> verb.eval.AdaptiveRefinementNode( <span class="hljs-keyword">this</span>.srf, left, <span class="hljs-keyword">this</span> ),
												<span class="hljs-keyword">new</span> verb.eval.AdaptiveRefinementNode( <span class="hljs-keyword">this</span>.srf, right, <span class="hljs-keyword">this</span> ) ];

		<span class="hljs-keyword">this</span>.children[<span class="hljs-number">0</span>].neighbors = [ <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.children[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">2</span>], <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">3</span>] ];
		<span class="hljs-keyword">this</span>.children[<span class="hljs-number">1</span>].neighbors = [ <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">2</span>], <span class="hljs-keyword">this</span>.children[<span class="hljs-number">0</span>] ];

	}</pre></div></div>
            
        </li>
        
        
        <li id="section-306">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-306">&#182;</a>
              </div>
              <p>divide all children recursively</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.children.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span>{ x._divide( options, currentDepth, !horiz ); })

};

verb.eval.AdaptiveRefinementNode.prototype.triangulate = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( mesh )</span></span>{

	mesh = mesh || verb.TriMesh.empty();

	<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.isLeaf() ) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.triangulateLeaf( mesh );</pre></div></div>
            
        </li>
        
        
        <li id="section-307">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-307">&#182;</a>
              </div>
              <p>recurse on the children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.children.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span>{
		<span class="hljs-keyword">if</span> (!x) <span class="hljs-keyword">return</span>;
		x.triangulate( mesh );
	});

	<span class="hljs-keyword">return</span> mesh;

};

verb.eval.AdaptiveRefinementNode.prototype.triangulateLeaf = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( mesh )</span></span>{

	<span class="hljs-keyword">var</span> baseIndex = mesh.points.length 
		, uvs = []
		, ids = []
		, i = <span class="hljs-number">0</span>
		, corner
		, l
		, j
		, splitid;</pre></div></div>
            
        </li>
        
        
        <li id="section-308">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-308">&#182;</a>
              </div>
              <p>enumerate all uvs in counter clockwise direction</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++){

		<span class="hljs-keyword">var</span> edgeCorners = <span class="hljs-keyword">this</span>.getAllCorners(i);</pre></div></div>
            
        </li>
        
        
        <li id="section-309">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-309">&#182;</a>
              </div>
              <p>this is the vertex that is split</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (edgeCorners.length === <span class="hljs-number">2</span> ) splitid = i + <span class="hljs-number">1</span>;

		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; edgeCorners.length; j++) 
			uvs.push(edgeCorners[j])
	}

	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = uvs.length; i &lt; l; i++){
		corner = uvs[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-310">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-310">&#182;</a>
              </div>
              <p>if the id is defined, we can just push it and continue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (corner.id != <span class="hljs-literal">undefined</span>){
			ids.push(corner.id);
			<span class="hljs-keyword">continue</span>;
		}

		mesh.uvs.push( corner.uv );
		mesh.points.push( corner.point );
		mesh.normals.push( corner.normal );

		corner.id = baseIndex;
		ids.push( baseIndex );

		baseIndex++;
	}

	<span class="hljs-keyword">if</span> (uvs.length === <span class="hljs-number">4</span>){</pre></div></div>
            
        </li>
        
        
        <li id="section-311">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-311">&#182;</a>
              </div>
              <p>if the number of points is 4, we’re just doing a
rectangle - just build the basic triangulated square</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		mesh.faces.push( [ ids[<span class="hljs-number">0</span>], ids[<span class="hljs-number">3</span>], ids[<span class="hljs-number">1</span>] ] );
		mesh.faces.push( [ ids[<span class="hljs-number">3</span>], ids[<span class="hljs-number">2</span>], ids[<span class="hljs-number">1</span>] ] );</pre></div></div>
            
        </li>
        
        
        <li id="section-312">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-312">&#182;</a>
              </div>
              <p>all done </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">return</span> mesh;

	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (uvs.length === <span class="hljs-number">5</span>){</pre></div></div>
            
        </li>
        
        
        <li id="section-313">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-313">&#182;</a>
              </div>
              <p>use the splitcorner to triangulate</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> il = ids.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-314">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-314">&#182;</a>
              </div>
              <p>there will be 3 triangles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		mesh.faces.push( [ ids[ splitid ], 
											 ids[ (splitid + <span class="hljs-number">1</span>) % il ], 
											 ids[ (splitid + <span class="hljs-number">2</span>) % il ] ] );

		mesh.faces.push( [ ids[ (splitid + <span class="hljs-number">4</span>) % il ], 
											 ids[ (splitid + <span class="hljs-number">3</span>) % il ], 
											 ids[ splitid ] ] );

		mesh.faces.push( [ ids[ splitid ], 
		 									 ids[ (splitid + <span class="hljs-number">2</span>) % il ],
		 									 ids[ (splitid + <span class="hljs-number">3</span>) % il ] ]);

		<span class="hljs-keyword">return</span> mesh;

	}</pre></div></div>
            
        </li>
        
        
        <li id="section-315">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-315">&#182;</a>
              </div>
              <p>make point at center of face</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> center = <span class="hljs-keyword">this</span>.center();

	mesh.uvs.push( center.uv );	
	mesh.points.push( center.point );
	mesh.normals.push( center.normal );</pre></div></div>
            
        </li>
        
        
        <li id="section-316">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-316">&#182;</a>
              </div>
              <p>get index </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> centerIndex = mesh.points.length - <span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-317">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-317">&#182;</a>
              </div>
              <p>build triangle fan from center</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = uvs.length-<span class="hljs-number">1</span>; i &lt; uvs.length; j = i++){
		mesh.faces.push( [	centerIndex, ids[j], ids[i]   ]);
	}

	<span class="hljs-keyword">return</span> mesh;

};





verb.eval.rational_surface_closest_point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points, p )</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-318">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-318">&#182;</a>
              </div>
              <p>for surfaces, we try to minimize the following:</p>
<p>f = Su(u,v) <em> r = 0
g = Sv(u,v) </em> r = 0</p>
<p> where r = S(u,v) - P</p>
<p>Again, this requires newton iteration, but this time our objective function is vector valued</p>
<p>   J d = k</p>
<p>   d =   [ u<em> - u, v</em> - v ]
    k = - [ f(u,v), g(u,v) ]
    J =
         |Su|^2   +  Suu <em> r       Su</em>Sv  +  Suv <em> r
               Su</em>Sv   +  Svu <em> r      |Sv|^2  +  Svv </em> r</p>
<pre><code>we have similar halting conditions:
</code></pre><p> point coincidence</p>
<pre><code>|S(u,v) - p| <span class="xml"><span class="hljs-tag">&lt; <span class="hljs-attribute">e1</span></span></span>
</code></pre><p> cosine</p>
<p>  |Su(u,v)*(S(u,v) - P)|
  ———————————  &lt; e2
  |Su(u,v)| |S(u,v) - P|</p>
<p>  |Sv(u,v)*(S(u,v) - P)|
  ———————————  &lt; e2
  |Sv(u,v)| |S(u,v) - P|</p>
<p> 1) first check 2 &amp; 3
    2) if at least one of these is not, compute new value, otherwise halt
    3) ensure the parameter stays within range</p>
<pre><code>        * if not closed, don&#39;t allow outside of range a-b
        * if closed (e.g. circle), allow to move back to beginning
</code></pre><p> 4)  if |(u* - u)C’(u)| &lt; e1, halt</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	
	<span class="hljs-keyword">var</span> maxits = <span class="hljs-number">5</span>;
	<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>
		, e
		, eps1 = <span class="hljs-number">0.0001</span>
		, eps2 = <span class="hljs-number">0.0005</span>
		, dif
		, minu = knots_u[<span class="hljs-number">0</span>]
		, maxu = verb.last(knots_u)
		, minv = knots_v[<span class="hljs-number">0</span>]
		, maxv = verb.last(knots_v)
		, closedu = homo_control_points[<span class="hljs-number">0</span>].reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(acc,x,i)</span></span>{ <span class="hljs-keyword">return</span> acc &amp;&amp; numeric.norm2Squared( numeric.sub(x, verb.last(homo_control_points)[i] ) ) &lt; verb.EPSILON; })
		, transposed = numeric.transpose( homo_control_points )
		, closedv = transposed[<span class="hljs-number">0</span>].reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(acc, x,i)</span></span>{ <span class="hljs-keyword">return</span> acc &amp;&amp; numeric.norm2Squared( numeric.sub(x, verb.last(transposed)[i] ) ) &lt; verb.EPSILON; })
		, cuv;</pre></div></div>
            
        </li>
        
        
        <li id="section-319">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-319">&#182;</a>
              </div>
              <p>console.log(closedu, closedv)</p>

            </div>
            
        </li>
        
        
        <li id="section-320">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-320">&#182;</a>
              </div>
              <p>approximate closest point with tessellation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> tess = verb.eval.tessellate_rational_surface_adaptive( degree_u, knots_u, degree_v, knots_v, 
		homo_control_points, { normTol: <span class="hljs-number">5e-2</span> } );

	<span class="hljs-keyword">var</span> dmin = <span class="hljs-built_in">Number</span>.MAX_VALUE;
	tess.points.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x,i)</span></span>{

		<span class="hljs-keyword">var</span> d = numeric.norm2Squared( numeric.sub( p, x ) );

		<span class="hljs-keyword">if</span> ( d &lt; dmin ){
			dmin = d;
			cuv = tess.uvs[i];
		}

	});</pre></div></div>
            
        </li>
        
        
        <li id="section-321">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-321">&#182;</a>
              </div>
              <p>console.log(dmin)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(uv)</span></span>{
		<span class="hljs-keyword">var</span> d = verb.eval.rational_surface_derivs( degree_u, knots_u, degree_v, knots_v, homo_control_points, <span class="hljs-number">2</span>, uv[<span class="hljs-number">0</span>], uv[<span class="hljs-number">1</span>] );</pre></div></div>
            
        </li>
        
        
        <li id="section-322">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-322">&#182;</a>
              </div>
              <p>console.log(d);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">return</span> d;
	}

	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span><span class="hljs-params">(uv, e, r)</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-323">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-323">&#182;</a>
              </div>
              <p>f = Su(u,v) <em> r = 0
g = Sv(u,v) </em> r = 0</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-keyword">var</span> Su = e[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
		<span class="hljs-keyword">var</span> Sv = e[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];

		<span class="hljs-keyword">var</span> Suu = e[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>];
		<span class="hljs-keyword">var</span> Svv = e[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];

		<span class="hljs-keyword">var</span> Suv = e[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];
		<span class="hljs-keyword">var</span> Svu = e[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];

		<span class="hljs-keyword">var</span> f = numeric.dot( Su, r );
		<span class="hljs-keyword">var</span> g = numeric.dot( Sv, r );

		<span class="hljs-keyword">var</span> k = [-f, -g];

		<span class="hljs-keyword">var</span> J00 = numeric.dot( Su, Su ) + numeric.dot( Suu, r );
		<span class="hljs-keyword">var</span> J01 = numeric.dot( Su, Sv ) + numeric.dot( Suv, r );
		<span class="hljs-keyword">var</span> J10 = numeric.dot( Su, Sv ) + numeric.dot( Svu, r );
		<span class="hljs-keyword">var</span> J11 = numeric.dot( Sv, Sv ) + numeric.dot( Svv, r );

		<span class="hljs-keyword">var</span> J = [ [ J00, J01 ], [ J10, J11 ] ];</pre></div></div>
            
        </li>
        
        
        <li id="section-324">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-324">&#182;</a>
              </div>
              <p>   d =   [ u<em> - u, v</em> - v ]
    k = - [ f(u,v), g(u,v) ]
    J =
         |Su|^2   +  Suu <em> r       Su</em>Sv  +  Suv <em> r
               Su</em>Sv   +  Svu <em> r      |Sv|^2  +  Svv </em> r</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
		<span class="hljs-keyword">var</span> d = numeric.solve( J, k );

		<span class="hljs-keyword">return</span> numeric.add( d, uv );

	}

	<span class="hljs-keyword">while</span>( i &lt; maxits ){

		e = f(cuv);
		dif = numeric.sub(e[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], p );</pre></div></div>
            
        </li>
        
        
        <li id="section-325">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-325">&#182;</a>
              </div>
              <p>console.log(‘dist’, numeric.norm2Squared(dif))
console.log(‘uv’, cuv)</p>

            </div>
            
        </li>
        
        
        <li id="section-326">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-326">&#182;</a>
              </div>
              <p> point coincidence</p>
<pre><code>|S(u,v) - p| <span class="xml"><span class="hljs-tag">&lt; <span class="hljs-attribute">e1</span></span></span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> c1v = numeric.norm2( dif );</pre></div></div>
            
        </li>
        
        
        <li id="section-327">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-327">&#182;</a>
              </div>
              <p> cosine</p>
<p>  |Su(u,v)*(S(u,v) - P)|
  ———————————  &lt; e2
  |Su(u,v)| |S(u,v) - P|</p>
<p>  |Sv(u,v)*(S(u,v) - P)|
  ———————————  &lt; e2
  |Sv(u,v)| |S(u,v) - P|</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> c2an = numeric.norm2( numeric.dot( e[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dif) );
		<span class="hljs-keyword">var</span> c2ad = numeric.norm2( e[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] ) * c1;

		<span class="hljs-keyword">var</span> c2bn = numeric.norm2( numeric.dot( e[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], dif) );
		<span class="hljs-keyword">var</span> c2bd = numeric.norm2( e[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] ) * c1;

		<span class="hljs-keyword">var</span> c2av = c2an / c2ad;
		<span class="hljs-keyword">var</span> c2bv = c2bn / c2bd;

		<span class="hljs-keyword">var</span> c1 = c1v &lt; eps1;
		<span class="hljs-keyword">var</span> c2a = c2av &lt; eps2;
		<span class="hljs-keyword">var</span> c2b = c2bv &lt; eps2;</pre></div></div>
            
        </li>
        
        
        <li id="section-328">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-328">&#182;</a>
              </div>
              <p>if all of the tolerance are met, we’re done</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (c1 &amp;&amp; c2a &amp;&amp; c2b){
			<span class="hljs-keyword">return</span> cuv;
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-329">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-329">&#182;</a>
              </div>
              <p>otherwise, take a step</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> ct = n(cuv, e, dif);</pre></div></div>
            
        </li>
        
        
        <li id="section-330">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-330">&#182;</a>
              </div>
              <p>console.log(‘ct prop’, ct)</p>

            </div>
            
        </li>
        
        
        <li id="section-331">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-331">&#182;</a>
              </div>
              <p>correct for exceeding bounds</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> ( ct[<span class="hljs-number">0</span>] &lt; minu ){
			ct = closedu ? [ maxu - ( ct[<span class="hljs-number">0</span>] - minu ), ct[<span class="hljs-number">1</span>] ] : [ minu + verb.EPSILON, ct[<span class="hljs-number">1</span>] ];
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ct[<span class="hljs-number">0</span>] &gt; maxu){
			ct = closedu ? [ minu + ( ct[<span class="hljs-number">0</span>] - maxu ), ct[<span class="hljs-number">1</span>] ] : [ maxu - verb.EPSILON, ct[<span class="hljs-number">1</span>] ];
		}

		<span class="hljs-keyword">if</span> ( ct[<span class="hljs-number">1</span>] &lt; minv ){
			ct = closedv ? [ ct[<span class="hljs-number">0</span>], maxv - ( ct[<span class="hljs-number">1</span>] - minv ) ] : [ ct[<span class="hljs-number">0</span>], minv + verb.EPSILON ];
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ct[<span class="hljs-number">1</span>] &gt; maxv){
			ct = closedv ? [ ct[<span class="hljs-number">0</span>], minv + ( ct[<span class="hljs-number">0</span>] - maxv ) ] : [ ct[<span class="hljs-number">0</span>], maxv - verb.EPSILON ];
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-332">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-332">&#182;</a>
              </div>
              <p>if |(u* - u) C’(u)| &lt; e1, halt</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> c3v0 =  numeric.norm2( numeric.mul(ct[<span class="hljs-number">0</span>] - cuv[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] ) );
		<span class="hljs-keyword">var</span> c3v1 =  numeric.norm2( numeric.mul(ct[<span class="hljs-number">1</span>] - cuv[<span class="hljs-number">1</span>], e[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] ) );

		<span class="hljs-keyword">if</span> (c3v0 + c3v1 &lt; eps1) {
			<span class="hljs-keyword">return</span> cuv;
		}

		cuv = ct;
		i++;

	}

	<span class="hljs-keyword">return</span> cuv;

}

verb.eval.rational_curve_closest_point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, p )</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-333">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-333">&#182;</a>
              </div>
              <p> We want to solve:</p>
<p>  C’(u) * ( C(u) - P ) = 0 = f(u)</p>
<p> C(u) is the curve, p is the point, * is a dot product</p>
<p>We’ll use newton’s method:</p>
<pre><code> u* = u - f / f<span class="hljs-string">'  </span>
</code></pre><p>We use the product rule in order to form the derivative, f’:</p>
<p>f’ = C”(u) <em> ( C(u) - p ) + C’(u) </em> C’(u)</p>
<p>What is the conversion criteria? (Piegl &amp; Tiller suggest)</p>
<p>|C(u) - p| &lt; e1</p>
<p>|C’(u)*(C(u) - P)|
—————————  &lt; e2
|C’(u)| |C(u) - P|</p>
<p> 1) first check 2 &amp; 3
    2) if at least one of these is not, compute new value, otherwise halt
    3) ensure the parameter stays within range</p>
<pre><code>        * if not closed, don&#39;t allow outside of range a-b
        * if closed (e.g. circle), allow to move back to beginning
</code></pre><p> 4)  if |(u* - u)C’(u)| &lt; e1, halt</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">var</span> tol = <span class="hljs-number">1e-3</span>;
	<span class="hljs-keyword">var</span> min = <span class="hljs-built_in">Number</span>.MAX_VALUE;
	<span class="hljs-keyword">var</span> u = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">var</span> pts = verb.eval.rational_curve_adaptive_sample( degree, knots, control_points, tol, <span class="hljs-literal">true</span> )

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pts.length-<span class="hljs-number">1</span>; i++){

		<span class="hljs-keyword">var</span> u0 = pts[i][<span class="hljs-number">0</span>];
		<span class="hljs-keyword">var</span> u1 = pts[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];

		<span class="hljs-keyword">var</span> p0 = pts[i].slice(<span class="hljs-number">1</span>);
		<span class="hljs-keyword">var</span> p1 = pts[i+<span class="hljs-number">1</span>].slice(<span class="hljs-number">1</span>);

		<span class="hljs-keyword">var</span> proj = verb.eval.closest_point_on_segment( p, p0, p1, u0, u1 );
		<span class="hljs-keyword">var</span> d = numeric.norm2( numeric.sub( p, proj.pt ) );

		<span class="hljs-keyword">if</span> ( d &lt; min ){
			min = d;
			u = proj.u;
		}
	}

	<span class="hljs-keyword">var</span> maxits = <span class="hljs-number">5</span>
		, i = <span class="hljs-number">0</span>
		, e
		, eps1 = <span class="hljs-number">0.0001</span>
		, eps2 = <span class="hljs-number">0.0005</span>
		, dif
		, minu = knots[<span class="hljs-number">0</span>]
		, maxu = verb.last(knots)
		, closed = numeric.norm2Squared( numeric.sub(control_points[<span class="hljs-number">0</span>], verb.last( control_points) ) ) &lt; verb.EPSILON
		, cu = u; 

	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(u)</span></span>{
		<span class="hljs-keyword">return</span> verb.eval.rational_curve_derivs( degree, knots, control_points, u, <span class="hljs-number">2</span> );
	}

	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span><span class="hljs-params">(u, e, d)</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-334">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-334">&#182;</a>
              </div>
              <p>  C’(u) * ( C(u) - P ) = 0 = f(u)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> f = numeric.dot( e[<span class="hljs-number">1</span>], d );</pre></div></div>
            
        </li>
        
        
        <li id="section-335">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-335">&#182;</a>
              </div>
              <p>f’ = C”(u) <em> ( C(u) - p ) + C’(u) </em> C’(u)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> s0 = numeric.dot( e[<span class="hljs-number">2</span>], d )
			, s1 = numeric.dot( e[<span class="hljs-number">1</span>], e[<span class="hljs-number">1</span>] )
			, df = s0 + s1;

		<span class="hljs-keyword">return</span> u - f / df;

	}

	<span class="hljs-keyword">while</span>( i &lt; maxits ){

		e = f( cu );
		dif = numeric.sub( e[<span class="hljs-number">0</span>], p );</pre></div></div>
            
        </li>
        
        
        <li id="section-336">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-336">&#182;</a>
              </div>
              <p>|C(u) - p| &lt; e1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> c1v = numeric.norm2( dif );</pre></div></div>
            
        </li>
        
        
        <li id="section-337">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-337">&#182;</a>
              </div>
              <p>C’(u) * (C(u) - P)
————————— &lt; e2
|C’(u)| |C(u) - P|</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> c2n = numeric.dot( e[<span class="hljs-number">1</span>], dif);
		<span class="hljs-keyword">var</span> c2d = numeric.norm2( e[<span class="hljs-number">1</span>] ) * c1v;

		<span class="hljs-keyword">var</span> c2v = c2n / c2d;

		<span class="hljs-keyword">var</span> c1 = c1v &lt; eps1;
		<span class="hljs-keyword">var</span> c2 = <span class="hljs-built_in">Math</span>.abs(c2v) &lt; eps2;</pre></div></div>
            
        </li>
        
        
        <li id="section-338">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-338">&#182;</a>
              </div>
              <p>if both tolerances are met</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (c1 &amp;&amp; c2){
			<span class="hljs-keyword">return</span> cu;
		}

		<span class="hljs-keyword">var</span> ct = n(cu, e, dif);</pre></div></div>
            
        </li>
        
        
        <li id="section-339">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-339">&#182;</a>
              </div>
              <p>are we outside of the bounds of the curve?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> ( ct &lt; minu ){
			ct = closed ? maxu - ( ct - minu ) : minu;
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ct &gt; maxu){
			ct = closed ? minu + ( ct - maxu ) : maxu;
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-340">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-340">&#182;</a>
              </div>
              <p>will our next step force us out of the curve?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> c3v = numeric.norm2( numeric.mul(ct - cu, e[<span class="hljs-number">1</span>] ) );
		<span class="hljs-keyword">if</span> (c3v &lt; eps1) {
			<span class="hljs-keyword">return</span> cu;
		}

		cu = ct;
		i++;

	}

	<span class="hljs-keyword">return</span> cu;

}

verb.eval.rational_curve_divide_curve_equally_by_arc_length = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(degree, knots, control_points, num)</span></span>{

	<span class="hljs-keyword">var</span> tlen = verb.eval.rational_curve_arc_length( degree, knots, control_points );
	<span class="hljs-keyword">var</span> inc = tlen / num;

	<span class="hljs-keyword">return</span> verb.eval.rational_curve_divide_curve_by_arc_length(degree, knots, control_points, inc);

}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CurvePoint</span><span class="hljs-params">(u, len)</span></span>{
	<span class="hljs-keyword">this</span>.u = u;
	<span class="hljs-keyword">this</span>.len = len;
}

verb.eval.rational_curve_divide_curve_by_arc_length = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(degree, knots, control_points, l)</span></span>{

	<span class="hljs-keyword">var</span> crvs = verb.eval.curve_bezier_decompose( degree, knots, control_points )
		, crvlens = crvs.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span>{ <span class="hljs-keyword">return</span> verb.eval.rational_bezier_curve_arc_length( x.degree, x.knots, x.control_points ); })
		, totlen = crvlens.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(acc, l)</span></span>{ <span class="hljs-keyword">return</span> acc + l; }, <span class="hljs-number">0</span>)
		, pts = [ <span class="hljs-keyword">new</span> CurvePoint( knots[<span class="hljs-number">0</span>], <span class="hljs-number">0</span> ) ];

	<span class="hljs-keyword">if</span> (l &gt; totlen) <span class="hljs-keyword">return</span> pts;

	<span class="hljs-keyword">var</span> inc = l
		, i = <span class="hljs-number">0</span>
		, lc = inc
		, runsum = <span class="hljs-number">0</span>
		, runsum1 = <span class="hljs-number">0</span>
		, u;

	<span class="hljs-keyword">while</span> ( i &lt; crvs.length ){

		runsum += crvlens[i];

		<span class="hljs-keyword">while</span> ( lc &lt; runsum + verb.EPSILON ){

			u = verb.eval.rational_bezier_curve_param_at_arc_length( crvs[i].degree, crvs[i].knots, crvs[i].control_points, 
				lc - runsum1, verb.TOLERANCE, crvlens[i] );

			pts.push( <span class="hljs-keyword">new</span> CurvePoint( u, lc ) );
			lc += inc;

		}

		runsum1 += crvlens[i];

		i++;

	}

	<span class="hljs-keyword">return</span> pts;

}

verb.eval.rational_curve_param_at_arc_length = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(degree, knots, control_points, len, tol, beziers, bezier_lengths)</span></span>{

	<span class="hljs-keyword">if</span> (len &lt; verb.EPSILON) <span class="hljs-keyword">return</span> knots[<span class="hljs-number">0</span>];

	<span class="hljs-keyword">var</span> crvs = beziers || verb.eval.curve_bezier_decompose( degree, knots, control_points )
		, i = <span class="hljs-number">0</span>
		, cc = crvs[i]
		, cl = -verb.EPSILON
		, bezier_lengths = bezier_lengths || [];</pre></div></div>
            
        </li>
        
        
        <li id="section-341">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-341">&#182;</a>
              </div>
              <p>iterate through the curves consuming the bezier’s, summing their length along the way</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; cl &lt; len &amp;&amp; i &lt; crvs.length; i++){

		bezier_lengths[i] = bezier_lengths[i] != <span class="hljs-literal">undefined</span> ? 
			bezier_lengths[i] : verb.eval.rational_bezier_curve_arc_length( degree, knots, control_points ); 

		cl += bezier_lengths[i];

		<span class="hljs-keyword">if</span> (len &lt; cl + verb.EPSILON){
			<span class="hljs-keyword">return</span> verb.eval.rational_bezier_curve_param_at_arc_length(degree, knots, 
				control_points, len, tol, bezier_lengths[i]);
		}

	}
	
	<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;

}

verb.eval.rational_bezier_curve_param_at_arc_length = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(degree, knots, control_points, len, tol, total_len)</span></span>{

	<span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> knots[<span class="hljs-number">0</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-342">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-342">&#182;</a>
              </div>
              <p>we compute the whole length.  if desired length is outside of that, give up</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> totalLen = total_len || verb.eval.rational_bezier_curve_arc_length( degree, knots, control_points );

	<span class="hljs-keyword">if</span> (len &gt; totalLen) <span class="hljs-keyword">return</span> verb.last( knots );</pre></div></div>
            
        </li>
        
        
        <li id="section-343">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-343">&#182;</a>
              </div>
              <p>divide &amp; conquer
TODO: newton’s method formulation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> start = { p : knots[<span class="hljs-number">0</span>], l : <span class="hljs-number">0</span> }
		, end = { p : verb.last( knots ), l : totalLen }
		, mid = { p : <span class="hljs-number">0</span>, l : <span class="hljs-number">0</span> }
		, tol = tol || verb.TOLERANCE * <span class="hljs-number">2</span>;

	<span class="hljs-keyword">while</span> ( (end.l - start.l) &gt; tol ){

		mid.p = (start.p + end.p) / <span class="hljs-number">2</span>;
		mid.l = verb.eval.rational_bezier_curve_arc_length(degree, knots, control_points, mid.p );

		<span class="hljs-keyword">if</span> (mid.l &gt; len){
			end.p = mid.p;
			end.l = mid.l;
		} <span class="hljs-keyword">else</span> {
			start.p = mid.p;
			start.l = mid.l;
		}

	}

	<span class="hljs-keyword">return</span> (start.p + end.p) / <span class="hljs-number">2</span>;

}

verb.eval.rational_curve_arc_length = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(degree, knots, control_points, u)</span></span>{

	<span class="hljs-keyword">if</span> (u === <span class="hljs-literal">undefined</span>) u = verb.last( knots );

	<span class="hljs-keyword">var</span> crvs = verb.eval.curve_bezier_decompose( degree, knots, control_points )
		, i = <span class="hljs-number">0</span>
		, cc = crvs[i]
		, sum = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">while</span> ( cc &amp;&amp; cc.knots[<span class="hljs-number">0</span>] + verb.EPSILON &lt; u  ){
		sum += verb.eval.rational_bezier_curve_arc_length( cc.degree, cc.knots, cc.control_points, 
			<span class="hljs-built_in">Math</span>.min(verb.last(cc.knots), u) );
		
		cc = crvs[++i];
	}

	<span class="hljs-keyword">return</span> sum;
	
}

verb.eval.rational_bezier_curve_arc_length = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(degree, knots, control_points, u, gaussDegIncrease)</span> </span>{

  <span class="hljs-keyword">var</span> u = u === <span class="hljs-literal">undefined</span> ? verb.last(knots) : u
  	, z = (u - knots[<span class="hljs-number">0</span>]) / <span class="hljs-number">2</span>
  	, sum = <span class="hljs-number">0</span>
  	, gaussDeg = degree + ( gaussDegIncrease != <span class="hljs-literal">undefined</span> ? gaussDegIncrease : <span class="hljs-number">16</span>)
  	, i = <span class="hljs-number">0</span>
  	, cu
  	, tan;

  <span class="hljs-keyword">for</span>(; i &lt; gaussDeg; i++) {

    cu = z * verb.eval.Tvalues[gaussDeg][i] + z + knots[<span class="hljs-number">0</span>];
    tan = verb.eval.rational_curve_derivs( degree, knots, control_points, cu, <span class="hljs-number">1</span> );

    sum += verb.eval.Cvalues[gaussDeg][i] * numeric.norm2( tan[<span class="hljs-number">1</span>] );

  }

  <span class="hljs-keyword">return</span> z * sum;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-344">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-344">&#182;</a>
              </div>
              <p>Legendre-Gauss abscissae (xi values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.Tvalues = [
	[],
	[],
  [  -<span class="hljs-number">0.5773502691896257645091487805019574556476</span>,<span class="hljs-number">0.5773502691896257645091487805019574556476</span>],
  [<span class="hljs-number">0</span>,-<span class="hljs-number">0.7745966692414833770358530799564799221665</span>,<span class="hljs-number">0.7745966692414833770358530799564799221665</span>],
  [  -<span class="hljs-number">0.3399810435848562648026657591032446872005</span>,<span class="hljs-number">0.3399810435848562648026657591032446872005</span>,-<span class="hljs-number">0.8611363115940525752239464888928095050957</span>,<span class="hljs-number">0.8611363115940525752239464888928095050957</span>],
  [<span class="hljs-number">0</span>,-<span class="hljs-number">0.5384693101056830910363144207002088049672</span>,<span class="hljs-number">0.5384693101056830910363144207002088049672</span>,-<span class="hljs-number">0.9061798459386639927976268782993929651256</span>,<span class="hljs-number">0.9061798459386639927976268782993929651256</span>],
  [   <span class="hljs-number">0.6612093864662645136613995950199053470064</span>,-<span class="hljs-number">0.6612093864662645136613995950199053470064</span>,-<span class="hljs-number">0.2386191860831969086305017216807119354186</span>,<span class="hljs-number">0.2386191860831969086305017216807119354186</span>,-<span class="hljs-number">0.9324695142031520278123015544939946091347</span>,<span class="hljs-number">0.9324695142031520278123015544939946091347</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">0.4058451513773971669066064120769614633473</span>,-<span class="hljs-number">0.4058451513773971669066064120769614633473</span>,-<span class="hljs-number">0.7415311855993944398638647732807884070741</span>,<span class="hljs-number">0.7415311855993944398638647732807884070741</span>,-<span class="hljs-number">0.9491079123427585245261896840478512624007</span>,<span class="hljs-number">0.9491079123427585245261896840478512624007</span>],
  [  -<span class="hljs-number">0.1834346424956498049394761423601839806667</span>,<span class="hljs-number">0.1834346424956498049394761423601839806667</span>,-<span class="hljs-number">0.5255324099163289858177390491892463490419</span>,<span class="hljs-number">0.5255324099163289858177390491892463490419</span>,-<span class="hljs-number">0.7966664774136267395915539364758304368371</span>,<span class="hljs-number">0.7966664774136267395915539364758304368371</span>,-<span class="hljs-number">0.9602898564975362316835608685694729904282</span>,<span class="hljs-number">0.9602898564975362316835608685694729904282</span>],
  [<span class="hljs-number">0</span>,-<span class="hljs-number">0.8360311073266357942994297880697348765441</span>,<span class="hljs-number">0.8360311073266357942994297880697348765441</span>,-<span class="hljs-number">0.9681602395076260898355762029036728700494</span>,<span class="hljs-number">0.9681602395076260898355762029036728700494</span>,-<span class="hljs-number">0.3242534234038089290385380146433366085719</span>,<span class="hljs-number">0.3242534234038089290385380146433366085719</span>,-<span class="hljs-number">0.6133714327005903973087020393414741847857</span>,<span class="hljs-number">0.6133714327005903973087020393414741847857</span>],
  [  -<span class="hljs-number">0.1488743389816312108848260011297199846175</span>,<span class="hljs-number">0.1488743389816312108848260011297199846175</span>,-<span class="hljs-number">0.4333953941292471907992659431657841622000</span>,<span class="hljs-number">0.4333953941292471907992659431657841622000</span>,-<span class="hljs-number">0.6794095682990244062343273651148735757692</span>,<span class="hljs-number">0.6794095682990244062343273651148735757692</span>,-<span class="hljs-number">0.8650633666889845107320966884234930485275</span>,<span class="hljs-number">0.8650633666889845107320966884234930485275</span>,-<span class="hljs-number">0.9739065285171717200779640120844520534282</span>,<span class="hljs-number">0.9739065285171717200779640120844520534282</span>],
  [<span class="hljs-number">0</span>,-<span class="hljs-number">0.2695431559523449723315319854008615246796</span>,<span class="hljs-number">0.2695431559523449723315319854008615246796</span>,-<span class="hljs-number">0.5190961292068118159257256694586095544802</span>,<span class="hljs-number">0.5190961292068118159257256694586095544802</span>,-<span class="hljs-number">0.7301520055740493240934162520311534580496</span>,<span class="hljs-number">0.7301520055740493240934162520311534580496</span>,-<span class="hljs-number">0.8870625997680952990751577693039272666316</span>,<span class="hljs-number">0.8870625997680952990751577693039272666316</span>,-<span class="hljs-number">0.9782286581460569928039380011228573907714</span>,<span class="hljs-number">0.9782286581460569928039380011228573907714</span>],
  [  -<span class="hljs-number">0.1252334085114689154724413694638531299833</span>,<span class="hljs-number">0.1252334085114689154724413694638531299833</span>,-<span class="hljs-number">0.3678314989981801937526915366437175612563</span>,<span class="hljs-number">0.3678314989981801937526915366437175612563</span>,-<span class="hljs-number">0.5873179542866174472967024189405342803690</span>,<span class="hljs-number">0.5873179542866174472967024189405342803690</span>,-<span class="hljs-number">0.7699026741943046870368938332128180759849</span>,<span class="hljs-number">0.7699026741943046870368938332128180759849</span>,-<span class="hljs-number">0.9041172563704748566784658661190961925375</span>,<span class="hljs-number">0.9041172563704748566784658661190961925375</span>,-<span class="hljs-number">0.9815606342467192506905490901492808229601</span>,<span class="hljs-number">0.9815606342467192506905490901492808229601</span>],
  [<span class="hljs-number">0</span>,-<span class="hljs-number">0.2304583159551347940655281210979888352115</span>,<span class="hljs-number">0.2304583159551347940655281210979888352115</span>,-<span class="hljs-number">0.4484927510364468528779128521276398678019</span>,<span class="hljs-number">0.4484927510364468528779128521276398678019</span>,-<span class="hljs-number">0.6423493394403402206439846069955156500716</span>,<span class="hljs-number">0.6423493394403402206439846069955156500716</span>,-<span class="hljs-number">0.8015780907333099127942064895828598903056</span>,<span class="hljs-number">0.8015780907333099127942064895828598903056</span>,-<span class="hljs-number">0.9175983992229779652065478365007195123904</span>,<span class="hljs-number">0.9175983992229779652065478365007195123904</span>,-<span class="hljs-number">0.9841830547185881494728294488071096110649</span>,<span class="hljs-number">0.9841830547185881494728294488071096110649</span>],
  [  -<span class="hljs-number">0.1080549487073436620662446502198347476119</span>,<span class="hljs-number">0.1080549487073436620662446502198347476119</span>,-<span class="hljs-number">0.3191123689278897604356718241684754668342</span>,<span class="hljs-number">0.3191123689278897604356718241684754668342</span>,-<span class="hljs-number">0.5152486363581540919652907185511886623088</span>,<span class="hljs-number">0.5152486363581540919652907185511886623088</span>,-<span class="hljs-number">0.6872929048116854701480198030193341375384</span>,<span class="hljs-number">0.6872929048116854701480198030193341375384</span>,-<span class="hljs-number">0.8272013150697649931897947426503949610397</span>,<span class="hljs-number">0.8272013150697649931897947426503949610397</span>,-<span class="hljs-number">0.9284348836635735173363911393778742644770</span>,<span class="hljs-number">0.9284348836635735173363911393778742644770</span>,-<span class="hljs-number">0.9862838086968123388415972667040528016760</span>,<span class="hljs-number">0.9862838086968123388415972667040528016760</span>],
  [<span class="hljs-number">0</span>,-<span class="hljs-number">0.2011940939974345223006283033945962078128</span>,<span class="hljs-number">0.2011940939974345223006283033945962078128</span>,-<span class="hljs-number">0.3941513470775633698972073709810454683627</span>,<span class="hljs-number">0.3941513470775633698972073709810454683627</span>,-<span class="hljs-number">0.5709721726085388475372267372539106412383</span>,<span class="hljs-number">0.5709721726085388475372267372539106412383</span>,-<span class="hljs-number">0.7244177313601700474161860546139380096308</span>,<span class="hljs-number">0.7244177313601700474161860546139380096308</span>,-<span class="hljs-number">0.8482065834104272162006483207742168513662</span>,<span class="hljs-number">0.8482065834104272162006483207742168513662</span>,-<span class="hljs-number">0.9372733924007059043077589477102094712439</span>,<span class="hljs-number">0.9372733924007059043077589477102094712439</span>,-<span class="hljs-number">0.9879925180204854284895657185866125811469</span>,<span class="hljs-number">0.9879925180204854284895657185866125811469</span>],
  [  -<span class="hljs-number">0.0950125098376374401853193354249580631303</span>,<span class="hljs-number">0.0950125098376374401853193354249580631303</span>,-<span class="hljs-number">0.2816035507792589132304605014604961064860</span>,<span class="hljs-number">0.2816035507792589132304605014604961064860</span>,-<span class="hljs-number">0.4580167776572273863424194429835775735400</span>,<span class="hljs-number">0.4580167776572273863424194429835775735400</span>,-<span class="hljs-number">0.6178762444026437484466717640487910189918</span>,<span class="hljs-number">0.6178762444026437484466717640487910189918</span>,-<span class="hljs-number">0.7554044083550030338951011948474422683538</span>,<span class="hljs-number">0.7554044083550030338951011948474422683538</span>,-<span class="hljs-number">0.8656312023878317438804678977123931323873</span>,<span class="hljs-number">0.8656312023878317438804678977123931323873</span>,-<span class="hljs-number">0.9445750230732325760779884155346083450911</span>,<span class="hljs-number">0.9445750230732325760779884155346083450911</span>,-<span class="hljs-number">0.9894009349916499325961541734503326274262</span>,<span class="hljs-number">0.9894009349916499325961541734503326274262</span>],
  [<span class="hljs-number">0</span>,-<span class="hljs-number">0.1784841814958478558506774936540655574754</span>,<span class="hljs-number">0.1784841814958478558506774936540655574754</span>,-<span class="hljs-number">0.3512317634538763152971855170953460050405</span>,<span class="hljs-number">0.3512317634538763152971855170953460050405</span>,-<span class="hljs-number">0.5126905370864769678862465686295518745829</span>,<span class="hljs-number">0.5126905370864769678862465686295518745829</span>,-<span class="hljs-number">0.6576711592166907658503022166430023351478</span>,<span class="hljs-number">0.6576711592166907658503022166430023351478</span>,-<span class="hljs-number">0.7815140038968014069252300555204760502239</span>,<span class="hljs-number">0.7815140038968014069252300555204760502239</span>,-<span class="hljs-number">0.8802391537269859021229556944881556926234</span>,<span class="hljs-number">0.8802391537269859021229556944881556926234</span>,-<span class="hljs-number">0.9506755217687677612227169578958030214433</span>,<span class="hljs-number">0.9506755217687677612227169578958030214433</span>,-<span class="hljs-number">0.9905754753144173356754340199406652765077</span>,<span class="hljs-number">0.9905754753144173356754340199406652765077</span>],
  [  -<span class="hljs-number">0.0847750130417353012422618529357838117333</span>,<span class="hljs-number">0.0847750130417353012422618529357838117333</span>,-<span class="hljs-number">0.2518862256915055095889728548779112301628</span>,<span class="hljs-number">0.2518862256915055095889728548779112301628</span>,-<span class="hljs-number">0.4117511614628426460359317938330516370789</span>,<span class="hljs-number">0.4117511614628426460359317938330516370789</span>,-<span class="hljs-number">0.5597708310739475346078715485253291369276</span>,<span class="hljs-number">0.5597708310739475346078715485253291369276</span>,-<span class="hljs-number">0.6916870430603532078748910812888483894522</span>,<span class="hljs-number">0.6916870430603532078748910812888483894522</span>,-<span class="hljs-number">0.8037049589725231156824174550145907971032</span>,<span class="hljs-number">0.8037049589725231156824174550145907971032</span>,-<span class="hljs-number">0.8926024664975557392060605911271455154078</span>,<span class="hljs-number">0.8926024664975557392060605911271455154078</span>,-<span class="hljs-number">0.9558239495713977551811958929297763099728</span>,<span class="hljs-number">0.9558239495713977551811958929297763099728</span>,-<span class="hljs-number">0.9915651684209309467300160047061507702525</span>,<span class="hljs-number">0.9915651684209309467300160047061507702525</span>],
  [<span class="hljs-number">0</span>,-<span class="hljs-number">0.1603586456402253758680961157407435495048</span>,<span class="hljs-number">0.1603586456402253758680961157407435495048</span>,-<span class="hljs-number">0.3165640999636298319901173288498449178922</span>,<span class="hljs-number">0.3165640999636298319901173288498449178922</span>,-<span class="hljs-number">0.4645707413759609457172671481041023679762</span>,<span class="hljs-number">0.4645707413759609457172671481041023679762</span>,-<span class="hljs-number">0.6005453046616810234696381649462392798683</span>,<span class="hljs-number">0.6005453046616810234696381649462392798683</span>,-<span class="hljs-number">0.7209661773352293786170958608237816296571</span>,<span class="hljs-number">0.7209661773352293786170958608237816296571</span>,-<span class="hljs-number">0.8227146565371428249789224867127139017745</span>,<span class="hljs-number">0.8227146565371428249789224867127139017745</span>,-<span class="hljs-number">0.9031559036148179016426609285323124878093</span>,<span class="hljs-number">0.9031559036148179016426609285323124878093</span>,-<span class="hljs-number">0.9602081521348300308527788406876515266150</span>,<span class="hljs-number">0.9602081521348300308527788406876515266150</span>,-<span class="hljs-number">0.9924068438435844031890176702532604935893</span>,<span class="hljs-number">0.9924068438435844031890176702532604935893</span>],
  [  -<span class="hljs-number">0.0765265211334973337546404093988382110047</span>,<span class="hljs-number">0.0765265211334973337546404093988382110047</span>,-<span class="hljs-number">0.2277858511416450780804961953685746247430</span>,<span class="hljs-number">0.2277858511416450780804961953685746247430</span>,-<span class="hljs-number">0.3737060887154195606725481770249272373957</span>,<span class="hljs-number">0.3737060887154195606725481770249272373957</span>,-<span class="hljs-number">0.5108670019508270980043640509552509984254</span>,<span class="hljs-number">0.5108670019508270980043640509552509984254</span>,-<span class="hljs-number">0.6360536807265150254528366962262859367433</span>,<span class="hljs-number">0.6360536807265150254528366962262859367433</span>,-<span class="hljs-number">0.7463319064601507926143050703556415903107</span>,<span class="hljs-number">0.7463319064601507926143050703556415903107</span>,-<span class="hljs-number">0.8391169718222188233945290617015206853296</span>,<span class="hljs-number">0.8391169718222188233945290617015206853296</span>,-<span class="hljs-number">0.9122344282513259058677524412032981130491</span>,<span class="hljs-number">0.9122344282513259058677524412032981130491</span>,-<span class="hljs-number">0.9639719272779137912676661311972772219120</span>,<span class="hljs-number">0.9639719272779137912676661311972772219120</span>,-<span class="hljs-number">0.9931285991850949247861223884713202782226</span>,<span class="hljs-number">0.9931285991850949247861223884713202782226</span>],
  [<span class="hljs-number">0</span>,-<span class="hljs-number">0.1455618541608950909370309823386863301163</span>,<span class="hljs-number">0.1455618541608950909370309823386863301163</span>,-<span class="hljs-number">0.2880213168024010966007925160646003199090</span>,<span class="hljs-number">0.2880213168024010966007925160646003199090</span>,-<span class="hljs-number">0.4243421202074387835736688885437880520964</span>,<span class="hljs-number">0.4243421202074387835736688885437880520964</span>,-<span class="hljs-number">0.5516188358872198070590187967243132866220</span>,<span class="hljs-number">0.5516188358872198070590187967243132866220</span>,-<span class="hljs-number">0.6671388041974123193059666699903391625970</span>,<span class="hljs-number">0.6671388041974123193059666699903391625970</span>,-<span class="hljs-number">0.7684399634756779086158778513062280348209</span>,<span class="hljs-number">0.7684399634756779086158778513062280348209</span>,-<span class="hljs-number">0.8533633645833172836472506385875676702761</span>,<span class="hljs-number">0.8533633645833172836472506385875676702761</span>,-<span class="hljs-number">0.9200993341504008287901871337149688941591</span>,<span class="hljs-number">0.9200993341504008287901871337149688941591</span>,-<span class="hljs-number">0.9672268385663062943166222149076951614246</span>,<span class="hljs-number">0.9672268385663062943166222149076951614246</span>,-<span class="hljs-number">0.9937521706203895002602420359379409291933</span>,<span class="hljs-number">0.9937521706203895002602420359379409291933</span>],
  [  -<span class="hljs-number">0.0697392733197222212138417961186280818222</span>,<span class="hljs-number">0.0697392733197222212138417961186280818222</span>,-<span class="hljs-number">0.2078604266882212854788465339195457342156</span>,<span class="hljs-number">0.2078604266882212854788465339195457342156</span>,-<span class="hljs-number">0.3419358208920842251581474204273796195591</span>,<span class="hljs-number">0.3419358208920842251581474204273796195591</span>,-<span class="hljs-number">0.4693558379867570264063307109664063460953</span>,<span class="hljs-number">0.4693558379867570264063307109664063460953</span>,-<span class="hljs-number">0.5876404035069115929588769276386473488776</span>,<span class="hljs-number">0.5876404035069115929588769276386473488776</span>,-<span class="hljs-number">0.6944872631866827800506898357622567712673</span>,<span class="hljs-number">0.6944872631866827800506898357622567712673</span>,-<span class="hljs-number">0.7878168059792081620042779554083515213881</span>,<span class="hljs-number">0.7878168059792081620042779554083515213881</span>,-<span class="hljs-number">0.8658125777203001365364256370193787290847</span>,<span class="hljs-number">0.8658125777203001365364256370193787290847</span>,-<span class="hljs-number">0.9269567721871740005206929392590531966353</span>,<span class="hljs-number">0.9269567721871740005206929392590531966353</span>,-<span class="hljs-number">0.9700604978354287271239509867652687108059</span>,<span class="hljs-number">0.9700604978354287271239509867652687108059</span>,-<span class="hljs-number">0.9942945854823992920730314211612989803930</span>,<span class="hljs-number">0.9942945854823992920730314211612989803930</span>],
  [<span class="hljs-number">0</span>,-<span class="hljs-number">0.1332568242984661109317426822417661370104</span>,<span class="hljs-number">0.1332568242984661109317426822417661370104</span>,-<span class="hljs-number">0.2641356809703449305338695382833096029790</span>,<span class="hljs-number">0.2641356809703449305338695382833096029790</span>,-<span class="hljs-number">0.3903010380302908314214888728806054585780</span>,<span class="hljs-number">0.3903010380302908314214888728806054585780</span>,-<span class="hljs-number">0.5095014778460075496897930478668464305448</span>,<span class="hljs-number">0.5095014778460075496897930478668464305448</span>,-<span class="hljs-number">0.6196098757636461563850973116495956533871</span>,<span class="hljs-number">0.6196098757636461563850973116495956533871</span>,-<span class="hljs-number">0.7186613631319501944616244837486188483299</span>,<span class="hljs-number">0.7186613631319501944616244837486188483299</span>,-<span class="hljs-number">0.8048884016188398921511184069967785579414</span>,<span class="hljs-number">0.8048884016188398921511184069967785579414</span>,-<span class="hljs-number">0.8767523582704416673781568859341456716389</span>,<span class="hljs-number">0.8767523582704416673781568859341456716389</span>,-<span class="hljs-number">0.9329710868260161023491969890384229782357</span>,<span class="hljs-number">0.9329710868260161023491969890384229782357</span>,-<span class="hljs-number">0.9725424712181152319560240768207773751816</span>,<span class="hljs-number">0.9725424712181152319560240768207773751816</span>,-<span class="hljs-number">0.9947693349975521235239257154455743605736</span>,<span class="hljs-number">0.9947693349975521235239257154455743605736</span>],
  [  -<span class="hljs-number">0.0640568928626056260850430826247450385909</span>,<span class="hljs-number">0.0640568928626056260850430826247450385909</span>,-<span class="hljs-number">0.1911188674736163091586398207570696318404</span>,<span class="hljs-number">0.1911188674736163091586398207570696318404</span>,-<span class="hljs-number">0.3150426796961633743867932913198102407864</span>,<span class="hljs-number">0.3150426796961633743867932913198102407864</span>,-<span class="hljs-number">0.4337935076260451384870842319133497124524</span>,<span class="hljs-number">0.4337935076260451384870842319133497124524</span>,-<span class="hljs-number">0.5454214713888395356583756172183723700107</span>,<span class="hljs-number">0.5454214713888395356583756172183723700107</span>,-<span class="hljs-number">0.6480936519369755692524957869107476266696</span>,<span class="hljs-number">0.6480936519369755692524957869107476266696</span>,-<span class="hljs-number">0.7401241915785543642438281030999784255232</span>,<span class="hljs-number">0.7401241915785543642438281030999784255232</span>,-<span class="hljs-number">0.8200019859739029219539498726697452080761</span>,<span class="hljs-number">0.8200019859739029219539498726697452080761</span>,-<span class="hljs-number">0.8864155270044010342131543419821967550873</span>,<span class="hljs-number">0.8864155270044010342131543419821967550873</span>,-<span class="hljs-number">0.9382745520027327585236490017087214496548</span>,<span class="hljs-number">0.9382745520027327585236490017087214496548</span>,-<span class="hljs-number">0.9747285559713094981983919930081690617411</span>,<span class="hljs-number">0.9747285559713094981983919930081690617411</span>,-<span class="hljs-number">0.9951872199970213601799974097007368118745</span>,<span class="hljs-number">0.9951872199970213601799974097007368118745</span>]
];</pre></div></div>
            
        </li>
        
        
        <li id="section-345">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-345">&#182;</a>
              </div>
              <p>Legendre-Gauss weights (wi values, defined by a function linked to in the Bezier primer article)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.Cvalues = [[],[],
  [<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>],
  [<span class="hljs-number">0.8888888888888888888888888888888888888888</span>,<span class="hljs-number">0.5555555555555555555555555555555555555555</span>,<span class="hljs-number">0.5555555555555555555555555555555555555555</span>],
  [<span class="hljs-number">0.6521451548625461426269360507780005927646</span>,<span class="hljs-number">0.6521451548625461426269360507780005927646</span>,<span class="hljs-number">0.3478548451374538573730639492219994072353</span>,<span class="hljs-number">0.3478548451374538573730639492219994072353</span>],
  [<span class="hljs-number">0.5688888888888888888888888888888888888888</span>,<span class="hljs-number">0.4786286704993664680412915148356381929122</span>,<span class="hljs-number">0.4786286704993664680412915148356381929122</span>,<span class="hljs-number">0.2369268850561890875142640407199173626432</span>,<span class="hljs-number">0.2369268850561890875142640407199173626432</span>],
  [<span class="hljs-number">0.3607615730481386075698335138377161116615</span>,<span class="hljs-number">0.3607615730481386075698335138377161116615</span>,<span class="hljs-number">0.4679139345726910473898703439895509948116</span>,<span class="hljs-number">0.4679139345726910473898703439895509948116</span>,<span class="hljs-number">0.1713244923791703450402961421727328935268</span>,<span class="hljs-number">0.1713244923791703450402961421727328935268</span>],
  [<span class="hljs-number">0.4179591836734693877551020408163265306122</span>,<span class="hljs-number">0.3818300505051189449503697754889751338783</span>,<span class="hljs-number">0.3818300505051189449503697754889751338783</span>,<span class="hljs-number">0.2797053914892766679014677714237795824869</span>,<span class="hljs-number">0.2797053914892766679014677714237795824869</span>,<span class="hljs-number">0.1294849661688696932706114326790820183285</span>,<span class="hljs-number">0.1294849661688696932706114326790820183285</span>],
  [<span class="hljs-number">0.3626837833783619829651504492771956121941</span>,<span class="hljs-number">0.3626837833783619829651504492771956121941</span>,<span class="hljs-number">0.3137066458778872873379622019866013132603</span>,<span class="hljs-number">0.3137066458778872873379622019866013132603</span>,<span class="hljs-number">0.2223810344533744705443559944262408844301</span>,<span class="hljs-number">0.2223810344533744705443559944262408844301</span>,<span class="hljs-number">0.1012285362903762591525313543099621901153</span>,<span class="hljs-number">0.1012285362903762591525313543099621901153</span>],
  [<span class="hljs-number">0.3302393550012597631645250692869740488788</span>,<span class="hljs-number">0.1806481606948574040584720312429128095143</span>,<span class="hljs-number">0.1806481606948574040584720312429128095143</span>,<span class="hljs-number">0.0812743883615744119718921581105236506756</span>,<span class="hljs-number">0.0812743883615744119718921581105236506756</span>,<span class="hljs-number">0.3123470770400028400686304065844436655987</span>,<span class="hljs-number">0.3123470770400028400686304065844436655987</span>,<span class="hljs-number">0.2606106964029354623187428694186328497718</span>,<span class="hljs-number">0.2606106964029354623187428694186328497718</span>],
  [<span class="hljs-number">0.2955242247147528701738929946513383294210</span>,<span class="hljs-number">0.2955242247147528701738929946513383294210</span>,<span class="hljs-number">0.2692667193099963550912269215694693528597</span>,<span class="hljs-number">0.2692667193099963550912269215694693528597</span>,<span class="hljs-number">0.2190863625159820439955349342281631924587</span>,<span class="hljs-number">0.2190863625159820439955349342281631924587</span>,<span class="hljs-number">0.1494513491505805931457763396576973324025</span>,<span class="hljs-number">0.1494513491505805931457763396576973324025</span>,<span class="hljs-number">0.0666713443086881375935688098933317928578</span>,<span class="hljs-number">0.0666713443086881375935688098933317928578</span>],
  [<span class="hljs-number">0.2729250867779006307144835283363421891560</span>,<span class="hljs-number">0.2628045445102466621806888698905091953727</span>,<span class="hljs-number">0.2628045445102466621806888698905091953727</span>,<span class="hljs-number">0.2331937645919904799185237048431751394317</span>,<span class="hljs-number">0.2331937645919904799185237048431751394317</span>,<span class="hljs-number">0.1862902109277342514260976414316558916912</span>,<span class="hljs-number">0.1862902109277342514260976414316558916912</span>,<span class="hljs-number">0.1255803694649046246346942992239401001976</span>,<span class="hljs-number">0.1255803694649046246346942992239401001976</span>,<span class="hljs-number">0.0556685671161736664827537204425485787285</span>,<span class="hljs-number">0.0556685671161736664827537204425485787285</span>],
  [<span class="hljs-number">0.2491470458134027850005624360429512108304</span>,<span class="hljs-number">0.2491470458134027850005624360429512108304</span>,<span class="hljs-number">0.2334925365383548087608498989248780562594</span>,<span class="hljs-number">0.2334925365383548087608498989248780562594</span>,<span class="hljs-number">0.2031674267230659217490644558097983765065</span>,<span class="hljs-number">0.2031674267230659217490644558097983765065</span>,<span class="hljs-number">0.1600783285433462263346525295433590718720</span>,<span class="hljs-number">0.1600783285433462263346525295433590718720</span>,<span class="hljs-number">0.1069393259953184309602547181939962242145</span>,<span class="hljs-number">0.1069393259953184309602547181939962242145</span>,<span class="hljs-number">0.0471753363865118271946159614850170603170</span>,<span class="hljs-number">0.0471753363865118271946159614850170603170</span>],
  [<span class="hljs-number">0.2325515532308739101945895152688359481566</span>,<span class="hljs-number">0.2262831802628972384120901860397766184347</span>,<span class="hljs-number">0.2262831802628972384120901860397766184347</span>,<span class="hljs-number">0.2078160475368885023125232193060527633865</span>,<span class="hljs-number">0.2078160475368885023125232193060527633865</span>,<span class="hljs-number">0.1781459807619457382800466919960979955128</span>,<span class="hljs-number">0.1781459807619457382800466919960979955128</span>,<span class="hljs-number">0.1388735102197872384636017768688714676218</span>,<span class="hljs-number">0.1388735102197872384636017768688714676218</span>,<span class="hljs-number">0.0921214998377284479144217759537971209236</span>,<span class="hljs-number">0.0921214998377284479144217759537971209236</span>,<span class="hljs-number">0.0404840047653158795200215922009860600419</span>,<span class="hljs-number">0.0404840047653158795200215922009860600419</span>],
  [<span class="hljs-number">0.2152638534631577901958764433162600352749</span>,<span class="hljs-number">0.2152638534631577901958764433162600352749</span>,<span class="hljs-number">0.2051984637212956039659240656612180557103</span>,<span class="hljs-number">0.2051984637212956039659240656612180557103</span>,<span class="hljs-number">0.1855383974779378137417165901251570362489</span>,<span class="hljs-number">0.1855383974779378137417165901251570362489</span>,<span class="hljs-number">0.1572031671581935345696019386238421566056</span>,<span class="hljs-number">0.1572031671581935345696019386238421566056</span>,<span class="hljs-number">0.1215185706879031846894148090724766259566</span>,<span class="hljs-number">0.1215185706879031846894148090724766259566</span>,<span class="hljs-number">0.0801580871597602098056332770628543095836</span>,<span class="hljs-number">0.0801580871597602098056332770628543095836</span>,<span class="hljs-number">0.0351194603317518630318328761381917806197</span>,<span class="hljs-number">0.0351194603317518630318328761381917806197</span>],
  [<span class="hljs-number">0.2025782419255612728806201999675193148386</span>,<span class="hljs-number">0.1984314853271115764561183264438393248186</span>,<span class="hljs-number">0.1984314853271115764561183264438393248186</span>,<span class="hljs-number">0.1861610000155622110268005618664228245062</span>,<span class="hljs-number">0.1861610000155622110268005618664228245062</span>,<span class="hljs-number">0.1662692058169939335532008604812088111309</span>,<span class="hljs-number">0.1662692058169939335532008604812088111309</span>,<span class="hljs-number">0.1395706779261543144478047945110283225208</span>,<span class="hljs-number">0.1395706779261543144478047945110283225208</span>,<span class="hljs-number">0.1071592204671719350118695466858693034155</span>,<span class="hljs-number">0.1071592204671719350118695466858693034155</span>,<span class="hljs-number">0.0703660474881081247092674164506673384667</span>,<span class="hljs-number">0.0703660474881081247092674164506673384667</span>,<span class="hljs-number">0.0307532419961172683546283935772044177217</span>,<span class="hljs-number">0.0307532419961172683546283935772044177217</span>],
  [<span class="hljs-number">0.1894506104550684962853967232082831051469</span>,<span class="hljs-number">0.1894506104550684962853967232082831051469</span>,<span class="hljs-number">0.1826034150449235888667636679692199393835</span>,<span class="hljs-number">0.1826034150449235888667636679692199393835</span>,<span class="hljs-number">0.1691565193950025381893120790303599622116</span>,<span class="hljs-number">0.1691565193950025381893120790303599622116</span>,<span class="hljs-number">0.1495959888165767320815017305474785489704</span>,<span class="hljs-number">0.1495959888165767320815017305474785489704</span>,<span class="hljs-number">0.1246289712555338720524762821920164201448</span>,<span class="hljs-number">0.1246289712555338720524762821920164201448</span>,<span class="hljs-number">0.0951585116824927848099251076022462263552</span>,<span class="hljs-number">0.0951585116824927848099251076022462263552</span>,<span class="hljs-number">0.0622535239386478928628438369943776942749</span>,<span class="hljs-number">0.0622535239386478928628438369943776942749</span>,<span class="hljs-number">0.0271524594117540948517805724560181035122</span>,<span class="hljs-number">0.0271524594117540948517805724560181035122</span>],
  [<span class="hljs-number">0.1794464703562065254582656442618856214487</span>,<span class="hljs-number">0.1765627053669926463252709901131972391509</span>,<span class="hljs-number">0.1765627053669926463252709901131972391509</span>,<span class="hljs-number">0.1680041021564500445099706637883231550211</span>,<span class="hljs-number">0.1680041021564500445099706637883231550211</span>,<span class="hljs-number">0.1540457610768102880814315948019586119404</span>,<span class="hljs-number">0.1540457610768102880814315948019586119404</span>,<span class="hljs-number">0.1351363684685254732863199817023501973721</span>,<span class="hljs-number">0.1351363684685254732863199817023501973721</span>,<span class="hljs-number">0.1118838471934039710947883856263559267358</span>,<span class="hljs-number">0.1118838471934039710947883856263559267358</span>,<span class="hljs-number">0.0850361483171791808835353701910620738504</span>,<span class="hljs-number">0.0850361483171791808835353701910620738504</span>,<span class="hljs-number">0.0554595293739872011294401653582446605128</span>,<span class="hljs-number">0.0554595293739872011294401653582446605128</span>,<span class="hljs-number">0.0241483028685479319601100262875653246916</span>,<span class="hljs-number">0.0241483028685479319601100262875653246916</span>],
  [<span class="hljs-number">0.1691423829631435918406564701349866103341</span>,<span class="hljs-number">0.1691423829631435918406564701349866103341</span>,<span class="hljs-number">0.1642764837458327229860537764659275904123</span>,<span class="hljs-number">0.1642764837458327229860537764659275904123</span>,<span class="hljs-number">0.1546846751262652449254180038363747721932</span>,<span class="hljs-number">0.1546846751262652449254180038363747721932</span>,<span class="hljs-number">0.1406429146706506512047313037519472280955</span>,<span class="hljs-number">0.1406429146706506512047313037519472280955</span>,<span class="hljs-number">0.1225552067114784601845191268002015552281</span>,<span class="hljs-number">0.1225552067114784601845191268002015552281</span>,<span class="hljs-number">0.1009420441062871655628139849248346070628</span>,<span class="hljs-number">0.1009420441062871655628139849248346070628</span>,<span class="hljs-number">0.0764257302548890565291296776166365256053</span>,<span class="hljs-number">0.0764257302548890565291296776166365256053</span>,<span class="hljs-number">0.0497145488949697964533349462026386416808</span>,<span class="hljs-number">0.0497145488949697964533349462026386416808</span>,<span class="hljs-number">0.0216160135264833103133427102664524693876</span>,<span class="hljs-number">0.0216160135264833103133427102664524693876</span>],
  [<span class="hljs-number">0.1610544498487836959791636253209167350399</span>,<span class="hljs-number">0.1589688433939543476499564394650472016787</span>,<span class="hljs-number">0.1589688433939543476499564394650472016787</span>,<span class="hljs-number">0.1527660420658596667788554008976629984610</span>,<span class="hljs-number">0.1527660420658596667788554008976629984610</span>,<span class="hljs-number">0.1426067021736066117757461094419029724756</span>,<span class="hljs-number">0.1426067021736066117757461094419029724756</span>,<span class="hljs-number">0.1287539625393362276755157848568771170558</span>,<span class="hljs-number">0.1287539625393362276755157848568771170558</span>,<span class="hljs-number">0.1115666455473339947160239016817659974813</span>,<span class="hljs-number">0.1115666455473339947160239016817659974813</span>,<span class="hljs-number">0.0914900216224499994644620941238396526609</span>,<span class="hljs-number">0.0914900216224499994644620941238396526609</span>,<span class="hljs-number">0.0690445427376412265807082580060130449618</span>,<span class="hljs-number">0.0690445427376412265807082580060130449618</span>,<span class="hljs-number">0.0448142267656996003328381574019942119517</span>,<span class="hljs-number">0.0448142267656996003328381574019942119517</span>,<span class="hljs-number">0.0194617882297264770363120414644384357529</span>,<span class="hljs-number">0.0194617882297264770363120414644384357529</span>],
  [<span class="hljs-number">0.1527533871307258506980843319550975934919</span>,<span class="hljs-number">0.1527533871307258506980843319550975934919</span>,<span class="hljs-number">0.1491729864726037467878287370019694366926</span>,<span class="hljs-number">0.1491729864726037467878287370019694366926</span>,<span class="hljs-number">0.1420961093183820513292983250671649330345</span>,<span class="hljs-number">0.1420961093183820513292983250671649330345</span>,<span class="hljs-number">0.1316886384491766268984944997481631349161</span>,<span class="hljs-number">0.1316886384491766268984944997481631349161</span>,<span class="hljs-number">0.1181945319615184173123773777113822870050</span>,<span class="hljs-number">0.1181945319615184173123773777113822870050</span>,<span class="hljs-number">0.1019301198172404350367501354803498761666</span>,<span class="hljs-number">0.1019301198172404350367501354803498761666</span>,<span class="hljs-number">0.0832767415767047487247581432220462061001</span>,<span class="hljs-number">0.0832767415767047487247581432220462061001</span>,<span class="hljs-number">0.0626720483341090635695065351870416063516</span>,<span class="hljs-number">0.0626720483341090635695065351870416063516</span>,<span class="hljs-number">0.0406014298003869413310399522749321098790</span>,<span class="hljs-number">0.0406014298003869413310399522749321098790</span>,<span class="hljs-number">0.0176140071391521183118619623518528163621</span>,<span class="hljs-number">0.0176140071391521183118619623518528163621</span>],
  [<span class="hljs-number">0.1460811336496904271919851476833711882448</span>,<span class="hljs-number">0.1445244039899700590638271665537525436099</span>,<span class="hljs-number">0.1445244039899700590638271665537525436099</span>,<span class="hljs-number">0.1398873947910731547221334238675831108927</span>,<span class="hljs-number">0.1398873947910731547221334238675831108927</span>,<span class="hljs-number">0.1322689386333374617810525744967756043290</span>,<span class="hljs-number">0.1322689386333374617810525744967756043290</span>,<span class="hljs-number">0.1218314160537285341953671771257335983563</span>,<span class="hljs-number">0.1218314160537285341953671771257335983563</span>,<span class="hljs-number">0.1087972991671483776634745780701056420336</span>,<span class="hljs-number">0.1087972991671483776634745780701056420336</span>,<span class="hljs-number">0.0934444234560338615532897411139320884835</span>,<span class="hljs-number">0.0934444234560338615532897411139320884835</span>,<span class="hljs-number">0.0761001136283793020170516533001831792261</span>,<span class="hljs-number">0.0761001136283793020170516533001831792261</span>,<span class="hljs-number">0.0571344254268572082836358264724479574912</span>,<span class="hljs-number">0.0571344254268572082836358264724479574912</span>,<span class="hljs-number">0.0369537897708524937999506682993296661889</span>,<span class="hljs-number">0.0369537897708524937999506682993296661889</span>,<span class="hljs-number">0.0160172282577743333242246168584710152658</span>,<span class="hljs-number">0.0160172282577743333242246168584710152658</span>],
  [<span class="hljs-number">0.1392518728556319933754102483418099578739</span>,<span class="hljs-number">0.1392518728556319933754102483418099578739</span>,<span class="hljs-number">0.1365414983460151713525738312315173965863</span>,<span class="hljs-number">0.1365414983460151713525738312315173965863</span>,<span class="hljs-number">0.1311735047870623707329649925303074458757</span>,<span class="hljs-number">0.1311735047870623707329649925303074458757</span>,<span class="hljs-number">0.1232523768105124242855609861548144719594</span>,<span class="hljs-number">0.1232523768105124242855609861548144719594</span>,<span class="hljs-number">0.1129322960805392183934006074217843191142</span>,<span class="hljs-number">0.1129322960805392183934006074217843191142</span>,<span class="hljs-number">0.1004141444428809649320788378305362823508</span>,<span class="hljs-number">0.1004141444428809649320788378305362823508</span>,<span class="hljs-number">0.0859416062170677274144436813727028661891</span>,<span class="hljs-number">0.0859416062170677274144436813727028661891</span>,<span class="hljs-number">0.0697964684245204880949614189302176573987</span>,<span class="hljs-number">0.0697964684245204880949614189302176573987</span>,<span class="hljs-number">0.0522933351526832859403120512732112561121</span>,<span class="hljs-number">0.0522933351526832859403120512732112561121</span>,<span class="hljs-number">0.0337749015848141547933022468659129013491</span>,<span class="hljs-number">0.0337749015848141547933022468659129013491</span>,<span class="hljs-number">0.0146279952982722006849910980471854451902</span>,<span class="hljs-number">0.0146279952982722006849910980471854451902</span>],
  [<span class="hljs-number">0.1336545721861061753514571105458443385831</span>,<span class="hljs-number">0.1324620394046966173716424647033169258050</span>,<span class="hljs-number">0.1324620394046966173716424647033169258050</span>,<span class="hljs-number">0.1289057221880821499785953393997936532597</span>,<span class="hljs-number">0.1289057221880821499785953393997936532597</span>,<span class="hljs-number">0.1230490843067295304675784006720096548158</span>,<span class="hljs-number">0.1230490843067295304675784006720096548158</span>,<span class="hljs-number">0.1149966402224113649416435129339613014914</span>,<span class="hljs-number">0.1149966402224113649416435129339613014914</span>,<span class="hljs-number">0.1048920914645414100740861850147438548584</span>,<span class="hljs-number">0.1048920914645414100740861850147438548584</span>,<span class="hljs-number">0.0929157660600351474770186173697646486034</span>,<span class="hljs-number">0.0929157660600351474770186173697646486034</span>,<span class="hljs-number">0.0792814117767189549228925247420432269137</span>,<span class="hljs-number">0.0792814117767189549228925247420432269137</span>,<span class="hljs-number">0.0642324214085258521271696151589109980391</span>,<span class="hljs-number">0.0642324214085258521271696151589109980391</span>,<span class="hljs-number">0.0480376717310846685716410716320339965612</span>,<span class="hljs-number">0.0480376717310846685716410716320339965612</span>,<span class="hljs-number">0.0309880058569794443106942196418845053837</span>,<span class="hljs-number">0.0309880058569794443106942196418845053837</span>,<span class="hljs-number">0.0134118594871417720813094934586150649766</span>,<span class="hljs-number">0.0134118594871417720813094934586150649766</span>],
  [<span class="hljs-number">0.1279381953467521569740561652246953718517</span>,<span class="hljs-number">0.1279381953467521569740561652246953718517</span>,<span class="hljs-number">0.1258374563468282961213753825111836887264</span>,<span class="hljs-number">0.1258374563468282961213753825111836887264</span>,<span class="hljs-number">0.1216704729278033912044631534762624256070</span>,<span class="hljs-number">0.1216704729278033912044631534762624256070</span>,<span class="hljs-number">0.1155056680537256013533444839067835598622</span>,<span class="hljs-number">0.1155056680537256013533444839067835598622</span>,<span class="hljs-number">0.1074442701159656347825773424466062227946</span>,<span class="hljs-number">0.1074442701159656347825773424466062227946</span>,<span class="hljs-number">0.0976186521041138882698806644642471544279</span>,<span class="hljs-number">0.0976186521041138882698806644642471544279</span>,<span class="hljs-number">0.0861901615319532759171852029837426671850</span>,<span class="hljs-number">0.0861901615319532759171852029837426671850</span>,<span class="hljs-number">0.0733464814110803057340336152531165181193</span>,<span class="hljs-number">0.0733464814110803057340336152531165181193</span>,<span class="hljs-number">0.0592985849154367807463677585001085845412</span>,<span class="hljs-number">0.0592985849154367807463677585001085845412</span>,<span class="hljs-number">0.0442774388174198061686027482113382288593</span>,<span class="hljs-number">0.0442774388174198061686027482113382288593</span>,<span class="hljs-number">0.0285313886289336631813078159518782864491</span>,<span class="hljs-number">0.0285313886289336631813078159518782864491</span>,<span class="hljs-number">0.0123412297999871995468056670700372915759</span>,<span class="hljs-number">0.0123412297999871995468056670700372915759</span>]
];

verb.eval.rational_interp_curve = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points, degree, start_tangent, end_tangent )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-346">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-346">&#182;</a>
              </div>
              <p>0) build knot vector for curve by normalized chord length
1) construct effective basis function in square matrix (W)
2) construct set of coordinattes to interpolate vector (p)
3) set of control points (c)</p>

            </div>
            
        </li>
        
        
        <li id="section-347">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-347">&#182;</a>
              </div>
              <p>Wc = p</p>

            </div>
            
        </li>
        
        
        <li id="section-348">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-348">&#182;</a>
              </div>
              <p>4) solve for c in all 3 dimensions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	degree = degree || <span class="hljs-number">3</span>;

	<span class="hljs-keyword">if</span> (points.length &lt; degree + <span class="hljs-number">1</span>){
		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"You need to supply at least degree + 1 points!"</span>)
	}
	
	<span class="hljs-keyword">var</span> us = [ <span class="hljs-number">0</span> ]; 
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; points.length; i++){

		<span class="hljs-keyword">var</span> chord = numeric.norm2( numeric.sub( points[i], points[i-<span class="hljs-number">1</span>] ) );
		<span class="hljs-keyword">var</span> last = us[us.length - <span class="hljs-number">1</span>];
		us.push( last + chord );

	}</pre></div></div>
            
        </li>
        
        
        <li id="section-349">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-349">&#182;</a>
              </div>
              <p>normalize</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> max = us[us.length-<span class="hljs-number">1</span>];
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; us.length; i++){
		us[i] = us[i] / max;
	}

	<span class="hljs-keyword">var</span> knotsStart = numeric.rep( [ degree + <span class="hljs-number">1</span> ], <span class="hljs-number">0</span> );</pre></div></div>
            
        </li>
        
        
        <li id="section-350">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-350">&#182;</a>
              </div>
              <p>we need two more control points, two more knots</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">var</span> hasTangents = start_tangent != <span class="hljs-literal">undefined</span> &amp;&amp; end_tangent != <span class="hljs-literal">undefined</span>;
	<span class="hljs-keyword">var</span> start = hasTangents ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">var</span> end = hasTangents ? us.length - degree + <span class="hljs-number">1</span> : us.length - degree;

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = start, l = end; i &lt; l; i++){

		<span class="hljs-keyword">var</span> weightSums = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; degree; j++){
			weightSums += us[i + j]
		}

		knotsStart.push( (<span class="hljs-number">1</span> / degree) * weightSums );
	}

	<span class="hljs-keyword">var</span> knots = knotsStart.concat( numeric.rep( [ degree + <span class="hljs-number">1</span> ], <span class="hljs-number">1</span> ) );</pre></div></div>
            
        </li>
        
        
        <li id="section-351">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-351">&#182;</a>
              </div>
              <p>build matrix of basis function coeffs (TODO: use sparse rep)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> A = [];
	<span class="hljs-keyword">var</span> n = hasTangents ? points.length + <span class="hljs-number">1</span> : points.length - <span class="hljs-number">1</span>;

	<span class="hljs-keyword">var</span> lst = hasTangents ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> ld = hasTangents ? points.length - (degree - <span class="hljs-number">1</span>) : points.length - (degree + <span class="hljs-number">1</span>);

	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; us.length; i++ ){

		<span class="hljs-keyword">var</span> u = us[i];

		<span class="hljs-keyword">var</span> span = verb.eval.knot_span_given_n( n, degree, u, knots )
		<span class="hljs-keyword">var</span> basisFuncs = verb.eval.basis_functions_given_knot_span_index( span, u, degree, knots );

		<span class="hljs-keyword">var</span> ls = span - degree;

		<span class="hljs-keyword">var</span> rowstart = verb.eval.zeros_1d( ls );
		<span class="hljs-keyword">var</span> rowend = verb.eval.zeros_1d( ld - ls );

		A.push( rowstart.concat(basisFuncs).concat(rowend) );
	}

	<span class="hljs-keyword">if</span> (hasTangents){
		<span class="hljs-keyword">var</span> ln = A[<span class="hljs-number">0</span>].length - <span class="hljs-number">2</span>;

		<span class="hljs-keyword">var</span> tanRow0 = [-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>].concat( verb.eval.zeros_1d( ln ) );
		<span class="hljs-keyword">var</span> tanRow1 = verb.eval.zeros_1d( ln ).concat( [-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] );

		A.splice( <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, tanRow0 );
		A.splice( A.length-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, tanRow1 );
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-352">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-352">&#182;</a>
              </div>
              <p>for each dimension, solve</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> dim = points[<span class="hljs-number">0</span>].length;
	<span class="hljs-keyword">var</span> xs = [];

	<span class="hljs-keyword">var</span> mult1 = (<span class="hljs-number">1</span> - knots[knots.length - degree - <span class="hljs-number">2</span>] ) / degree;
	<span class="hljs-keyword">var</span> mult0 = (knots[degree + <span class="hljs-number">1</span>] ) / degree;

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; dim; i++){

		<span class="hljs-keyword">if</span> (!hasTangents){
			<span class="hljs-keyword">var</span> b = points.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span>{ <span class="hljs-keyword">return</span> x[i]; });
		} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-353">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-353">&#182;</a>
              </div>
              <p>insert the tangents at the second and second to last index</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> b = [ points[<span class="hljs-number">0</span>][i] ];
			b.push( mult0 * start_tangent[i]);
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt; points.length - <span class="hljs-number">1</span>; j++) b.push( points[j][i] );
			b.push( mult1 * end_tangent[i] );
			b.push( verb.last(points)[i] );
		}

		<span class="hljs-keyword">var</span> x = numeric.solve( A, b );

		xs.push(x);
	}

	<span class="hljs-keyword">var</span> controlPts = numeric.transpose(xs);
	<span class="hljs-keyword">var</span> weights = numeric.rep([controlPts.length], <span class="hljs-number">1</span>);

	<span class="hljs-keyword">return</span> { control_points: controlPts, knots: knots, degree: degree, weights: weights };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-354">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-354">&#182;</a>
              </div>
              <h4 id="get_sweep1_surface-profile_knots-profile_degree-profile_control_points-profile_weights-rail_knots-rail_degree-rail_control_points-rail_weights-">get_sweep1_surface( profile_knots, profile_degree, profile_control_points, profile_weights, rail_knots, rail_degree, rail_control_points, rail_weights )</h4>
<p>Generate the control points, weights, and knots of an elliptical arc</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, the center</li>
<li><em>Array</em>, the xaxis</li>
<li><em>Array</em>, orthogonal yaxis</li>
<li><em>Number</em>, xradius of the ellipse arc</li>
<li><em>Number</em>, yradius of the ellipse arc</li>
<li><em>Number</em>, start angle of the ellipse arc, between 0 and 2pi, where 0 points at the xaxis</li>
<li><em>Number</em>, end angle of the arc, between 0 and 2pi, greater than the start angle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.get_sweep1_surface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( profile_knots, profile_degree, profile_control_points, profile_weights, rail_knots, rail_degree, rail_control_points, rail_weights )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-355">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-355">&#182;</a>
              </div>
              <p>for each point on rail, move all of the points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> homo_rail = verb.eval.homogenize_1d( rail_control_points, rail_weights )
		, rail_start = verb.eval.rational_curve_point( rail_degree, rail_knots, homo_rail, <span class="hljs-number">0</span> )
		, span = <span class="hljs-number">1.0</span> / rail_control_points.length
		, control_points = []
		, weights = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; rail_control_points.length; i++ ){</pre></div></div>
            
        </li>
        
        
        <li id="section-356">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-356">&#182;</a>
              </div>
              <p>evaluate the point on the curve, subtracting it from the first point</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> rail_point = verb.eval.rational_curve_point( rail_degree, rail_knots, homo_rail, i * span )
			, rail_offset = numeric.sub( rail_point, rail_start )
			, row_control_points = []
			, row_weights = [];

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; profile_control_points.length; j++ ){

			row_control_points.push( numeric.add(rail_offset, profile_control_points[j] ) );
			row_weights.push( profile_weights[j] * rail_weights[i] );

		}

		control_points.push( row_control_points);
		weights.push( row_weights );
	}

	<span class="hljs-keyword">return</span> {<span class="hljs-string">"knots_u"</span>: rail_knots, 
			<span class="hljs-string">"knots_v"</span>: profile_knots,
			<span class="hljs-string">"control_points"</span>: control_points, 
			<span class="hljs-string">"degree_u"</span>: rail_degree, 
			<span class="hljs-string">"degree_v"</span>: profile_degree, 
			<span class="hljs-string">"weights"</span>: weights };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-357">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-357">&#182;</a>
              </div>
              <h4 id="get_ellipse_arc-center-xaxis-yaxis-xradius-yradius-start_angle-end_angle-">get_ellipse_arc( center, xaxis, yaxis, xradius, yradius, start_angle, end_angle )</h4>
<p>Generate the control points, weights, and knots of an elliptical arc</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, the center</li>
<li><em>Array</em>, the xaxis</li>
<li><em>Array</em>, orthogonal yaxis</li>
<li><em>Number</em>, xradius of the ellipse arc</li>
<li><em>Number</em>, yradius of the ellipse arc</li>
<li><em>Number</em>, start angle of the ellipse arc, between 0 and 2pi, where 0 points at the xaxis</li>
<li><em>Number</em>, end angle of the arc, between 0 and 2pi, greater than the start angle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.get_ellipse_arc = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( center, xaxis, yaxis, xradius, yradius, start_angle, end_angle )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-358">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-358">&#182;</a>
              </div>
              <p>if the end angle is less than the start angle, do a circle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (end_angle &lt; start_angle) end_angle = <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI + start_angle;

	<span class="hljs-keyword">var</span> theta = end_angle - start_angle
		, narcs = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-359">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-359">&#182;</a>
              </div>
              <p>how many arcs?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (theta &lt;= <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">2</span>) {
		narcs = <span class="hljs-number">1</span>;
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">if</span> (theta &lt;= <span class="hljs-built_in">Math</span>.PI){
			narcs = <span class="hljs-number">2</span>;
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (theta &lt;= <span class="hljs-number">3</span> * <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">2</span>){
			narcs = <span class="hljs-number">3</span>;
		} <span class="hljs-keyword">else</span> {
			narcs = <span class="hljs-number">4</span>;
		}
	}

	<span class="hljs-keyword">var</span> dtheta = theta / narcs
		, n = <span class="hljs-number">2</span> * narcs
		, w1 = <span class="hljs-built_in">Math</span>.cos( dtheta / <span class="hljs-number">2</span>) 
		, P0 = numeric.add( center, numeric.mul( xradius, <span class="hljs-built_in">Math</span>.cos(start_angle), xaxis), numeric.mul( yradius, <span class="hljs-built_in">Math</span>.sin(start_angle), yaxis ) )
		, T0 = numeric.sub( numeric.mul( <span class="hljs-built_in">Math</span>.cos(start_angle), yaxis ), numeric.mul( <span class="hljs-built_in">Math</span>.sin(start_angle), xaxis) )
		, Pw = verb.eval.zeros_1d( narcs * <span class="hljs-number">2</span> )
		, U = verb.eval.zeros_1d( <span class="hljs-number">2</span> *narcs + <span class="hljs-number">3</span> )
		, index = <span class="hljs-number">0</span>
		, angle = start_angle
		, W = verb.eval.zeros_1d( narcs * <span class="hljs-number">2</span> );

	Pw[<span class="hljs-number">0</span>] = P0;
	W[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= narcs; i++){

		angle += dtheta;
		<span class="hljs-keyword">var</span> P2 = numeric.add( center, numeric.mul( xradius, <span class="hljs-built_in">Math</span>.cos(angle), xaxis), numeric.mul( yradius, <span class="hljs-built_in">Math</span>.sin(angle), yaxis ) )

		W[index+<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;
		Pw[index+<span class="hljs-number">2</span>] = P2;

		<span class="hljs-keyword">var</span> T2 = numeric.sub( numeric.mul( <span class="hljs-built_in">Math</span>.cos(angle), yaxis ), numeric.mul( <span class="hljs-built_in">Math</span>.sin(angle), xaxis) )

		<span class="hljs-keyword">var</span> params = verb.eval.intersect_rays(P0, numeric.mul( <span class="hljs-number">1</span> / numeric.norm2(T0), T0), P2, numeric.mul( <span class="hljs-number">1</span> / numeric.norm2(T2), T2));
		<span class="hljs-keyword">var</span> P1 = numeric.add( P0, numeric.mul(T0, params[<span class="hljs-number">0</span>]));

		W[index+<span class="hljs-number">1</span>] = w1;
		Pw[index+<span class="hljs-number">1</span>] = P1;

		index += <span class="hljs-number">2</span>;

		<span class="hljs-keyword">if</span> (i &lt; narcs){
			P0 = P2;
			T0 = T2;
		}
	}

	<span class="hljs-keyword">var</span> j = <span class="hljs-number">2</span> *  narcs + <span class="hljs-number">1</span>;

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++){
		U[i] = <span class="hljs-number">0.0</span>;
		U[i+j] = <span class="hljs-number">1.0</span>;
	}

	<span class="hljs-keyword">switch</span> (narcs){
		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: U[<span class="hljs-number">3</span>] = U[<span class="hljs-number">4</span>] = <span class="hljs-number">0.5</span>; <span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: U[<span class="hljs-number">3</span>] = U[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>/<span class="hljs-number">3</span>;
						U[<span class="hljs-number">5</span>] = U[<span class="hljs-number">6</span>] = <span class="hljs-number">2</span>/<span class="hljs-number">3</span>; <span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: U[<span class="hljs-number">3</span>] = U[<span class="hljs-number">4</span>] = <span class="hljs-number">0.25</span>;
						U[<span class="hljs-number">5</span>] = U[<span class="hljs-number">6</span>] = <span class="hljs-number">0.5</span>;
						U[<span class="hljs-number">7</span>] = U[<span class="hljs-number">8</span>] = <span class="hljs-number">0.75</span>; <span class="hljs-keyword">break</span>;
	}

	<span class="hljs-keyword">return</span> {knots: U, control_points: Pw, degree: <span class="hljs-number">2</span>, weights: W };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-360">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-360">&#182;</a>
              </div>
              <h4 id="get_sphere_surface-center-axis-xaxis-radius-">get_sphere_surface( center, axis, xaxis, radius )</h4>
<p>Generate the control points, weights, and knots of a sphere</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, the center of the sphere</li>
<li><em>Array</em>, normalized axis of sphere</li>
<li><em>Array</em>, vector perpendicular to axis of sphere, starting the rotation of the sphere</li>
<li><em>Number</em>, radius of the sphere</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots_u, knots_v, degree_u, degree_v</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.get_sphere_surface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( center, axis, xaxis, radius )</span></span>{

	<span class="hljs-keyword">var</span> arc = verb.eval.get_arc(center, numeric.mul(axis, -<span class="hljs-number">1</span>), xaxis, radius, <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.PI );

	<span class="hljs-keyword">return</span> verb.eval.get_revolved_surface( center, axis, <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI, arc.knots, arc.degree, arc.control_points, arc.weights );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-361">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-361">&#182;</a>
              </div>
              <h4 id="get_polyline_curve-pts-">get_polyline_curve( pts )</h4>
<p>Generate the control points, weights, and knots of a polyline curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of points in curve</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.get_polyline_curve = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( pts )</span></span>{

	<span class="hljs-keyword">var</span> num_spans = pts.length - <span class="hljs-number">1</span>
		, span = <span class="hljs-number">1.0</span> / num_spans
		, knots = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; num_spans; i++){
		knots.push(i * span);
	}

	knots.push(<span class="hljs-number">1</span>);
	knots.push(<span class="hljs-number">1</span>);

	<span class="hljs-keyword">var</span> weights = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pts.length; i++){
		weights.push(<span class="hljs-number">1</span>);
	}

	<span class="hljs-keyword">return</span> {
			<span class="hljs-string">"knots"</span>: knots, 
			<span class="hljs-string">"control_points"</span>: pts.slice(<span class="hljs-number">0</span>), 
			<span class="hljs-string">"degree"</span>: <span class="hljs-number">1</span>,
			<span class="hljs-string">"weights"</span>: weights 
		};
			
}</pre></div></div>
            
        </li>
        
        
        <li id="section-362">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-362">&#182;</a>
              </div>
              <h4 id="get_4pt_surface-p1-p2-p3-p4-">get_4pt_surface( p1, p2, p3, p4 )</h4>
<p>Generate the control points, weights, and knots of a surface define by 3 points</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, first point in counter-clockwise form</li>
<li><em>Array</em>, second point in counter-clockwise form</li>
<li><em>Array</em>, third point in counter-clockwise form</li>
<li><em>Array</em>, forth point in counter-clockwise form</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots_u, knots_v, degree_u, degree_v</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.get_4pt_surface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( p1, p2, p3, p4 )</span></span>{

	<span class="hljs-keyword">var</span> p1p4 = numeric.mul( <span class="hljs-number">0.5</span>, numeric.add( p1, p4 ));
	<span class="hljs-keyword">var</span> p2p3 = numeric.mul( <span class="hljs-number">0.5</span>, numeric.add( p2, p3 ));
	<span class="hljs-keyword">var</span> p3p4 = numeric.mul( <span class="hljs-number">0.5</span>, numeric.add( p3, p4 ));
	<span class="hljs-keyword">var</span> p1p2 = numeric.mul( <span class="hljs-number">0.5</span>, numeric.add( p1, p2 ));
	<span class="hljs-keyword">var</span> p1p4p2p3 = numeric.mul( <span class="hljs-number">0.5</span>, numeric.add( p1p4, p2p3 ));

	<span class="hljs-keyword">return</span> {<span class="hljs-string">"knots_u"</span>: [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], 
			<span class="hljs-string">"knots_v"</span>: [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], 
			<span class="hljs-string">"control_points"</span>: [ [p1, 		p1p4, 		p4], 
													[p1p2, 	p1p4p2p3, p3p4], 
													[p2, 		p2p3, 		p3] ], 
			<span class="hljs-string">"degree_u"</span>: <span class="hljs-number">2</span>, 
			<span class="hljs-string">"degree_v"</span>: <span class="hljs-number">2</span>,
			<span class="hljs-string">"weights"</span>: [ [ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], 
									 [ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], 
									 [ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>] ] };
			
}</pre></div></div>
            
        </li>
        
        
        <li id="section-363">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-363">&#182;</a>
              </div>
              <h4 id="get_cylinder_surface-axis-xaxis-base-height-radius-">get_cylinder_surface( axis, xaxis, base, height, radius )</h4>
<p>Generate the control points, weights, and knots of a cylinder</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, normalized axis of cylinder</li>
<li><em>Array</em>, xaxis in plane of cylinder</li>
<li><em>Array</em>, position of base of cylinder</li>
<li><em>Number</em>, height from base to top</li>
<li><em>Number</em>, radius of the cylinder</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots_u, knots_v, degree_u, degree_v</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.get_cylinder_surface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( axis, xaxis, base, height, radius )</span></span>{

	<span class="hljs-keyword">var</span> yaxis = crossprod( axis, xaxis )
		, angle = <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI
		, circ = verb.eval.get_arc( base, xaxis, yaxis, radius, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI );

	<span class="hljs-keyword">return</span> verb.eval.get_extruded_surface( axis, height, circ.knots, circ.degree, circ.control_points, circ.weights );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-364">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-364">&#182;</a>
              </div>
              <h4 id="get_cone_surface-axis-xaxis-base-height-radius-">get_cone_surface( axis, xaxis, base, height, radius )</h4>
<p>Generate the control points, weights, and knots of a cone</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, normalized axis of cone</li>
<li><em>Array</em>, position of base of cone</li>
<li><em>Number</em>, height from base to tip</li>
<li><em>Number</em>, radius at the base of the cone</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.get_cone_surface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( axis, xaxis, base, height, radius )</span></span>{

	<span class="hljs-keyword">var</span> angle = <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI
		, prof_degree = <span class="hljs-number">1</span>
		, prof_ctrl_pts = [ numeric.add( base, numeric.mul( height, axis ) ), numeric.add( base, numeric.mul( radius, xaxis ) )]
		, prof_knots = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]
		, prof_weights = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>];

	<span class="hljs-keyword">return</span> verb.eval.get_revolved_surface(base, axis, angle, prof_knots, prof_degree, prof_ctrl_pts, prof_weights);

}</pre></div></div>
            
        </li>
        
        
        <li id="section-365">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-365">&#182;</a>
              </div>
              <h4 id="get_extruded_surface-axis-length-prof_knots-prof_degree-prof_control_points-prof_weights-">get_extruded_surface( axis, length, prof_knots, prof_degree, prof_control_points, prof_weights)</h4>
<p>Generate the control points, weights, and knots of an extruded surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, axis of the extrusion</li>
<li><em>Array</em>, length of the extrusion</li>
<li><em>Number</em>, degree of the profile</li>
<li><em>Number</em>, control points of the profile</li>
<li><em>Number</em>, weights of the profile</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.get_extruded_surface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( axis, length, prof_knots, prof_degree, prof_control_points, prof_weights)</span></span>{

	<span class="hljs-keyword">var</span> control_points = verb.eval.zeros_2d( <span class="hljs-number">3</span>, prof_control_points.length )
		, weights = verb.eval.zeros_2d( <span class="hljs-number">3</span>, prof_control_points.length );

	<span class="hljs-keyword">var</span> translation = numeric.mul(axis, length);
	<span class="hljs-keyword">var</span> halfTranslation = numeric.mul(axis, <span class="hljs-number">0.5</span> * length);</pre></div></div>
            
        </li>
        
        
        <li id="section-366">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-366">&#182;</a>
              </div>
              <p>original control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; prof_control_points.length; j++){
		control_points[<span class="hljs-number">2</span>][j] = prof_control_points[j];
		control_points[<span class="hljs-number">1</span>][j] = numeric.add( halfTranslation, prof_control_points[j] );
		control_points[<span class="hljs-number">0</span>][j] = numeric.add( translation, prof_control_points[j] );

		weights[<span class="hljs-number">0</span>][j] = prof_weights[j];
		weights[<span class="hljs-number">1</span>][j] = prof_weights[j];
		weights[<span class="hljs-number">2</span>][j] = prof_weights[j];
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-367">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-367">&#182;</a>
              </div>
              <p>return all parameters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> {<span class="hljs-string">"knots_u"</span>: [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], 
			<span class="hljs-string">"knots_v"</span>: prof_knots, 
			<span class="hljs-string">"control_points"</span>: control_points, 
			<span class="hljs-string">"degree_u"</span>: <span class="hljs-number">2</span>, 
			<span class="hljs-string">"degree_v"</span>: prof_degree, 
			<span class="hljs-string">"weights"</span>: weights };
}</pre></div></div>
            
        </li>
        
        
        <li id="section-368">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-368">&#182;</a>
              </div>
              <h4 id="get_revolved_surface-center-axis-theta-prof_knots-prof_degree-prof_control_points-prof_weights-">get_revolved_surface( center, axis, theta, prof_knots, prof_degree, prof_control_points, prof_weights)</h4>
<p>Generate the control points, weights, and knots of a revolved surface
(Corresponds to Algorithm A7.1 from Piegl &amp; Tiller)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, center of the rotation axis</li>
<li><em>Array</em>, axis of the rotation axis</li>
<li><em>Number</em>, angle to revolve around axis</li>
<li><em>Number</em>, degree of the generatrix</li>
<li><em>Number</em>, control points of the generatrix</li>
<li><em>Number</em>, weights of the generatrix</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
        </li>
        
        
        <li id="section-369">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-369">&#182;</a>
              </div>
              <p>helper method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">crossprod</span><span class="hljs-params">(u,v)</span> </span>{
  <span class="hljs-keyword">return</span> [u[<span class="hljs-number">1</span>]*v[<span class="hljs-number">2</span>]-u[<span class="hljs-number">2</span>]*v[<span class="hljs-number">1</span>],u[<span class="hljs-number">2</span>]*v[<span class="hljs-number">0</span>]-u[<span class="hljs-number">0</span>]*v[<span class="hljs-number">2</span>],u[<span class="hljs-number">0</span>]*v[<span class="hljs-number">1</span>]-u[<span class="hljs-number">1</span>]*v[<span class="hljs-number">0</span>]];
}

verb.eval.get_revolved_surface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( center, axis, theta, prof_knots, prof_degree, prof_control_points, prof_weights)</span></span>{

	<span class="hljs-keyword">var</span> narcs, knots_u, control_points, weights;

	<span class="hljs-keyword">if</span> (theta &lt;= <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">2</span>) { <span class="hljs-comment">// less than 90</span>
		narcs = <span class="hljs-number">1</span>;
		knots_u = verb.eval.zeros_1d( <span class="hljs-number">6</span> + <span class="hljs-number">2</span>  * (narcs-<span class="hljs-number">1</span>) );
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">if</span> (theta &lt;= <span class="hljs-built_in">Math</span>.PI){  <span class="hljs-comment">// between 90 and 180</span>
			narcs = <span class="hljs-number">2</span>;
			knots_u = verb.eval.zeros_1d( <span class="hljs-number">6</span> + <span class="hljs-number">2</span> * (narcs-<span class="hljs-number">1</span>) );
			knots_u[<span class="hljs-number">3</span>]= knots_u[<span class="hljs-number">4</span>] = <span class="hljs-number">0.5</span>;
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (theta &lt;= <span class="hljs-number">3</span> * <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">2</span>){ <span class="hljs-comment">// between 180 and 270</span>
			narcs = <span class="hljs-number">3</span>;
			knots_u = verb.eval.zeros_1d( <span class="hljs-number">6</span> + <span class="hljs-number">2</span> * (narcs-<span class="hljs-number">1</span>) );
			knots_u[<span class="hljs-number">3</span>]= knots_u[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>/<span class="hljs-number">3</span>;
			knots_u[<span class="hljs-number">5</span>]= knots_u[<span class="hljs-number">6</span>] = <span class="hljs-number">2</span>/<span class="hljs-number">3</span>;
		} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// between 270 and 360</span>
			narcs = <span class="hljs-number">4</span>;
			knots_u = verb.eval.zeros_1d( <span class="hljs-number">6</span> + <span class="hljs-number">2</span> * (narcs-<span class="hljs-number">1</span>) );
			knots_u[<span class="hljs-number">3</span>]= knots_u[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>/<span class="hljs-number">4</span>;
			knots_u[<span class="hljs-number">5</span>]= knots_u[<span class="hljs-number">6</span>] = <span class="hljs-number">1</span>/<span class="hljs-number">2</span>;
			knots_u[<span class="hljs-number">7</span>]= knots_u[<span class="hljs-number">8</span>] = <span class="hljs-number">3</span>/<span class="hljs-number">4</span>;
		}
	}

	<span class="hljs-keyword">var</span> dtheta = theta / narcs <span class="hljs-comment">// divide the interval into several points</span>
		, j = <span class="hljs-number">3</span> + <span class="hljs-number">2</span> * (narcs-<span class="hljs-number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-370">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-370">&#182;</a>
              </div>
              <p>initialize the start and end knots
keep in mind that we only return the knot vector for the </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; j++, i++){
		knots_u[i] = <span class="hljs-number">0.0</span>;
		knots_u[j] = <span class="hljs-number">1.0</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-371">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-371">&#182;</a>
              </div>
              <p>do some initialization</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> n = <span class="hljs-number">2</span> * narcs 
		, wm = <span class="hljs-built_in">Math</span>.cos( dtheta/<span class="hljs-number">2.0</span> )
		, angle = <span class="hljs-number">0.0</span>
		, sines = verb.eval.zeros_1d( narcs + <span class="hljs-number">1</span>)
		, cosines = verb.eval.zeros_1d( narcs + <span class="hljs-number">1</span>)
		, control_points = verb.eval.zeros_2d( <span class="hljs-number">2</span>*narcs + <span class="hljs-number">1</span>, prof_control_points.length )
		, weights = verb.eval.zeros_2d( <span class="hljs-number">2</span>*narcs + <span class="hljs-number">1</span>, prof_control_points.length );</pre></div></div>
            
        </li>
        
        
        <li id="section-372">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-372">&#182;</a>
              </div>
              <p>initialize the sines and cosines</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= narcs; i++){
		angle += dtheta;
		cosines[i] = <span class="hljs-built_in">Math</span>.cos(angle);
		sines[i] = <span class="hljs-built_in">Math</span>.sin(angle);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-373">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-373">&#182;</a>
              </div>
              <p>for each pt in the generatrix
i.e. for each row of the 2d knot vectors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; prof_control_points.length; j++){</pre></div></div>
            
        </li>
        
        
        <li id="section-374">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-374">&#182;</a>
              </div>
              <p>get the closest point of the generatrix point on the axis</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> O = verb.eval.closest_point_on_ray(prof_control_points[j], center, axis)</pre></div></div>
            
        </li>
        
        
        <li id="section-375">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-375">&#182;</a>
              </div>
              <p>X is the vector from the axis to generatrix control pt</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			, X = numeric.sub( prof_control_points[j], O )</pre></div></div>
            
        </li>
        
        
        <li id="section-376">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-376">&#182;</a>
              </div>
              <p>radius at that height</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			, r = numeric.norm2(X)</pre></div></div>
            
        </li>
        
        
        <li id="section-377">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-377">&#182;</a>
              </div>
              <p>Y is perpendicular to X and axis, and complete the coordinate system</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			, Y = crossprod(axis,X); 

		<span class="hljs-keyword">if</span> ( r &gt; verb.EPSILON ){
			X = numeric.mul( <span class="hljs-number">1</span> / r, X);
			Y = numeric.mul( <span class="hljs-number">1</span> / r, Y);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-378">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-378">&#182;</a>
              </div>
              <p>the first row of control_points and weights is just the generatrix</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		control_points[<span class="hljs-number">0</span>][j] = prof_control_points[j];
		<span class="hljs-keyword">var</span> P0 = prof_control_points[j];
		weights[<span class="hljs-number">0</span>][j] = prof_weights[j];</pre></div></div>
            
        </li>
        
        
        <li id="section-379">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-379">&#182;</a>
              </div>
              <p>store T0 as the Y vector</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> T0 = Y
			, index = <span class="hljs-number">0</span>
			, angle = <span class="hljs-number">0.0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-380">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-380">&#182;</a>
              </div>
              <p>proceed around the circle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= narcs; i++){</pre></div></div>
            
        </li>
        
        
        <li id="section-381">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-381">&#182;</a>
              </div>
              <p>O + r <em> cos(theta) </em> X + r <em> sin(theta) </em> Y
rotated generatrix pt</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> P2 = r == <span class="hljs-number">0</span> ? O : numeric.add( O, numeric.mul( r, cosines[i], X), numeric.mul( r, sines[i], Y) );

			control_points[index+<span class="hljs-number">2</span>][j] = P2;
			weights[index+<span class="hljs-number">2</span>][j] = prof_weights[j];</pre></div></div>
            
        </li>
        
        
        <li id="section-382">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-382">&#182;</a>
              </div>
              <p>construct the vector tangent to the rotation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> T2 = numeric.sub( numeric.mul( cosines[i], Y), numeric.mul(sines[i], X));</pre></div></div>
            
        </li>
        
        
        <li id="section-383">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-383">&#182;</a>
              </div>
              <p>construct the next control pt</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>){
				control_points[index+<span class="hljs-number">1</span>][j] = O;
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">var</span> params = verb.eval.intersect_rays(P0, numeric.mul( <span class="hljs-number">1</span> / numeric.norm2(T0), T0), P2, numeric.mul( <span class="hljs-number">1</span> / numeric.norm2(T2), T2));
				<span class="hljs-keyword">var</span> P1 = numeric.add( P0, numeric.mul(T0, params[<span class="hljs-number">0</span>]));

				control_points[index+<span class="hljs-number">1</span>][j] = P1;
			}

			weights[index+<span class="hljs-number">1</span>][j] = wm * prof_weights[j];

			index += <span class="hljs-number">2</span>;

			<span class="hljs-keyword">if</span> (i &lt; narcs)
			{
				P0 = P2;
				T0 = T2;
			}

		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-384">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-384">&#182;</a>
              </div>
              <p>store all of the parameters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> {<span class="hljs-string">"knots_u"</span>: knots_u, 
			<span class="hljs-string">"knots_v"</span>: prof_knots, 
			<span class="hljs-string">"control_points"</span>: control_points, 
			<span class="hljs-string">"degree_u"</span>: <span class="hljs-number">2</span>, 
			<span class="hljs-string">"degree_v"</span>: prof_degree, 
			<span class="hljs-string">"weights"</span>: weights };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-385">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-385">&#182;</a>
              </div>
              <h4 id="get_arc-center-xaxis-yaxis-radius-start_angle-end_angle-">get_arc( center, xaxis, yaxis, radius, start_angle, end_angle )</h4>
<p>Generate the control points, weights, and knots of an arbitrary arc
(Corresponds to Algorithm A7.1 from Piegl &amp; Tiller)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, the center of the arc</li>
<li><em>Array</em>, the xaxis of the arc</li>
<li><em>Array</em>, orthogonal yaxis of the arc</li>
<li><em>Number</em>, radius of the arc</li>
<li><em>Number</em>, start angle of the arc, between 0 and 2pi</li>
<li><em>Number</em>, end angle of the arc, between 0 and 2pi, greater than the start angle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.get_arc = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( center, xaxis, yaxis, radius, start_angle, end_angle )</span> </span>{

	<span class="hljs-keyword">return</span> verb.eval.get_ellipse_arc( center, xaxis, yaxis, radius, radius, start_angle, end_angle );

}


verb.eval.surface_split = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, control_points, u, dir)</span> </span>{

	<span class="hljs-keyword">var</span> c
		, newPts = []
		, knots
		, degree
		, newknots
		, i;

	<span class="hljs-keyword">if</span> (dir === <span class="hljs-number">0</span>){

		control_points = numeric.transpose( control_points );
		knots = knots_u;
		degree = degree_u;

	} <span class="hljs-keyword">else</span> {

		control_points = control_points;
		knots = knots_v;
		degree = degree_v;
	
	}

	<span class="hljs-keyword">var</span> knots_to_insert = [];
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; degree+<span class="hljs-number">1</span>; i++) knots_to_insert.push(u);

	<span class="hljs-keyword">var</span> newpts0 = []
		, newpts1 = []
		, res;

	<span class="hljs-keyword">var</span> s = verb.eval.knot_span( degree, u, knots );

	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; control_points.length; i++){

		res = verb.eval.curve_knot_refine( degree, knots, control_points[i], knots_to_insert );

		<span class="hljs-keyword">var</span> cpts0 = res.control_points.slice( <span class="hljs-number">0</span>, s + <span class="hljs-number">1</span> );
		<span class="hljs-keyword">var</span> cpts1 = res.control_points.slice( s + <span class="hljs-number">1</span> );

		newpts0.push( cpts0 );
		newpts1.push( cpts1 );

	}
	
	<span class="hljs-keyword">var</span> knots0 = res.knots.slice(<span class="hljs-number">0</span>, s + degree + <span class="hljs-number">2</span>);
	<span class="hljs-keyword">var</span> knots1 = res.knots.slice( s + <span class="hljs-number">1</span> );

	<span class="hljs-keyword">if</span> (dir === <span class="hljs-number">0</span>){

		newpts0 = numeric.transpose( newpts0 );
		newpts1 = numeric.transpose( newpts1 );

		<span class="hljs-keyword">return</span> [
			{ degree_u: degree, 
				knots_u: knots0, 

				degree_v: degree_v, 
				knots_v: knots_v, 

				control_points: newpts0 
			},
			{ degree_u: degree, 
				knots_u: knots1, 

				degree_v: degree_v, 
				knots_v: knots_v, 

				control_points: newpts1 
			}];</pre></div></div>
            
        </li>
        
        
        <li id="section-386">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-386">&#182;</a>
              </div>
              <p>v dir</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	} <span class="hljs-keyword">else</span> {

		<span class="hljs-keyword">return</span> [
			{ degree_u: degree_u, 
				knots_u: knots_u, 

				degree_v: degree, 
				knots_v: knots0, 

				control_points: newpts0 
			},
			{ degree_u: degree_u, 
				knots_u: knots_u, 

				degree_v: degree, 
				knots_v: knots1, 

				control_points: newpts1 
			}];

	}
}

verb.eval.surface_knot_refine =  <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, control_points, knots_to_insert, dir )</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-387">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-387">&#182;</a>
              </div>
              <p>TODO: make this faster by taking advantage of repeat computations in every row
             i.e. no reason to recompute the knot vectors on every row</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">var</span> c
		, newPts = []
		, knots
		, degree
		, ctrlPts
		, newknots;</pre></div></div>
            
        </li>
        
        
        <li id="section-388">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-388">&#182;</a>
              </div>
              <p>u dir</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (dir === <span class="hljs-number">0</span>){

		ctrlPts = numeric.transpose( control_points );
		knots = knots_u;
		degree = degree_u;</pre></div></div>
            
        </li>
        
        
        <li id="section-389">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-389">&#182;</a>
              </div>
              <p>v dir</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	} <span class="hljs-keyword">else</span> {

		ctrlPts = control_points;
		knots = knots_v;
		degree = degree_v;

	}</pre></div></div>
            
        </li>
        
        
        <li id="section-390">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-390">&#182;</a>
              </div>
              <p>do knot refinement on every row</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ctrlPts.length; i++ ){
		
		c = verb.eval.curve_knot_refine( degree, knots, ctrlPts[i], knots_to_insert );
		newPts.push( c.control_points );

	}

	newknots = c.knots;</pre></div></div>
            
        </li>
        
        
        <li id="section-391">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-391">&#182;</a>
              </div>
              <p>u dir</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (dir === <span class="hljs-number">0</span>){

		newPts = numeric.transpose( newPts );

		<span class="hljs-keyword">return</span> {
			knots_u: newknots,
			degree_u : degree,

			knots_v: knots_v,
			degree_v : degree_v,

			control_points: newPts 
		};</pre></div></div>
            
        </li>
        
        
        <li id="section-392">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-392">&#182;</a>
              </div>
              <p>v dir</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	} <span class="hljs-keyword">else</span> {

		<span class="hljs-keyword">return</span> {
			knots_u: knots_u,
			degree_u : degree_u,

			knots_v: newknots,
			degree_v : degree,

			control_points: newPts
		};

	}

}</pre></div></div>
            
        </li>
        
        
        <li id="section-393">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-393">&#182;</a>
              </div>
              <h4 id="curve_bezier_decompose-degree-knots-control_points-">curve_bezier_decompose( degree, knots, control_points )</h4>
<p>Decompose a NURBS curve into a collection of bezier’s.  Useful
as each bezier fits into it’s convex hull.  This is a useful starting
point for intersection, closest point, algorithms</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, array of control points</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em> of curves, defined by degree, knots, and control points</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.curve_bezier_decompose = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-394">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-394">&#182;</a>
              </div>
              <p>find all of the unique knot values and their multiplicity
for each, increase their multiplicity to degree + 1</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">var</span> mults = verb.eval.knot_multiplicities( knots );
	<span class="hljs-keyword">var</span> reqMult = degree + <span class="hljs-number">1</span>;
	<span class="hljs-keyword">var</span> refine = verb.eval.curve_knot_refine;</pre></div></div>
            
        </li>
        
        
        <li id="section-395">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-395">&#182;</a>
              </div>
              <p>insert the knots</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; mults.length; i++){
		<span class="hljs-keyword">if</span> ( mults[i][<span class="hljs-number">1</span>] &lt; reqMult ){

			<span class="hljs-keyword">var</span> knotsInsert = numeric.rep( [ reqMult - mults[i][<span class="hljs-number">1</span>] ], mults[i][<span class="hljs-number">0</span>] );
			<span class="hljs-keyword">var</span> res = refine( degree, knots, control_points, knotsInsert );

			knots = res.knots;
			control_points = res.control_points;

		}
	}

	<span class="hljs-keyword">var</span> numCrvs = knots.length / reqMult - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">var</span> crvKnotLength = reqMult * <span class="hljs-number">2</span>;

	<span class="hljs-keyword">var</span> crvs = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; control_points.length; i += reqMult ){

		<span class="hljs-keyword">var</span> kts = knots.slice( i, i + crvKnotLength );
		<span class="hljs-keyword">var</span> pts = control_points.slice( i, i + reqMult );

		crvs.push( { degree : degree, knots: kts, control_points: pts } );

	}

	<span class="hljs-keyword">return</span> crvs;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-396">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-396">&#182;</a>
              </div>
              <h4 id="knot_multiplicities-knots-">knot_multiplicities( knots )</h4>
<p>Determine the multiplicities of the values in a knot vector</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em> of length 2 arrays, [knotValue, knotMultiplicity]</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.knot_multiplicities = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(knots)</span></span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-397">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-397">&#182;</a>
              </div>
              <p>initialize</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> mults = [ [ knots[<span class="hljs-number">0</span>], <span class="hljs-number">0</span> ] ];
	<span class="hljs-keyword">var</span> curr = mults[<span class="hljs-number">0</span>];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; knots.length; i++){

		<span class="hljs-keyword">if</span> ( (<span class="hljs-built_in">Math</span>.abs(knots[i] - curr[<span class="hljs-number">0</span>])) &gt; verb.EPSILON ){

			curr = [knots[i], <span class="hljs-number">0</span>];
			mults.push(curr);

		} 

		curr[<span class="hljs-number">1</span>]++;

	}

	<span class="hljs-keyword">return</span> mults;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-398">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-398">&#182;</a>
              </div>
              <h4 id="curve_split-degree-knots-control_points-u-">curve_split( degree, knots, control_points, u )</h4>
<p>Split a curve into two parts</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, array of control points</li>
<li><em>Number</em>, location to split the curve</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em> two new curves, defined by degree, knots, and control points</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.curve_split = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, u )</span> </span>{

	<span class="hljs-keyword">var</span> knots_to_insert = [];
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; degree+<span class="hljs-number">1</span>; i++) knots_to_insert.push(u);
	<span class="hljs-keyword">var</span> res = verb.eval.curve_knot_refine( degree, knots, control_points, knots_to_insert );

	<span class="hljs-keyword">var</span> s = verb.eval.knot_span( degree, u, knots );

	<span class="hljs-keyword">var</span> knots0 = res.knots.slice(<span class="hljs-number">0</span>, s + degree + <span class="hljs-number">2</span>);
	<span class="hljs-keyword">var</span> knots1 = res.knots.slice( s + <span class="hljs-number">1</span> );

	<span class="hljs-keyword">var</span> cpts0 = res.control_points.slice( <span class="hljs-number">0</span>, s + <span class="hljs-number">1</span> );
	<span class="hljs-keyword">var</span> cpts1 = res.control_points.slice( s + <span class="hljs-number">1</span> );

	<span class="hljs-keyword">return</span> [
		{ degree: degree, knots: knots0, control_points: cpts0 },
		{ degree: degree, knots: knots1, control_points: cpts1 }
	];

}</pre></div></div>
            
        </li>
        
        
        <li id="section-399">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-399">&#182;</a>
              </div>
              <h4 id="curve_knot_refine-degree-knots-control_points-knots_to_insert-">curve_knot_refine( degree, knots, control_points, knots_to_insert )</h4>
<p>Insert a collection of knots on a curve</p>
<p>Corresponds to Algorithm A5.4 (Piegl &amp; Tiller)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, array of control points</li>
<li><em>Array</em>, knots to insert</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em> the new curve, defined by knots and control_points</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.curve_knot_refine = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, knots_to_insert )</span> </span>{

	<span class="hljs-keyword">var</span> n = control_points.length - <span class="hljs-number">1</span>
		, m = n + degree + <span class="hljs-number">1</span>
		, r = knots_to_insert.length - <span class="hljs-number">1</span>
		, a = verb.eval.knot_span( degree, knots_to_insert[<span class="hljs-number">0</span>], knots ) 
		, b = verb.eval.knot_span( degree, knots_to_insert[r], knots )
		, control_points_post = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( control_points.length + r + <span class="hljs-number">1</span> )
		, knots_post = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( knots.length + r + <span class="hljs-number">1</span> )
		, i = <span class="hljs-number">0</span>
		, j = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-400">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-400">&#182;</a>
              </div>
              <p>new control pts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= a - degree; i++) {
		control_points_post[i] = control_points[i];
	}

	<span class="hljs-keyword">for</span> (i = b-<span class="hljs-number">1</span>; i &lt;= n; i++) {
		control_points_post[i+r+<span class="hljs-number">1</span>] = control_points[i];
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-401">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-401">&#182;</a>
              </div>
              <p>new knot vector</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= a; i++) {
		knots_post[i] = knots[i];
	}

	<span class="hljs-keyword">for</span> (i = b+degree; i &lt;= m; i++){
		knots_post[i+r+<span class="hljs-number">1</span>] = knots[i];
	}

	i = b + degree - <span class="hljs-number">1</span>;
	<span class="hljs-keyword">var</span> k = b + degree + r;

	<span class="hljs-keyword">for</span> (j=r; j&gt;=<span class="hljs-number">0</span>; j--) {

		<span class="hljs-keyword">while</span> (knots_to_insert[j] &lt;= knots[i] &amp;&amp; i &gt; a){

			control_points_post[k-degree-<span class="hljs-number">1</span>] = control_points[i-degree-<span class="hljs-number">1</span>];
			knots_post[k] = knots[i];
			k = k-<span class="hljs-number">1</span>;
			i = i-<span class="hljs-number">1</span>;

		}

		control_points_post[k-degree-<span class="hljs-number">1</span>] = control_points_post[k-degree];

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> l = <span class="hljs-number">1</span>; l &lt;= degree; l++){

			<span class="hljs-keyword">var</span> ind = k-degree+l;
			<span class="hljs-keyword">var</span> alfa = knots_post[k+l] - knots_to_insert[j];

			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(alfa) &lt; verb.EPSILON){
				control_points_post[ind-<span class="hljs-number">1</span>] = control_points_post[ind];
			} <span class="hljs-keyword">else</span> {
				alfa = alfa / (knots_post[k+l] - knots[i-degree+l]);
				control_points_post[ind-<span class="hljs-number">1</span>] =
									numeric.add( 
										numeric.mul( alfa, control_points_post[ind-<span class="hljs-number">1</span>] ), 
										numeric.mul( (<span class="hljs-number">1.0</span> - alfa), control_points_post[ind]) 
									);
			}

		}

		knots_post[k] = knots_to_insert[j];
		k = k - <span class="hljs-number">1</span>;

	}

	<span class="hljs-keyword">return</span> { knots: knots_post, control_points: control_points_post };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-402">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-402">&#182;</a>
              </div>
              <h4 id="curve_knot_insert-degree-knots-control_points-u-r-">curve_knot_insert( degree, knots, control_points, u, r )</h4>
<p>Insert a knot along a rational curve.  Note that this algorithm only works
for r + s &lt;= degree, where s is the initial multiplicity (number of duplicates) of the knot.</p>
<p>Corresponds to algorithm A5.1 (Piegl &amp; Tiller)</p>
<p>Use the curve_knot_refine for applications like curve splitting.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, array of control points</li>
<li><em>Number</em>, parameter at which to insert the knot</li>
<li><em>Number</em>, number of times to insert the knot</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em> the new curve, defined by knots and control_points</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.curve_knot_insert = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, u, r )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-403">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-403">&#182;</a>
              </div>
              <p>num_pts is num control points for the initial curve
k is the span on which the knots are inserted
s is the initial multiplicity of the knot
r is the number of times to insert the knot
control_points is initial set of control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">var</span> s = <span class="hljs-number">0</span>; <span class="hljs-comment">// assume original multiplicity is 0 - TODO add check for multiplicity in knots</span>

	<span class="hljs-keyword">var</span> num_pts = control_points.length
		, k = verb.eval.knot_span( degree, u, knots ) <span class="hljs-comment">// the span in which the knot will be inserted</span>
		, num_pts_post = num_pts + r <span class="hljs-comment">// a new control pt for every new knot    </span>
		, control_points_temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( degree - s )  
		, knots_post = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( knots.length + r )  <span class="hljs-comment">// r new knots</span>
		, control_points_post = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( num_pts_post ) 
		, i = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-404">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-404">&#182;</a>
              </div>
              <p>new knot vector</p>

            </div>
            
        </li>
        
        
        <li id="section-405">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-405">&#182;</a>
              </div>
              <p>insert the k knots that will not be affected</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= k; i++) {
			knots_post[i] = knots[i];
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-406">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-406">&#182;</a>
              </div>
              <p>insert the new repeat knots</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= r; i++) {
			knots_post[k+i] = u; 
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-407">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-407">&#182;</a>
              </div>
              <p>insert the rest of the knots</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (i = k+<span class="hljs-number">1</span>; i &lt; knots.length; i++) {
			knots_post[i+r] = knots[i];
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-408">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-408">&#182;</a>
              </div>
              <p>control point generation</p>

            </div>
            
        </li>
        
        
        <li id="section-409">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-409">&#182;</a>
              </div>
              <p>copy the original control points before the insertion span</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= k - degree; i++) {
			control_points_post[i] = control_points[i]; 
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-410">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-410">&#182;</a>
              </div>
              <p>copy the original controls after the insertion span</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (i = k-s; i &lt; num_pts; i++) {
			control_points_post[i+r] = control_points[i];
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-411">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-411">&#182;</a>
              </div>
              <p>collect the affected control points in this temporary array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= degree-s; i++) {
			control_points_temp[i] = control_points[k-degree+i];
		}

	<span class="hljs-keyword">var</span> L = <span class="hljs-number">0</span>
		, alpha = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-412">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-412">&#182;</a>
              </div>
              <p>insert knot r times</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt;= r; j++) {

		L = k-degree+j;

		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= degree-j-s; i++) {

			alpha = ( u - knots[L+i] ) / ( knots[i+k+<span class="hljs-number">1</span>] - knots[L+i] );

			control_points_temp[i] = 
				numeric.add( 
					numeric.mul( alpha, control_points_temp[i+<span class="hljs-number">1</span>] ), 
					numeric.mul( (<span class="hljs-number">1.0</span> - alpha), control_points_temp[i]) 
				);


		}

		control_points_post[ L ] = control_points_temp[<span class="hljs-number">0</span>];
		control_points_post[k+r-j-s] = control_points_temp[degree-j-s];

	}</pre></div></div>
            
        </li>
        
        
        <li id="section-413">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-413">&#182;</a>
              </div>
              <p>not so confident about this part</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (i = L+<span class="hljs-number">1</span>; i &lt; k-s; i++) {
		control_points_post[i] = control_points_temp[ i - L ];
	}

	<span class="hljs-keyword">return</span> { knots: knots_post, control_points: control_points_post };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-414">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-414">&#182;</a>
              </div>
              <h4 id="surface_curvature-degree_u-knots_u-degree_v-knots_v-control_points-u-v-options-">surface_curvature( degree_u, knots_u, degree_v, knots_v, control_points, u, v, options )</h4>
<p>Compute the gaussian curvature on a non-uniform, non-rational B spline surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run alonsg the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the derivatives</li>
<li><em>Number</em>, v parameter at which to evaluate the derivatives</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.rational_surface_curvature = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points, u, v )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-415">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-415">&#182;</a>
              </div>
              <p>compute the first fundamental form</p>

            </div>
            
        </li>
        
        
        <li id="section-416">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-416">&#182;</a>
              </div>
              <p>symmetric matrix where</p>
<p>I = [ E F; F G ]</p>
<p>where:</p>
<p>E = Xu <em> Xu
F = Xu </em> Xv
G = Xv * Xv</p>

            </div>
            
        </li>
        
        
        <li id="section-417">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-417">&#182;</a>
              </div>
              <p>second fundamental form (shape operator)</p>

            </div>
            
        </li>
        
        
        <li id="section-418">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-418">&#182;</a>
              </div>
              <p>symmetric matrix where</p>
<p>II = [ L M; M N ]</p>
<p>where:</p>
<p>L = Xuu <em> n
M = Xuv </em> n
N = Xvv * n</p>

            </div>
            
        </li>
        
        
        <li id="section-419">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-419">&#182;</a>
              </div>
              <p>principal curvatures are the eigenvalues of the second fundamental form</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	<span class="hljs-keyword">var</span> derivs = verb.eval.rational_surface_derivs( 	degree_u, 
															knots_u, 
															degree_v, 
															knots_v, 
															homo_control_points, 
															<span class="hljs-number">2</span>, u, v );</pre></div></div>
            
        </li>
        
        
        <li id="section-420">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-420">&#182;</a>
              </div>
              <p>structure of the derivatives</p>

            </div>
            
        </li>
        
        
        <li id="section-421">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-421">&#182;</a>
              </div>
              <p>pos  du  vuu
dv   duv
dvv </p>

            </div>
            
            <div class="content"><div class='highlight'><pre> 
  <span class="hljs-keyword">var</span> du = derivs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];
  <span class="hljs-keyword">var</span> dv = derivs[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
  <span class="hljs-keyword">var</span> duu = derivs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];
  <span class="hljs-keyword">var</span> dvv = derivs[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>];
  <span class="hljs-keyword">var</span> duv = derivs[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];

  <span class="hljs-keyword">var</span> n = numeric.cross( du, dv );
  <span class="hljs-keyword">var</span> L = numeric.dot( duu, n );
  <span class="hljs-keyword">var</span> M = numeric.dot( duv, n );
  <span class="hljs-keyword">var</span> N = numeric.dot( dvv, n );

  <span class="hljs-keyword">var</span> shapeOperator = [ [ L, M ], [ M, N ] ];

	<span class="hljs-keyword">var</span> eigs = numeric.eig( shapeOperator );</pre></div></div>
            
        </li>
        
        
        <li id="section-422">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-422">&#182;</a>
              </div>
              <p>contains: lambda - x
                 E - x</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	
	<span class="hljs-keyword">var</span> k1 = eigs.lambda.x[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">var</span> k2 = eigs.lambda.x[<span class="hljs-number">1</span>];
	<span class="hljs-keyword">var</span> mean = <span class="hljs-number">0.5</span> * ( k1 + k2 );
	<span class="hljs-keyword">var</span> gaussian = k1 * k2;
	<span class="hljs-keyword">var</span> p1 = numeric.add( numeric.mul( eigs.E.x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], du ), numeric.mul( eigs.E.x[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], dv ) );
	<span class="hljs-keyword">var</span> p2 = numeric.add( numeric.mul( eigs.E.x[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], du ), numeric.mul( eigs.E.x[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dv ) );

	<span class="hljs-keyword">return</span> { point: derivs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], normal: n, mean: mean, gaussian: gaussian, shapeOperator: shapeOperator, k1: k1, k2: k2, p1: p1, p2: p2, p1p : eigs.E.x[<span class="hljs-number">0</span>], p2p: eigs.E.x[<span class="hljs-number">1</span>]  };

};</pre></div></div>
            
        </li>
        
        
        <li id="section-423">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-423">&#182;</a>
              </div>
              <h4 id="rational_surface_derivs-degree_u-knots_u-degree_v-knots_v-homo_control_points-num_derivs-u-v-">rational_surface_derivs( degree_u, knots_u, degree_v, knots_v, homo_control_points, num_derivs, u, v)</h4>
<p>Compute the derivatives at a point on a NURBS surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the derivatives</li>
<li><em>Number</em>, v parameter at which to evaluate the derivatives</li>
<li><em>Array</em>, 1d array of control point weights </li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.rational_surface_derivs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points, num_derivs, u, v)</span> </span>{

	<span class="hljs-keyword">var</span> SKL_homo = verb.eval.surface_derivs( degree_u, knots_u, degree_v, knots_v, homo_control_points, num_derivs, u, v )
		, ders = verb.eval.separate_homo_derivs_2d( SKL_homo )
		, Aders = ders[<span class="hljs-number">0</span>]
		, wders = ders[<span class="hljs-number">1</span>]
		, k = <span class="hljs-number">0</span>
		, i  = <span class="hljs-number">0</span>
		, j = <span class="hljs-number">0</span>
		, l = <span class="hljs-number">0</span>
		, SKL = []
		, dim = Aders[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].length;

	<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt;= num_derivs; k++) {
		SKL.push([]);

		<span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>; l &lt;= num_derivs-k; l++) {

			<span class="hljs-keyword">var</span> v = Aders[k][l];
			<span class="hljs-keyword">for</span> (j=<span class="hljs-number">1</span>; j &lt;= l; j++) {
				v = numeric.sub( v, numeric.mul( numeric.mul( binomial.get(l, j), wders[<span class="hljs-number">0</span>][j] ), SKL[k][l-j] ) );
			}

			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= k; i++) {
				v = numeric.sub( v, numeric.mul( numeric.mul( binomial.get(k, i), wders[i][<span class="hljs-number">0</span>] ), SKL[k-i][l] ) );
				
				<span class="hljs-keyword">var</span> v2 = verb.eval.zeros_1d(dim);

				<span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= l; j++) {
					v2 = numeric.add( v2, numeric.mul( numeric.mul( binomial.get(l, j), wders[i][j] ), SKL[k-i][l-j] ) );
				}

				v = numeric.sub( v, numeric.mul( binomial.get(k, i), v2) );

			}
			SKL[k].push( numeric.mul(<span class="hljs-number">1</span>/wders[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], v )); <span class="hljs-comment">// demogenize</span>

		}
	}

	<span class="hljs-keyword">return</span> SKL;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-424">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-424">&#182;</a>
              </div>
              <h4 id="rational_surface_point-degree_u-knots_u-degree_v-knots_v-homo_control_points-u-v-">rational_surface_point( degree_u, knots_u,  degree_v, knots_v, homo_control_points, u, v )</h4>
<p>Compute a point on a NURBS surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points (tensor), top to bottom is increasing u direction, left to right is increasing v direction,
and where each control point is an array of length (dim+1)</li>
<li><em>Number</em>, u parameter at which to evaluate the surface point</li>
<li><em>Number</em>, v parameter at which to evaluate the surface point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.rational_surface_point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u,  degree_v, knots_v, homo_control_points, u, v )</span> </span>{

	<span class="hljs-keyword">return</span> verb.eval.dehomogenize( verb.eval.surface_point( degree_u, knots_u,  degree_v, knots_v, homo_control_points, u, v ) );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-425">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-425">&#182;</a>
              </div>
              <p>`</p>
<h4 id="rational_curve_derivs-degree-knots-homo_control_points-u-num_derivs-">rational_curve_derivs( degree, knots, homo_control_points, u, num_derivs )</h4>
<p>Determine the derivatives of a NURBS curve at a given parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi)</li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.rational_curve_derivs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, homo_control_points, u, num_derivs )</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-426">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-426">&#182;</a>
              </div>
              <p>compute the derivatives of the control points
separate derivative array into two</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> ders = verb.eval.separate_homo_derivs_1d( verb.eval.curve_derivs( degree, knots, homo_control_points, u, num_derivs ) )
		, Aders = ders[<span class="hljs-number">0</span>]
		, wders = ders[<span class="hljs-number">1</span>]
		, k = <span class="hljs-number">0</span>
		, i  = <span class="hljs-number">0</span>
		, CK = [];

	<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt;= num_derivs; k++) {
		<span class="hljs-keyword">var</span> v = Aders[k];

		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= k; i++) {
			v = numeric.sub( v, numeric.mul( numeric.mul( binomial.get(k, i), wders[i] ), CK[k-i] ) );
		}
		CK.push( numeric.mul(<span class="hljs-number">1</span>/wders[<span class="hljs-number">0</span>], v )); <span class="hljs-comment">// demogenize</span>
	}

	<span class="hljs-keyword">return</span> CK;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-427">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-427">&#182;</a>
              </div>
              <h4 id="separate_homo_derivs_1d-ck-">separate_homo_derivs_1d( ck )</h4>
<p>Separate the array of derivatives into the A(u) component and w(u), i.e. the weight and everything else without dehomogenization</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 1d array of homogeneous derivatives</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an array with Aders and wders as element 0 and 1, respectively</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.separate_homo_derivs_1d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( CK )</span> </span>{

	<span class="hljs-keyword">var</span> dim = CK[<span class="hljs-number">0</span>].length
		, last = dim-<span class="hljs-number">1</span>
		, Aders = []
		, wders = [];

	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = CK.length; i &lt; l; i++ ) {
		Aders.push( CK[i].slice(<span class="hljs-number">0</span>, last) );
		wders.push( CK[i][last] );
	}

	<span class="hljs-keyword">return</span> [Aders, wders];

};</pre></div></div>
            
        </li>
        
        
        <li id="section-428">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-428">&#182;</a>
              </div>
              <h4 id="separate_homo_derivs_2d-skl-">separate_homo_derivs_2d( skl )</h4>
<p>Separate the array of derivatives into the A(u) component and w(u), i.e. the weight and everything else without dehomogenization</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 2d array of homogeneous derivatives</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an array with Aders and wders as element 0 and 1, respectively</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.separate_homo_derivs_2d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( SKL )</span> </span>{

	<span class="hljs-keyword">var</span> Aders = []
		, wders = [];

	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = SKL.length; i &lt; l; i++ ) {
		<span class="hljs-keyword">var</span> CK = verb.eval.separate_homo_derivs_1d( SKL[i] );
		Aders.push( CK[<span class="hljs-number">0</span>] );
		wders.push( CK[<span class="hljs-number">1</span>] );
	}

	<span class="hljs-keyword">return</span> [Aders, wders];

};</pre></div></div>
            
        </li>
        
        
        <li id="section-429">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-429">&#182;</a>
              </div>
              <h4 id="rational_curve_point-degree-knots-homo_control_points-u-">rational_curve_point( degree, knots, homo_control_points, u)</h4>
<p>Compute a point on a NURBS curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi)</li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.rational_curve_point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, homo_control_points, u)</span> </span>{

	<span class="hljs-keyword">return</span> verb.eval.dehomogenize( verb.eval.curve_point( degree, knots, homo_control_points, u) );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-430">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-430">&#182;</a>
              </div>
              <h4 id="dehomogenize-homo_point-">dehomogenize( homo_point )</h4>
<p>Dehomogenize a point </p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, a point represented by an array (wi*pi, wi) with length (dim+1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array pi with length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.dehomogenize = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( homo_point )</span> </span>{

	<span class="hljs-keyword">var</span> dim = homo_point.length
		, point = []
		, wt = homo_point[dim-<span class="hljs-number">1</span>];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; homo_point.length-<span class="hljs-number">1</span>;i++)
		point.push( homo_point[i] / wt );

	<span class="hljs-keyword">return</span> point;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-431">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-431">&#182;</a>
              </div>
              <h4 id="weights_1d-homo_points-">weights_1d( homo_points )</h4>
<p>Obtain the weight from a collection of points in homogeneous space, assuming all
are the same dimension</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of points represented by an array (wi*pi, wi) with length (dim+1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array pi with length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.weight_1d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( homo_points )</span> </span>{

	<span class="hljs-keyword">var</span> dim = homo_points[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;

	<span class="hljs-keyword">return</span> homo_points.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span>{ <span class="hljs-keyword">return</span> x[dim]; });

};</pre></div></div>
            
        </li>
        
        
        <li id="section-432">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-432">&#182;</a>
              </div>
              <h4 id="weights_2d-homo_points-">weights_2d( homo_points )</h4>
<p>Obtain the weight from a collection of points in homogeneous space, assuming all
are the same dimension</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of arrays of of points represented by an array (wi*pi, wi) with length (dim+1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>,  array of arrays of points, each represented by an array pi with length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.weight_2d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( homo_points )</span> </span>{

	<span class="hljs-keyword">return</span> homo_points.map(verb.eval.weight_1d);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-433">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-433">&#182;</a>
              </div>
              <h4 id="dehomogenize_1d-homo_points-">dehomogenize_1d( homo_points )</h4>
<p>Dehomogenize a point </p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of points represented by an array (wi*pi, wi) with length (dim+1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an array of points, each of length dim</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.dehomogenize_1d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( homo_points )</span> </span>{

	<span class="hljs-keyword">return</span> homo_points.map(verb.eval.dehomogenize);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-434">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-434">&#182;</a>
              </div>
              <h4 id="dehomogenize_2d-homo_points-">dehomogenize_2d( homo_points )</h4>
<p>Dehomogenize a 2d array of pts </p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of arrays of points represented by an array (wi*pi, wi) with length (dim+1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, array of arrays of points, each of length dim</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.dehomogenize_2d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( homo_points )</span> </span>{

	<span class="hljs-keyword">return</span> homo_points.map(verb.eval.dehomogenize_1d);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-435">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-435">&#182;</a>
              </div>
              <h4 id="homogenize_1d-control_points-weights-">homogenize_1d( control_points, weights)</h4>
<p>Transform a 1d array of points into their homogeneous equivalents</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 1d array of control points, (actually a 2d array of size (m x dim) )</li>
<li><em>Array</em>, array of control point weights, the same size as the array of control points (m x 1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 1d array of control points where each point is (wi*pi, wi) where wi 
i the ith control point weight and pi is the ith control point, 
hence the dimension of the point is dim + 1</li>
</ul>

            </div>
            
        </li>
        
        
        <li id="section-436">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-436">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.homogenize_1d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( control_points, weights)</span> </span>{

	<span class="hljs-keyword">var</span> rows = control_points.length
		, dim = control_points[<span class="hljs-number">0</span>].length
		, k = <span class="hljs-number">0</span>
		, homo_control_points = []
		, wt = <span class="hljs-number">0</span>
		, ref_pt = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) {

		<span class="hljs-keyword">var</span> pt = [];
		ref_pt = control_points[i];
		wt = weights[i];

		<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; dim; k++) {
			pt.push( ref_pt[k] * wt );
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-437">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-437">&#182;</a>
              </div>
              <p>append the weight</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		pt.push(wt);

		homo_control_points.push(pt);
	}

	<span class="hljs-keyword">return</span> homo_control_points;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-438">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-438">&#182;</a>
              </div>
              <h4 id="homogenize_2d-control_points-weights-">homogenize_2d( control_points, weights)</h4>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 2d array of control points, (actually a 3d array of size m x n x dim)</li>
<li><em>Array</em>, array of control point weights, the same size as the control points array (m x n x 1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 1d array of control points where each point is (wi*pi, wi) where wi 
i the ith control point weight and pi is the ith control point, the size is 
(m x n x dim+1)</li>
</ul>

            </div>
            
        </li>
        
        
        <li id="section-439">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-439">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.homogenize_2d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( control_points, weights)</span> </span>{

	<span class="hljs-keyword">var</span> rows = control_points.length
		, cols = control_points[<span class="hljs-number">0</span>].length
		, dim = control_points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].length
		, j = <span class="hljs-number">0</span>
		, k = <span class="hljs-number">0</span>
		, homo_control_points = []
		, wt = <span class="hljs-number">0</span>
		, ref_pt = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) {
		homo_control_points.push( verb.eval.homogenize_1d(control_points[i], weights[i]) );
	}

	<span class="hljs-keyword">return</span> homo_control_points;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-440">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-440">&#182;</a>
              </div>
              <h4 id="surface_derivs-degree_u-knots_u-degree_v-knots_v-control_points-num_derivatives-u-v-">surface_derivs( degree_u, knots_u, degree_v, knots_v, control_points, num_derivatives, u, v )</h4>
<p>Compute the derivatives on a non-uniform, non-rational B spline surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the derivatives</li>
<li><em>Number</em>, v parameter at which to evaluate the derivatives</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.surface_derivs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, control_points, num_derivatives, u, v )</span> </span>{

	<span class="hljs-keyword">var</span> n = knots_u.length - degree_u - <span class="hljs-number">2</span>
		, m = knots_v.length - degree_v - <span class="hljs-number">2</span>;

	<span class="hljs-keyword">return</span> verb.eval.surface_derivs_given_n_m( n, degree_u, knots_u, m, degree_v, knots_v, control_points, num_derivatives, u, v );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-441">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-441">&#182;</a>
              </div>
              <h4 id="surface_derivs_given_n_m-n-degree_u-knots_u-m-degree_v-knots_v-control_points-num_derivatives-u-v-">surface_derivs_given_n_m( n, degree_u, knots_u, m, degree_v, knots_v, control_points, num_derivatives, u, v )</h4>
<p>Compute the derivatives on a non-uniform, non-rational B spline surface 
(corresponds to algorithm 3.6 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions in u dir - 1 = knots_u.length - degree_u - 2</li>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer number of basis functions in v dir - 1 = knots_u.length - degree_u - 2</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the derivatives</li>
<li><em>Number</em>, v parameter at which to evaluate the derivatives</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.surface_derivs_given_n_m = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( n, degree_u, knots_u, m, degree_v, knots_v, control_points, num_derivatives, u, v )</span> </span>{

	<span class="hljs-keyword">if</span> ( verb.eval.are_valid_relations(degree_u, control_points.length, knots_u.length ) === <span class="hljs-literal">false</span> ||
		verb.eval.are_valid_relations(degree_v, control_points[<span class="hljs-number">0</span>].length, knots_v.length ) === <span class="hljs-literal">false</span> ) {
		<span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Invalid relations between control points, knot vector, and n'</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">var</span> dim = control_points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].length
		, du = <span class="hljs-built_in">Math</span>.min(num_derivatives, degree_u)
		, dv = <span class="hljs-built_in">Math</span>.min(num_derivatives, degree_v)
		, SKL = verb.eval.zeros_3d( du+<span class="hljs-number">1</span>, dv+<span class="hljs-number">1</span>, dim )
		, knot_span_index_u = verb.eval.knot_span_given_n( n, degree_u, u, knots_u )
		, knot_span_index_v = verb.eval.knot_span_given_n( m, degree_v, v, knots_v )
		, uders = verb.eval.deriv_basis_functions_given_n_i( knot_span_index_u, u, degree_u, n, knots_u )  
		, vders = verb.eval.deriv_basis_functions_given_n_i( knot_span_index_v, v, degree_v, m, knots_v )
		, temp = verb.eval.zeros_2d( degree_v+<span class="hljs-number">1</span>, dim )
		, k = <span class="hljs-number">0</span>
		, s = <span class="hljs-number">0</span>
		, r = <span class="hljs-number">0</span>
		, l = <span class="hljs-number">0</span>
		, dd = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt;= du; k++) {	
		<span class="hljs-keyword">for</span> (s = <span class="hljs-number">0</span>; s &lt;= degree_v; s++) {		
			temp[s] = verb.eval.zeros_1d( dim );

			<span class="hljs-keyword">for</span> (r = <span class="hljs-number">0</span>; r &lt;= degree_u; r++) {	
				temp[s] = numeric.add( temp[s], numeric.mul( uders[k][r], control_points[knot_span_index_u-degree_u+r][knot_span_index_v-degree_v+s]) );
			}
		}

		dd = <span class="hljs-built_in">Math</span>.min(num_derivatives-k, dv);

		<span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>; l &lt;= dd; l++) {	
			SKL[k][l] = verb.eval.zeros_1d( dim );

			<span class="hljs-keyword">for</span> (s = <span class="hljs-number">0</span>; s &lt;= degree_v; s++) {	
				SKL[k][l] = numeric.add( SKL[k][l], numeric.mul( vders[l][s], temp[s] ) );
			}
		}
	}

	<span class="hljs-keyword">return</span> SKL;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-442">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-442">&#182;</a>
              </div>
              <h4 id="surface_point-degree_u-knots_u-degree_v-knots_v-control_points-u-v-">surface_point( degree_u, knots_u, degree_v, knots_v, control_points, u, v)</h4>
<p>Compute a point on a non-uniform, non-rational B-spline surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the surface point</li>
<li><em>Number</em>, v parameter at which to evaluate the surface point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.surface_point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, control_points, u, v)</span> </span>{

	<span class="hljs-keyword">var</span> n = knots_u.length - degree_u - <span class="hljs-number">2</span>
		, m = knots_v.length - degree_v - <span class="hljs-number">2</span>;

	<span class="hljs-keyword">return</span> 	verb.eval.surface_point_given_n_m( n, degree_u, knots_u, m, degree_v, knots_v, control_points, u, v );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-443">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-443">&#182;</a>
              </div>
              <h4 id="volume_point-degree_u-knots_u-degree_v-knots_v-degree_w-knots_w-control_points-u-v-w-">volume_point( degree_u, knots_u, degree_v, knots_v, degree_w, knots_w, control_points, u, v, w  )</h4>
<p>Compute a point in a non-uniform, non-rational B spline volume</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions in u dir - 1 = knots_u.length - degree_u - 2</li>
<li><em>Number</em>, integer degree of volume in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer number of basis functions in v dir - 1 = knots_v.length - degree_v - 2</li>
<li><em>Number</em>, integer degree of volume in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Number</em>, integer number of basis functions in w dir - 1 = knots_w.length - degree_w - 2</li>
<li><em>Number</em>, integer degree of volume in w direction</li>
<li><em>Array</em>, array of nondecreasing knot values in w direction</li>
<li><em>Array</em>, 4d array of control points where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the volume point</li>
<li><em>Number</em>, v parameter at which to evaluate the volume point</li>
<li><em>Number</em>, w parameter at which to evaluate the volume point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.volume_point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, degree_w, knots_w, control_points, u, v, w )</span> </span>{

	<span class="hljs-keyword">var</span> n = knots_u.length - degree_u - <span class="hljs-number">2</span>
		, m = knots_v.length - degree_v - <span class="hljs-number">2</span>
		, l = knots_w.length - degree_w - <span class="hljs-number">2</span>;

	<span class="hljs-keyword">return</span> verb.eval.volume_point_given_n_m_l( n, degree_u, knots_u, m, degree_v, knots_v, l, degree_w, knots_w, control_points, u, v, w );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-444">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-444">&#182;</a>
              </div>
              <h4 id="volume_point_given_n_m_l-n-degree_u-knots_u-m-degree_v-knots_v-l-degree_w-knots_w-control_points-u-v-w-">volume_point_given_n_m_l( n, degree_u, knots_u, m, degree_v, knots_v, l, degree_w, knots_w, control_points, u, v, w )</h4>
<p>Compute a point in a non-uniform, non-rational B spline volume</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions in u dir - 1 = knots_u.length - degree_u - 2</li>
<li><em>Number</em>, integer degree of volume in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer number of basis functions in v dir - 1 = knots_v.length - degree_v - 2</li>
<li><em>Number</em>, integer degree of volume in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Number</em>, integer number of basis functions in w dir - 1 = knots_w.length - degree_w - 2</li>
<li><em>Number</em>, integer degree of volume in w direction</li>
<li><em>Array</em>, array of nondecreasing knot values in w direction</li>
<li><em>Array</em>, 4d array of control points where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the volume point</li>
<li><em>Number</em>, v parameter at which to evaluate the volume point</li>
<li><em>Number</em>, w parameter at which to evaluate the volume point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.volume_point_given_n_m_l = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( n, degree_u, knots_u, m, degree_v, knots_v, l, degree_w, knots_w, control_points, u, v, w )</span> </span>{

	<span class="hljs-keyword">if</span> ( 	!verb.eval.are_valid_relations(degree_u, control_points.length, knots_u.length ) ||
				!verb.eval.are_valid_relations(degree_v, control_points[<span class="hljs-number">0</span>].length, knots_v.length ) || 
				!verb.eval.are_valid_relations(degree_w, control_points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].length, knots_w.length ) ) {
		<span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Invalid relations between control points and knot vector'</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">var</span> dim = control_points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].length

		, knot_span_index_u = verb.eval.knot_span_given_n( n, degree_u, u, knots_u )
		, knot_span_index_v = verb.eval.knot_span_given_n( m, degree_v, v, knots_v )
		, knot_span_index_w = verb.eval.knot_span_given_n( l, degree_w, w, knots_w )
		, u_basis_vals = verb.eval.basis_functions_given_knot_span_index( knot_span_index_u, u, degree_u, knots_u )
		, v_basis_vals = verb.eval.basis_functions_given_knot_span_index( knot_span_index_v, v, degree_v, knots_v )
		, w_basis_vals = verb.eval.basis_functions_given_knot_span_index( knot_span_index_w, w, degree_w, knots_w )
		, uind = knot_span_index_u - degree_u
		, vind = knot_span_index_v
		, wind = knot_span_index_w
		, position = verb.eval.zeros_1d( dim )
		, temp = verb.eval.zeros_1d( dim )
		, temp2 = verb.eval.zeros_1d( dim )
		, j = <span class="hljs-number">0</span>
		, k = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= degree_w; i++){

		temp2 = verb.eval.zeros_1d( dim );
		wind = knot_span_index_w - degree_w + i;

		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt;= degree_v; j++) {	

			temp = verb.eval.zeros_1d( dim );
			vind = knot_span_index_v  - degree_v + j;

			<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt;= degree_u; k++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-445">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-445">&#182;</a>
              </div>
              <p>sample u isoline</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				temp = numeric.add( temp, numeric.mul( u_basis_vals[k], control_points[uind+k][vind][wind] ));
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-446">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-446">&#182;</a>
              </div>
              <p>add weighted contribution of u isoline</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			temp2 = numeric.add( temp2, numeric.mul( v_basis_vals[j], temp ) );
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-447">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-447">&#182;</a>
              </div>
              <p>add weighted contribution from uv isosurfaces</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		position = numeric.add( position,  numeric.mul( w_basis_vals[i], temp2 ) );

	}

	<span class="hljs-keyword">return</span> position;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-448">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-448">&#182;</a>
              </div>
              <h4 id="surface_point_given_n_m-n-degree_u-knots_u-m-degree_v-knots_v-control_points-u-v-">surface_point_given_n_m( n, degree_u, knots_u, m, degree_v, knots_v, control_points, u, v )</h4>
<p>Compute a point on a non-uniform, non-rational B spline surface
(corresponds to algorithm 3.5 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions in u dir - 1 = knots_u.length - degree_u - 2</li>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the surface point</li>
<li><em>Number</em>, v parameter at which to evaluate the surface point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.surface_point_given_n_m = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( n, degree_u, knots_u, m, degree_v, knots_v, control_points, u, v )</span> </span>{

	<span class="hljs-keyword">if</span> ( verb.eval.are_valid_relations(degree_u, control_points.length, knots_u.length ) === <span class="hljs-literal">false</span> ||
		verb.eval.are_valid_relations(degree_v, control_points[<span class="hljs-number">0</span>].length, knots_v.length ) === <span class="hljs-literal">false</span> ) {
		<span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Invalid relations between control points, knot vector, and n'</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">var</span> dim = control_points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].length
		, knot_span_index_u = verb.eval.knot_span_given_n( n, degree_u, u, knots_u )
		, knot_span_index_v = verb.eval.knot_span_given_n( m, degree_v, v, knots_v )
		, u_basis_vals = verb.eval.basis_functions_given_knot_span_index( knot_span_index_u, u, degree_u, knots_u )
		, v_basis_vals = verb.eval.basis_functions_given_knot_span_index( knot_span_index_v, v, degree_v, knots_v )
		, uind = knot_span_index_u - degree_u
		, vind = knot_span_index_v
		, position = verb.eval.zeros_1d( dim )
		, temp = verb.eval.zeros_1d( dim )
		, l = <span class="hljs-number">0</span>
		, k = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>; l &lt;= degree_v; l++) {	

		temp = verb.eval.zeros_1d( dim );
		vind = knot_span_index_v - degree_v + l;</pre></div></div>
            
        </li>
        
        
        <li id="section-449">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-449">&#182;</a>
              </div>
              <p>sample u isoline</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt;= degree_u; k++) {	
			temp = numeric.add( temp, numeric.mul( u_basis_vals[k], control_points[uind+k][vind]) );
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-450">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-450">&#182;</a>
              </div>
              <p>add point from u isoline</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		position = numeric.add( position, numeric.mul(v_basis_vals[l], temp) );
	}

	<span class="hljs-keyword">return</span> position;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-451">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-451">&#182;</a>
              </div>
              <h4 id="curve_derivs-degree-knots-control_points-u-num_derivs-">curve_derivs( degree, knots, control_points, u, num_derivs )</h4>
<p>Determine the derivatives of a non-uniform, non-rational B-spline curve at a given parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of control points, where each control point is an array of length (dim)  </li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.curve_derivs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, u, num_derivs )</span> </span>{

	<span class="hljs-keyword">var</span> n = knots.length - degree - <span class="hljs-number">2</span>;
	<span class="hljs-keyword">return</span> verb.eval.curve_derivs_given_n( n, degree, knots, control_points, u, num_derivs );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-452">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-452">&#182;</a>
              </div>
              <h4 id="curve_derivs_given_n-n-degree-knots-control_points-u-num_derivatives-">curve_derivs_given_n( n, degree, knots, control_points, u, num_derivatives )</h4>
<p>Determine the derivatives of a non-uniform, non-rational B-spline curve at a given parameter
(corresponds to algorithm 3.1 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions - 1 = knots.length - degree - 2</li>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of control points, where each control point is an array of length (dim)  </li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.curve_derivs_given_n = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( n, degree, knots, control_points, u, num_derivatives )</span> </span>{

	<span class="hljs-keyword">if</span> ( verb.eval.are_valid_relations(degree, control_points.length, knots.length ) === <span class="hljs-literal">false</span> ) {
		<span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Invalid relations between control points, knot vector, and n'</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">var</span> dim = control_points[<span class="hljs-number">0</span>].length
		, du = <span class="hljs-built_in">Math</span>.min(num_derivatives, degree)
		, CK = verb.eval.zeros_2d( du+<span class="hljs-number">1</span>, dim )
		, knot_span_index = verb.eval.knot_span_given_n( n, degree, u, knots )
		, nders = verb.eval.deriv_basis_functions_given_n_i( knot_span_index, u, degree, du, knots )
		, k = <span class="hljs-number">0</span>
		, j = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt;= du; k++) {	
		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt;= degree; j++) {
			CK[k] = numeric.add( CK[k], numeric.mul( nders[k][j], control_points[ knot_span_index - degree + j ] ) )
		}
	}
	<span class="hljs-keyword">return</span> CK;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-453">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-453">&#182;</a>
              </div>
              <h4 id="are_valid_relations-degree-num_control_points-knots_length-">are_valid_relations( degree, num_control_points, knots_length )</h4>
<p>Confirm the relations between degree (p), number of control points(n+1), and the number of knots (m+1)
via The NURBS Book (section 3.2, Second Edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Number</em>, integer number of control points</li>
<li><em>Number</em>, integer length of the knot vector (including duplicate knots)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Boolean</em>, whether the values are correct</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.are_valid_relations = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, num_control_points, knots_length )</span> </span>{
	<span class="hljs-keyword">return</span> ( num_control_points + degree + <span class="hljs-number">1</span> - knots_length ) === <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-454">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-454">&#182;</a>
              </div>
              <h4 id="curve_point-degree-knots-control_points-u-">curve_point( degree, knots, control_points, u)</h4>
<p>Compute a point on a non-uniform, non-rational b-spline curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of control points, where each control point is an array of length (dim)  </li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.curve_point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, u)</span> </span>{

	<span class="hljs-keyword">var</span> n = knots.length - degree - <span class="hljs-number">2</span>;
	<span class="hljs-keyword">return</span> verb.eval.curve_point_given_n( n, degree, knots, control_points, u);

}</pre></div></div>
            
        </li>
        
        
        <li id="section-455">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-455">&#182;</a>
              </div>
              <h4 id="curve_point_given_n-n-degree-knots-control_points-u-">curve_point_given_n( n, degree, knots, control_points, u)</h4>
<p>Compute a point on a non-uniform, non-rational b-spline curve
(corresponds to algorithm 3.1 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions - 1 = knots.length - degree - 2</li>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of control points, where each control point is an array of length (dim)  </li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.curve_point_given_n = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( n, degree, knots, control_points, u)</span> </span>{

	<span class="hljs-keyword">if</span> ( verb.eval.are_valid_relations(degree, control_points.length, knots.length ) === <span class="hljs-literal">false</span> ) {
		<span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Invalid relations between control points, knot vector, and n'</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">var</span> knot_span_index = verb.eval.knot_span_given_n( n, degree, u, knots )
		, basis_values = verb.eval.basis_functions_given_knot_span_index( knot_span_index, u, degree, knots ) 
		, position = verb.eval.zeros_1d( control_points[<span class="hljs-number">0</span>].length );

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt;= degree; j++ )	{
			position = numeric.add( position, numeric.mul( basis_values[j], control_points[ knot_span_index - degree + j ] ) );
		}

		<span class="hljs-keyword">return</span> position;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-456">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-456">&#182;</a>
              </div>
              <h4 id="zeros_1d-size-">zeros_1d(size)</h4>
<p>Generate a 1d array of zeros</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of rows</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 1d array of given size</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.zeros_1d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(size)</span> </span>{
  <span class="hljs-keyword">return</span> numeric.rep([size], <span class="hljs-number">0</span>);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-457">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-457">&#182;</a>
              </div>
              <h4 id="zeros_2d-rows-cols-">zeros_2d(rows, cols)</h4>
<p>Generate a 2D array of zeros</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of rows</li>
<li><em>Number</em>, integer number of columns</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 2d array of given size</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.zeros_2d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(rows, cols)</span> </span>{
  cols = cols &gt; <span class="hljs-number">0</span> ? cols : <span class="hljs-number">0</span>;
  rows = rows &gt; <span class="hljs-number">0</span> ? rows : <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> numeric.rep([rows, cols], <span class="hljs-number">0</span>);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-458">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-458">&#182;</a>
              </div>
              <h4 id="zeros_3d-rows-cols-dim-">zeros_3d(rows, cols, dim)</h4>
<p>Generate a 3D array of zeros</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of rows</li>
<li><em>Number</em>, integer number of columns</li>
<li><em>Number</em>, integer depth (i.e. dimension of arrays in 2d matrix)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 3d array of given size</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.zeros_3d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(rows, cols, dim)</span> </span>{
  cols = cols &gt; <span class="hljs-number">0</span> ? cols : <span class="hljs-number">0</span>;
  rows = rows &gt; <span class="hljs-number">0</span> ? rows : <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> numeric.rep([rows, cols, dim], <span class="hljs-number">0</span>);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-459">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-459">&#182;</a>
              </div>
              <h4 id="deriv_basis_functions-u-degree-knots-">deriv_basis_functions( u, degree, knots )</h4>
<p>Compute the non-vanishing basis functions and their derivatives</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, float parameter</li>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 2d array of basis and derivative values of size (n+1, p+1) The nth row is the nth derivative and the first row is made up of the basis function values.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.deriv_basis_functions = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, degree, knots )</span>
</span>{
	<span class="hljs-keyword">var</span> knot_span_index = verb.eval.knot_span( degree, u, knots )
		, m = knots.length - <span class="hljs-number">1</span>
		, n = m - degree - <span class="hljs-number">1</span>;

	<span class="hljs-keyword">return</span> verb.eval.deriv_basis_functions_given_n_i( knot_span_index, u, degree, n, knots );
}</pre></div></div>
            
        </li>
        
        
        <li id="section-460">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-460">&#182;</a>
              </div>
              <h4 id="deriv_basis_functions_given_n_i-knot_span_index-u-p-n-knots-">deriv_basis_functions_given_n_i( knot_span_index, u, p, n, knots )</h4>
<p>Compute the non-vanishing basis functions and their derivatives
(corresponds to algorithm 2.3 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer knot span index</li>
<li><em>Number</em>, float parameter</li>
<li><em>Number</em>, integer degree</li>
<li><em>Number</em>, integer number of basis functions - 1 = knots.length - degree - 2</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 2d array of basis and derivative values of size (n+1, p+1) The nth row is the nth derivative and the first row is made up of the basis function values.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.deriv_basis_functions_given_n_i = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( knot_span_index, u, p, n, knots )</span>
</span>{
	<span class="hljs-keyword">var</span> ndu = verb.eval.zeros_2d(p+<span class="hljs-number">1</span>, p+<span class="hljs-number">1</span>)
		, left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( p + <span class="hljs-number">1</span> )
		, right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( p + <span class="hljs-number">1</span> )
		, saved = <span class="hljs-number">0</span>
		, temp = <span class="hljs-number">0</span>
		, j = <span class="hljs-number">1</span>
		, r = <span class="hljs-number">0</span>;

	ndu[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1.0</span>;

	<span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt;= p; j++) {

		left[j] = u - knots[knot_span_index+<span class="hljs-number">1</span>-j];
		right[j] = knots[knot_span_index+j] - u;
		saved = <span class="hljs-number">0.0</span>;

		<span class="hljs-keyword">for</span> (r = <span class="hljs-number">0</span>; r &lt; j; r++) {

			ndu[j][r] = right[r+<span class="hljs-number">1</span>] + left[j-r];
			temp = ndu[r][j-<span class="hljs-number">1</span>] / ndu[j][r];

			ndu[r][j] = saved + right[r+<span class="hljs-number">1</span>]*temp;
			saved = left[j-r]*temp;

		}
		ndu[j][j] = saved;
	}


	<span class="hljs-keyword">var</span> ders = verb.eval.zeros_2d(n+<span class="hljs-number">1</span>, p+<span class="hljs-number">1</span>)
		, a = verb.eval.zeros_2d(<span class="hljs-number">2</span>, p+<span class="hljs-number">1</span>)
		, k = <span class="hljs-number">1</span>
		, s1 = <span class="hljs-number">0</span>
		, s2 = <span class="hljs-number">1</span>
		, d = <span class="hljs-number">0</span>
		, rk = <span class="hljs-number">0</span>
		, pk = <span class="hljs-number">0</span>
		, j1 = <span class="hljs-number">0</span>
		, j2 = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt;= p; j++) {
		ders[<span class="hljs-number">0</span>][j] = ndu[j][p];
	}

	<span class="hljs-keyword">for</span> (r = <span class="hljs-number">0</span>; r&lt;=p; r++) {
		s1 = <span class="hljs-number">0</span>;
		s2 = <span class="hljs-number">1</span>;
		a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1.0</span>;

		<span class="hljs-keyword">for</span> (k=<span class="hljs-number">1</span>; k&lt;=n ;k++)
		{
			d = <span class="hljs-number">0.0</span>;
			rk = r - k;
			pk = p - k;

			<span class="hljs-keyword">if</span> (r &gt;= k) {
				a[s2][<span class="hljs-number">0</span>] = a[s1][<span class="hljs-number">0</span>] / ndu[pk+<span class="hljs-number">1</span>][rk];
				d = a[s2][<span class="hljs-number">0</span>]*ndu[rk][pk];
			}

			<span class="hljs-keyword">if</span> (rk &gt;= -<span class="hljs-number">1</span>) {
				j1 = <span class="hljs-number">1</span>;
			} <span class="hljs-keyword">else</span> {
				j1 = -rk;
			}

			<span class="hljs-keyword">if</span> (r-<span class="hljs-number">1</span> &lt;= pk) {
				j2 = k-<span class="hljs-number">1</span>;
			} <span class="hljs-keyword">else</span> {
				j2 = p - r;
			}

			<span class="hljs-keyword">for</span> (j = j1; j &lt;= j2; j++) {
				a[s2][j] = ( a[s1][j] - a[s1][ j - <span class="hljs-number">1</span> ] ) / ndu[ pk + <span class="hljs-number">1</span> ][ rk + j ];
				d += a[s2][j]*ndu[rk+j][pk];
			}

			<span class="hljs-keyword">if</span> (r &lt;= pk)
			{
				a[s2][k] = -a[s1][k-<span class="hljs-number">1</span>]/ndu[pk+<span class="hljs-number">1</span>][r];
				d += a[s2][k] * ndu[r][pk];
			}

			ders[k][r] = d;
			j = s1;
			s1 = s2;
			s2 = j;
		}
	}

	r = p;
	<span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt;= n; k++) {
		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt;= p; j++) {
			ders[k][j] *= r;
		}
		r *= (p-k);
	}

	<span class="hljs-keyword">return</span> ders;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-461">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-461">&#182;</a>
              </div>
              <h4 id="basis_functions-u-degree-knots-">basis_functions( u, degree, knots )</h4>
<p>Compute the non-vanishing basis functions</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, float parameter</li>
<li><em>Number</em>, integer degree of function</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, list of non-vanishing basis functions</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.basis_functions = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, degree, knots )</span>
</span>{
	<span class="hljs-keyword">var</span> knot_span_index = verb.eval.knot_span(u, degree, knots);
	<span class="hljs-keyword">return</span> verb.eval.basis_functions_given_knot_span_index( knot_span_index, u, degree, knots );
};</pre></div></div>
            
        </li>
        
        
        <li id="section-462">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-462">&#182;</a>
              </div>
              <h4 id="basis_functions_given_knot_span_index-knot_span_index-u-degree-knots-">basis_functions_given_knot_span_index( knot_span_index, u, degree, knots )</h4>
<p>Compute the non-vanishing basis functions
(corresponds to algorithm 2.2 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer knot span index</li>
<li><em>Number</em>, float parameter</li>
<li><em>Number</em>, integer degree of function</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, list of non-vanishing basis functions</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.basis_functions_given_knot_span_index = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( knot_span_index, u, degree, knots )</span>
</span>{
	<span class="hljs-keyword">var</span> basis_functions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( degree + <span class="hljs-number">1</span> )
		, left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( degree + <span class="hljs-number">1</span> )
		, right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( degree + <span class="hljs-number">1</span> )
		, saved = <span class="hljs-number">0</span>
		, temp = <span class="hljs-number">0</span>;

	basis_functions[<span class="hljs-number">0</span>] = <span class="hljs-number">1.0</span>;

	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt;= degree; j++) {

		left[j] = u - knots[knot_span_index+<span class="hljs-number">1</span>-j];
		right[j] = knots[knot_span_index+j] - u;
		saved = <span class="hljs-number">0.0</span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> r = <span class="hljs-number">0</span>; r &lt; j; r++) {

			temp = basis_functions[r] / ( right[r+<span class="hljs-number">1</span>] + left[j-r] );
			basis_functions[r] = saved + right[r+<span class="hljs-number">1</span>]*temp;
			saved = left[j-r]*temp;

		}

		basis_functions[j] = saved;
	}

	<span class="hljs-keyword">return</span> basis_functions;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-463">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-463">&#182;</a>
              </div>
              <h4 id="knot_span-degree-u-knots-">knot_span( degree, u, knots )</h4>
<p>Find the span on the knot vector without supplying n</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of function</li>
<li><em>Number</em>, float parameter</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, the index of the knot span</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.knot_span = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, u, knots )</span>
</span>{

	<span class="hljs-keyword">var</span> m = knots.length - <span class="hljs-number">1</span>
		, n = m - degree - <span class="hljs-number">1</span>;

	<span class="hljs-keyword">return</span> verb.eval.knot_span_given_n(n, degree, u, knots);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-464">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-464">&#182;</a>
              </div>
              <h4 id="knot_span_given_n-n-degree-u-knots-">knot_span_given_n( n, degree, u, knots )</h4>
<p>Find the span on the knot vector knots of the given parameter
(corresponds to algorithm 2.1 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions - 1 = knots.length - degree - 2</li>
<li><em>Number</em>, integer degree of function</li>
<li><em>Number</em>, float parameter</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, the index of the knot span</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
verb.eval.knot_span_given_n = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( n, degree, u, knots )</span>
</span>{
	<span class="hljs-keyword">if</span> ( u &gt;= knots[n+<span class="hljs-number">1</span>] )
	{
		<span class="hljs-keyword">return</span> n;
	}

	<span class="hljs-keyword">if</span> ( u &lt; knots[degree] )
	{
		<span class="hljs-keyword">return</span> degree;
	}

	<span class="hljs-keyword">var</span> low = degree
		, high = n+<span class="hljs-number">1</span>
		, mid = <span class="hljs-built_in">Math</span>.floor( (low + high) / <span class="hljs-number">2</span> );

	<span class="hljs-keyword">while</span>( u &lt; knots[ mid ] || u &gt;= knots[ mid + <span class="hljs-number">1</span> ] )
	{
		<span class="hljs-keyword">if</span> ( u &lt; knots[ mid ] )
		{
			high = mid;
		}
		<span class="hljs-keyword">else</span> 
		{
			low = mid;
		}
		mid = <span class="hljs-built_in">Math</span>.floor( (low + high) / <span class="hljs-number">2</span> );
	}

	<span class="hljs-keyword">return</span> mid;

};</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
