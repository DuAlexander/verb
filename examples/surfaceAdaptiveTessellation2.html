<!DOCTYPE html>
<html>
<head>
    <title>Surface Bezier Subdivision</title>

    <script src="../build/js/verb.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/verbToThreeConversion.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/codemirror.js"></script>
    <script src="js/javascript.js"></script>
    <script src="js/threeBasic.js"></script>

    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" href="css/codemirror.css">
    <link rel="stylesheet" href="css/example.css">
    <link rel="stylesheet" href="css/colorforth.css">
</head>
<body>

<div id="button">Show/Hide Code</div>
<div id="viewer" class="col">
    <div id="title"></div>
</div>
<div id="code-container" class="col scroll-y"></div>

</body>
<script id="script">
	setupScene();

    function asVector3(pts){
        return pts.map(function(x){
            return new THREE.Vector3(x[0],x[1],x[2]);
        });
    }

    function asGeometry(threePts){
        var geometry = new THREE.Geometry();
        geometry.vertices.push.apply( geometry.vertices, threePts );
        return geometry;
    }

    function tessellateSurface(srf, a, b) {

        var tess = verb.eval.Tess.rationalSurfaceNaive( srf, a, b );

        var geometry = new THREE.Geometry();
        var threePts = asVector3( tess.points );

        geometry.vertices.push.apply( geometry.vertices, threePts );

        var threeFaces = tess.faces.map(function(faceIndices){

            var normals = faceIndices.map(function(x){
                var vn = tess.normals[x];
                return new THREE.Vector3( vn[0], vn[1], vn[2] );
            });

            return new THREE.Face3(faceIndices[0],faceIndices[1],faceIndices[2], normals);
        });

        geometry.faces.push.apply(geometry.faces, threeFaces);
        return geometry;
    }

    function getThreeMesh( tess ) {

        var geometry = new THREE.Geometry();
        var threePts = asVector3( tess.points );

        geometry.vertices.push.apply( geometry.vertices, threePts );



        var threeFaces = tess.faces.map(function(faceIndices){
            return new THREE.Face3(faceIndices[0],faceIndices[1],faceIndices[2]);
        });

        geometry.faces.push.apply(geometry.faces, threeFaces);

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();

        return geometry;
    }

    var degree = 3
        , knotsV = [0, 0, 0, 0, 0.333, 0.666, 1, 1, 1, 1]
        , knotsU = [0, 0, 0, 0, 0.5, 1, 1, 1, 1]
        , controlPoints = [
                    [ [0, 0, -10],  [10, 0, 0],     [20, 0, 0],     [30, 0, 0] ,    [40, 0, 0],     [50, 0, 0] ],
                    [ [0, -10, 0],  [10, -10, 1],  [20, -10, 1],  [30, -10, 0] ,  [40, -10, 0],   [50, -10, 0]    ],
                    [ [0, -20, 0],  [10, -20, 20],  [20, -20, 1],  [30, -20, 0] ,  [40, -20, -2],  [50, -20, 0]    ],
                    [ [0, -30, 0],  [10, -30, 0],   [20, -30, 0], [30, -30, 30] ,  [40, -30, 0],   [50, -30, 0]     ],
                    [ [0, -40, 0],  [10, -40, 0],   [20, -40, 0],   [30, -40, 4] ,  [40, -40, 0], [50, -40, 0]     ] ]
        , surface = new verb.core.NurbsSurfaceData( degree, degree, knotsU, knotsV, controlPoints );


    function getBezier(){

        var degree = 3
            , knots = [0, 0, 0, 0, 1, 1, 1, 1]
            , pts = [   [ [0, 0, 0],  [10, 0, 10],     [20, 0, 0], [30, 0, 0] ],
                        [ [0, -10, 0],  [10, -10, 0],  [20, -10, 0], [30, -10, 0]   ],
                        [ [0, -20, 0],  [10, -20, 0],  [20, -20, 0], [30, -20, 0]  ],
                        [ [0, -30, 10],  [10, -30, 10],   [20, -30, 10], [30, -30, 10]     ]  ]
            , wts = [   [ 1, 1, 1, 1, 1, 1],
                        [ 1, 1, 1, 1, 1, 1],
                        [ 1, 1, 1, 1, 1, 1],
                        [ 1, 1, 1, 1, 1, 1],
                        [ 1, 1, 1, 1, 1, 1],
                        [ 1, 1, 1, 1, 1, 1] ];

        pts = verb.eval.Eval.homogenize2d(pts, wts);

        return {
            degreeU : degree,
            degreeV : degree,
            knotsU : knots,
            knotsV : knots,
            controlPoints : pts
        };
    }
    // homogenize the pts

    controlPoints.forEach((x) => {
        x.forEach((y) => {
            y.push(1.0);
        });
    });

    // surface = getBezier();

    var tol = 0.3;

    var mat2 = new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.DoubleSide, wireframe: true });
    var l = verb.eval.Tess.rationalBezierSurfaceStepLength( surface, tol );
    var res = verb.eval.Modify.decomposeSurfaceIntoBeziers( surface );

    for (var i = 0; i < res.length; i++){
        for (var j = 0; j < res[i].length; j++){

            var color = '#'+Math.floor(Math.random()*16777215).toString(16);
            var mat = new THREE.MeshBasicMaterial( { color: color, side: THREE.DoubleSide, wireframe: true });

            var srf = res[i][j];
            var l = verb.eval.Tess.rationalBezierSurfaceStepLength( srf, tol );
            // addMeshToScene( tessellateSurface( srf, Math.ceil( 1 / l.item0 ), Math.ceil( 1 / l.item1) ), mat );
        }
    }

    // add the edge points to the scene

    var mesh = verb.eval.Tess.rationalSurfaceAdaptiveSample( surface, tol );

    addMeshToScene( getThreeMesh( mesh ) );
    addMeshToScene( getThreeMesh( mesh ), mat2 );
    // addPointsToScene( mesh.points );

	renderScene();

</script>

<script src="js/example.js"></script>

</html>