<!DOCTYPE html>

<html>
<head>
  <title>verb.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>verb.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>browser context</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">if</span> ( <span class="keyword">typeof</span> exports != <span class="string">'object'</span> || exports === <span class="literal">undefined</span> )  
{
	<span class="keyword">var</span> verb = {}
		, numeric = window.numeric
		, binomial = window.binomial
		, labor = window.labor
		, _ = window.underscore;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>node.js context</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">else</span> 
{
	<span class="keyword">var</span> verb = module.exports = {}
		, numeric = require(<span class="string">'numeric'</span>)
		, binomial = require(<span class="string">'binomial'</span>)
		, labor = require(<span class="string">'labor'</span>)
		, _ = require(<span class="string">'underscore'</span>);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Initialize the verb namespace objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom = verb.geom || {};
verb.core = verb.core || {};
verb.eval = verb.eval || {};
verb.intersect = verb.intersect || {};
verb.eval.nurbs = verb.eval.nurbs || {};
verb.eval.geom = verb.eval.geom || {};
verb.eval.mesh = verb.eval.mesh || {};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h4 id="verb-epsilon">verb.EPSILON</h4>
<p>Used for numeric comparisons</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.EPSILON = <span class="number">1e-8</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h4 id="verb-tolerance">verb.TOLERANCE</h4>
<p>Default tolerance for geometric operations - defines &quot;close enough&quot; 
for tesselation, intersection, and more</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.TOLERANCE = <span class="number">1e-3</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h4 id="init-">init()</h4>
<p>Start a default Engine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.init = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
	verb.nurbsEngine = <span class="keyword">new</span> verb.core.Engine( verb.eval.nurbs );
	verb.geom.NurbsGeometry.prototype.nurbsEngine = verb.nurbsEngine;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h4 id="douglas-crockford-s-method-">Douglas Crockford&#39;s &quot;method&quot;</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>Function.prototype.method = <span class="function"><span class="keyword">function</span> <span class="params">(name, func)</span> {</span>
    <span class="keyword">this</span>.prototype[name] = func;
    <span class="keyword">return</span> <span class="keyword">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h4 id="douglas-crockford-s-inherits-">Douglas Crockford&#39;s &quot;inherits&quot;</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>Function.method(<span class="string">'inherits'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(parent)</span> {</span>
    <span class="keyword">this</span>.prototype = <span class="keyword">new</span> parent();
    <span class="keyword">var</span> d = {}, 
        p = <span class="keyword">this</span>.prototype;
    <span class="keyword">this</span>.prototype.constructor = parent; 
    <span class="keyword">return</span> <span class="keyword">this</span>;
});</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h4 id="array-flatten-">Array.flatten()</h4>
<p>Extend methods to collapse multidimensional arrays to 1d</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Array.prototype.flatten = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	<span class="keyword">if</span> (<span class="keyword">this</span>.length == <span class="number">0</span>) <span class="keyword">return</span> [];

	<span class="keyword">var</span> merged = [];

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++){
		<span class="keyword">if</span> (<span class="keyword">this</span>[i] <span class="keyword">instanceof</span> Array){
			merged = merged.concat( <span class="keyword">this</span>[i].flatten() );
		} <span class="keyword">else</span> {
			merged = merged.concat( <span class="keyword">this</span>[i] );
		}
	}

	<span class="keyword">return</span> merged;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h4 id="numeric-normalized-arr-">numeric.normalized( arr )</h4>
<p>Extend numeric to obtain the normalized version of an array</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Array of numbers</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, The array after normalization</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>numeric.normalized = <span class="function"><span class="keyword">function</span><span class="params">(arr)</span>{</span>

	<span class="keyword">return</span> numeric.div( arr, numeric.norm2(arr) );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h4 id="numeric-cross-u-v-">numeric.cross( u, v )</h4>
<p>Extend numeric to form the cross product between two length 3 arrays</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array of numbers</li>
<li><em>Array</em>, Length 3 array of numbers</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, The length 3 array cross product</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>numeric.cross = <span class="function"><span class="keyword">function</span><span class="params">(u, v)</span>{</span>

	<span class="keyword">return</span> [u[<span class="number">1</span>]*v[<span class="number">2</span>]-u[<span class="number">2</span>]*v[<span class="number">1</span>],u[<span class="number">2</span>]*v[<span class="number">0</span>]-u[<span class="number">0</span>]*v[<span class="number">2</span>],u[<span class="number">0</span>]*v[<span class="number">1</span>]-u[<span class="number">1</span>]*v[<span class="number">0</span>]];

}</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h3 id="new-engine-options-">new Engine( [options] )</h3>
<p>Constructor for Engine</p>
<p><strong>params</strong></p>
<ul>
<li><em>Object</em>, An options object defining the library location, number of threads to use, tolerance of the worker, etc.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.core.Engine = <span class="function"><span class="keyword">function</span><span class="params">(options)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>private properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> _use_pool = ( <span class="keyword">typeof</span> Worker === <span class="string">'function'</span> ) &amp;&amp; ( options.use_pool || options.use_pool === <span class="literal">undefined</span> );
	<span class="keyword">var</span> _num_threads = options.num_workers || <span class="number">2</span>;
	<span class="keyword">var</span> _tolerance = options.tolerance || <span class="number">1e-4</span>;
	<span class="keyword">var</span> _url = options.url || <span class="string">'js/verbEval.js'</span>;
	<span class="keyword">var</span> _lib = options.library || verb.eval.nurbs;
	<span class="keyword">var</span> _error_handler = options.error_handler || ( <span class="function"><span class="keyword">function</span><span class="params">( message )</span> {</span> console.warn( message ); } );
	<span class="keyword">var</span> _pool = <span class="literal">undefined</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>private methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> init_pool = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>

		<span class="keyword">try</span> {
			_pool = <span class="keyword">new</span> labor.Pool(_url, _num_threads );
			_pool.start();
		} <span class="keyword">catch</span> (err) {
			_error_handler( <span class="string">'Failed to initialize labor.Pool: '</span> + err );
			<span class="keyword">return</span> <span class="literal">false</span>;
		}
		<span class="keyword">return</span> <span class="literal">true</span>;

	};

	<span class="keyword">var</span> eval_sync = <span class="function"><span class="keyword">function</span><span class="params">(func, arguments_array)</span> {</span>
		<span class="keyword">return</span> _lib[func].apply(<span class="literal">null</span>, arguments_array);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h4 id="start-">start()</h4>
<p>Creates the thread pool if that is being used</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">this</span>.start = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>initialize pool</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="keyword">if</span> ( _use_pool )
		{
			init_pool();
		}
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <h4 id="eval-func-arguments_array-callback-">eval(func, arguments_array, callback )</h4>
<p>Evaluate a function asynchronously from the library</p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, The name of the function to call in the library</li>
<li><em>Array</em>, The array of arguments to the function</li>
<li><em>Function</em>, Function to execute on completion, passing the value to it</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Unknown</em>, the return value of the function</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">this</span>.eval = <span class="function"><span class="keyword">function</span><span class="params">(func, arguments_array, callback )</span>
	{</span>

		<span class="keyword">if</span> (!callback){
			<span class="keyword">return</span> eval_sync(func, arguments_array);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>if we are to use the pool we must init it </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="keyword">if</span> ( _use_pool &amp;&amp; ( _pool || ( _pool === <span class="literal">undefined</span> &amp;&amp; init_pool() ) ) ) {
			_pool.addWork( func, arguments_array, callback );
		}	<span class="keyword">else</span> {
			setTimeout( <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> callback( eval_sync(func, arguments_array ) ) }, <span class="number">0</span>);
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h4 id="settolerance-tolerance-">setTolerance( tolerance )</h4>
<p>Set the tolerance of the library</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The tolerance value</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">this</span>.setTolerance = <span class="function"><span class="keyword">function</span><span class="params">(tolerance)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>TODO: send message to worker pool in labor.js</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		_tolerance = tolerance;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h4 id="setusepool-use_pool-">setUsePool( use_pool )</h4>
<p>Whether to use the thread pool or do evaluations in the main thread</p>
<p><strong>params</strong></p>
<ul>
<li><em>Boolean</em>, Use the pool or not</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">this</span>.setUsePool = <span class="function"><span class="keyword">function</span><span class="params">( use_pool )</span> {</span>

		<span class="keyword">if</span> ( use_pool &amp;&amp; _pool === <span class="literal">undefined</span> &amp;&amp; init_pool() ) {
			_use_pool = use_pool;
			<span class="keyword">return</span> <span class="literal">true</span>;
		} <span class="keyword">else</span> <span class="keyword">if</span> ( !use_pool ) {
			_pool = <span class="literal">null</span>;
			<span class="keyword">delete</span> _pool;
			<span class="keyword">return</span> <span class="literal">true</span>;
		} <span class="keyword">else</span> {
			<span class="keyword">return</span> <span class="literal">false</span>;
		}
		
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h4 id="seterrorhandler-handler-">setErrorHandler( handler )</h4>
<p>The error handler function</p>
<p><strong>params</strong></p>
<ul>
<li><em>Function</em>, The function that handles errors</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">this</span>.setErrorHandler = <span class="function"><span class="keyword">function</span><span class="params">( handler )</span> {</span>
		_error_handler = handler;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <h4 id="setnumthreads-numthreads-">setNumThreads( numThreads )</h4>
<p>Set the number of threads to use</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The number of threads to use</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">this</span>.setNumThreads = <span class="function"><span class="keyword">function</span><span class="params">( num_threads )</span> {</span>
		_num_threads = num_threads;</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>TODO: implement add or remove workers in labor.js</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	}

};</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h3 id="new-watchobject-">new WatchObject()</h3>
<p>Constructor for WatchObject</p>
<p>WatchObject is a simple type with observable properties.  You can register callbacks for
when these properties change</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.core.WatchObject = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>name -&gt; { id -&gt; callback }</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> watchers = { <span class="string">"change"</span> : {} };</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>name -&gt; value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> properties = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>counter for watch ids</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> watcherId = <span class="number">0</span>;

	<span class="keyword">var</span> that = <span class="keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>report a property change to the watchers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> report = <span class="function"><span class="keyword">function</span><span class="params">(name, updateObject)</span>{</span>

		<span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">"string"</span>){

			<span class="keyword">for</span> (ele <span class="keyword">in</span> watchers[name]){
				watchers[name][ele]( updateObject );
			}

			<span class="keyword">for</span> (ele <span class="keyword">in</span> watchers[<span class="string">"change"</span>]){
				watchers[<span class="string">"change"</span>][ele]( updateObject );
			}
			
		} <span class="keyword">else</span> {
			<span class="keyword">for</span> (n <span class="keyword">in</span> name){
				report( n, updateObject );
			}
		}

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <h4 id="eval-func-arguments_array-callback-">eval(func, arguments_array, callback )</h4>
<p>Get the value of a property name. </p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, The name of the property</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Unknown</em>, The value of the property</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span><span class="params">( name )</span>{</span>

		<span class="keyword">return</span> properties[name];

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <h4 id="set-name-value-">set( name, value )</h4>
<p>Set the value of a property and update watchers.  Initializes the value if it doesn&#39;t already exist</p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, The name of the property</li>
<li><em>Unknown</em>, The new value for the property</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">this</span>.set = <span class="function"><span class="keyword">function</span><span class="params">( name, value )</span>{</span>

		<span class="keyword">var</span> old = properties[name];

		properties[name] = value;
		watchers[name] = watchers[name] || {};

		report( name, {name: name, old: old, <span class="string">"new"</span>: value, target: that, type: <span class="string">"full"</span>});

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <h4 id="setall-propertynamevaluepairs-">setAll( propertyNameValuePairs )</h4>
<p>Set the value of a collection of properties simultaneously</p>
<p><strong>params</strong></p>
<ul>
<li><em>Object</em>, An object literal mapping from property names to new values</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">this</span>.setAll = <span class="function"><span class="keyword">function</span><span class="params">( propertyNameValuePairs )</span>{</span>

		<span class="keyword">var</span> oldVals = {};

		<span class="keyword">for</span> ( propName <span class="keyword">in</span> propertyNameValuePairs ){
			oldVals[propName] = properties[propName];
			properties[propName] = propertyNameValuePairs[propName];
			watchers[propName] = watchers[propName] || {};
		}

		report( propertyNameValuePairs, { old: oldVals, <span class="string">"new"</span>: propertyNameValuePairs, target: that, type: <span class="string">"multi"</span> } );

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <h4 id="setat-name-index-value-">setAt( name, index, value  )</h4>
<p>Set the value of an array property at a particular index.  Update watchers
indicating that it is an &quot;index&quot; type update.</p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, The name of the property</li>
<li><em>Number</em>, The index at which to change the value</li>
<li><em>Unknown</em>, The new value for the index</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">this</span>.setAt = <span class="function"><span class="keyword">function</span><span class="params">( name, index, value )</span>{</span>

		<span class="keyword">var</span> oldArr = properties[name];

		<span class="keyword">if</span> (oldArr === <span class="literal">undefined</span> || oldArr.length &gt;= index || index &lt; <span class="number">0</span>){
			<span class="keyword">return</span>;
		}

		<span class="keyword">var</span> old = properties[name][index];
		properties[name][index] = value;

		report( name, {name: name, index: index, old: old, <span class="string">"new"</span>: value, target: that, type: <span class="string">"index"</span>} );

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <h4 id="watch-name-callback-">watch( name, callback )</h4>
<p>Start watching a particular property.  Use &quot;change&quot; as the name to receive all 
updates from this object</p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, The name of the property</li>
<li><em>Function</em>, The callback</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, A watcher id which can be used to unregister the callback</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">this</span>.watch = <span class="function"><span class="keyword">function</span><span class="params">( name, callback )</span>{</span>

		<span class="keyword">if</span> ( properties[name] === <span class="literal">undefined</span> || !callback ){
			<span class="keyword">return</span>;
		}

		<span class="keyword">var</span> id = watcherId++;
		watchers[name][watcherId] = callback;

		<span class="keyword">return</span> watcherId++;
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <h4 id="watchall-names-callback-">watchAll( names, callback )</h4>
<p>Start watching multiple properties</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Array of property names</li>
<li><em>Function</em>, The callback</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, An array of watcher ids which can be used to unregister the callbacks</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">this</span>.watchAll = <span class="function"><span class="keyword">function</span><span class="params">( names, callback )</span>{</span>

		<span class="keyword">var</span> watcherIds = [];

		<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.length; i++){
			watcherIds.push( <span class="keyword">this</span>.watch( names[i], callback ) );
		}

		<span class="keyword">return</span> watcherIds;

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <h4 id="watchall-names-callback-">watchAll( names, callback )</h4>
<p>Stop watching a property</p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, Property name</li>
<li><em>Number</em>, Watcher id to remove</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">this</span>.ignore = <span class="function"><span class="keyword">function</span><span class="params">( name, watcherId )</span>{</span>
	
		<span class="keyword">if</span> ( watchers[name] === <span class="literal">undefined</span> 
			|| watchers[name][watcherId] === <span class="literal">undefined</span>){
			<span class="keyword">return</span>;
		}

		watchers[name][watcherId] = <span class="literal">undefined</span>;

	};

};</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <h4 id="uid-">uid()</h4>
<p>Generate a unique id.</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Number</em>, The id</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.core.uid = (<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
	<span class="keyword">var</span> id = <span class="number">0</span>;
	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
		<span class="keyword">return</span> id++;
	};
})();</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <h3 id="new-nurbsgeometry-">new NurbsGeometry()</h3>
<p>Constructor for Geometry</p>
<p>Geometry is the base class for all Geometry types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Geometry = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> 

	verb.core.WatchObject.call(<span class="keyword">this</span>);

	<span class="keyword">var</span> id = verb.core.uid();
	
	<span class="keyword">this</span>.uniqueId = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
		<span class="keyword">return</span> id;
	};

}.inherits(verb.core.WatchObject);</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <h3 id="new-nurbsgeometry-">new NurbsGeometry()</h3>
<p>Constructor for NurbsGeometry</p>
<p>NurbsGeometry is the base class for all NURBS types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsGeometry = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>

	verb.geom.Geometry.call(<span class="keyword">this</span>);

}.inherits( verb.geom.Geometry );</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <h3 id="new-nurbssurface-degree-controlpoints-weights-knots-">new NurbsSurface( degree, controlPoints, weights, knots )</h3>
<p>Constructor for a NurbsCurve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The degree of the curve</li>
<li><em>Array</em>, Array of arrays representing the control points</li>
<li><em>Array</em>, Array of numbers representing the control point weights</li>
<li><em>Array</em>, Array of numbers representing the knot structure</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve = <span class="function"><span class="keyword">function</span><span class="params">( degree, controlPoints, weights, knots )</span> {</span>

	verb.geom.NurbsGeometry.call(<span class="keyword">this</span>);

	<span class="keyword">this</span>.setAll({
		<span class="string">"controlPoints"</span>: controlPoints,
		<span class="string">"weights"</span>: weights,
		<span class="string">"knots"</span>: knots ? knots.slice(<span class="number">0</span>) : [],
		<span class="string">"degree"</span>: degree
	});

}.inherits( verb.geom.NurbsGeometry );</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <h4 id="point-u-callback-">point( u [, callback] )</h4>
<p>Sample a point at the given parameter </p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The parameter to sample the curve</li>
<li><em>Function</em>, Optional callback to do it async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve.prototype.point = <span class="function"><span class="keyword">function</span><span class="params">( u, callback )</span> {</span>

	<span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'rational_curve_point'</span>, [ <span class="keyword">this</span>.get(<span class="string">'degree'</span>), <span class="keyword">this</span>.get(<span class="string">'knots'</span>), <span class="keyword">this</span>.homogenize(),  u ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <h4 id="derivatives-u-num_derivs-callback-">derivatives( u, num_derivs [, callback] )</h4>
<p>Get derivatives at a given parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The parameter to sample the curve</li>
<li><em>Number</em>, The number of derivatives to obtain</li>
<li><em>Number</em>, The callback, if you want this async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve.prototype.derivatives = <span class="function"><span class="keyword">function</span><span class="params">( u, num_derivs, callback )</span> {</span>

	<span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'rational_curve_derivs'</span>, [ <span class="keyword">this</span>.get(<span class="string">'degree'</span>), <span class="keyword">this</span>.get(<span class="string">'knots'</span>), <span class="keyword">this</span>.homogenize(),  u, num_derivs  ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <h4 id="tesselate-options-callback-">tesselate(options [, callback] )</h4>
<p>Tesselate a curve at a given tolerance</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The parameter to sample the curve</li>
<li><em>Number</em>, The number of derivatives to obtain</li>
<li><em>Number</em>, The callback, if you want this async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve.prototype.tesselate = <span class="function"><span class="keyword">function</span><span class="params">(options, callback)</span>{</span>

	<span class="keyword">var</span> options = options || {};
	options.tolerance = options.tolerance || verb.EPSILON;

	<span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'rational_curve_adaptive_sample'</span>, [ <span class="keyword">this</span>.get(<span class="string">'degree'</span>), <span class="keyword">this</span>.get(<span class="string">'knots'</span>), <span class="keyword">this</span>.homogenize(), options.tolerance ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <h4 id="transform-mat-">transform( mat )</h4>
<p>Transform a curve with the given matrix.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 4d array representing the transform</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve.prototype.transform = <span class="function"><span class="keyword">function</span><span class="params">( mat )</span>{</span>

	<span class="keyword">var</span> pts = <span class="keyword">this</span>.get(<span class="string">"controlPoints"</span>);

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pts.length; i++){
		<span class="keyword">var</span> homoPt = pts[<span class="number">1</span>].push(<span class="number">1</span>);
		pts[i] = numeric.mul( mat, homoPt ).slice( <span class="number">0</span>, homoPt.length-<span class="number">2</span> );
	}

	<span class="keyword">this</span>.set(<span class="string">'controlPoints'</span>, pts);

	<span class="keyword">return</span> <span class="keyword">this</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <h4 id="clone-">clone()</h4>
<p>Obtain a copy of the curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 4d array representing the transform</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve.prototype.clone = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>copy the control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> pts = <span class="keyword">this</span>.get(<span class="string">"controlPoints"</span>);

	<span class="keyword">var</span> pts_copy = [];

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pts.length; i++){
		pts_copy.push( pts[i].slice(<span class="number">0</span>) );
	}

	<span class="keyword">return</span> <span class="keyword">new</span> verb.geom.NurbsCurve( <span class="keyword">this</span>.get(<span class="string">'degree'</span>), pts_copy, <span class="keyword">this</span>.get(<span class="string">'weights'</span>).slice(<span class="number">0</span>), <span class="keyword">this</span>.get(<span class="string">'knots'</span>).slice );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <h4 id="homogenize-">homogenize()</h4>
<p>Obtain the homogeneous representation of the control points</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, 2d array of homogenized control points</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve.prototype.homogenize = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	<span class="keyword">return</span> verb.eval.nurbs.homogenize_1d( <span class="keyword">this</span>.get(<span class="string">'controlPoints'</span>), <span class="keyword">this</span>.get(<span class="string">'weights'</span>) );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <h4 id="update-">update()</h4>
<p>If this is a subtype of the NurbsCurve, this method will update the Nurbs representation
of the curve from those parameters.  This destroys any manual changes to the Nurbs rep.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve.prototype.update = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	<span class="keyword">if</span> ( !<span class="keyword">this</span>.nurbsRep ){
		<span class="keyword">return</span>;
	}

	<span class="keyword">var</span> curve_props = <span class="keyword">this</span>.nurbsRep();

	<span class="keyword">this</span>.setAll({
		<span class="string">"controlPoints"</span>: curve_props.control_points,
		<span class="string">"weights"</span>: curve_props.weights,
		<span class="string">"knots"</span>: curve_props.knots,
		<span class="string">"degree"</span>: curve_props.degree
	});

};</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <h3 id="new-nurbssurface-degreeu-knotsu-degreev-knotsv-controlpoints-weights-">new NurbsSurface( degreeU, knotsU, degreeV, knotsV, controlPoints, weights )</h3>
<p>Constructor for a NurbsSurface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The degree of the surface in the u direction</li>
<li><em>Array</em>, Array of numbers representing the knot positions in the u direction</li>
<li><em>Number</em>, The degree of the surface in the v direction</li>
<li><em>Array</em>, Array of numbers representing the knot positions in the v direction</li>
<li><em>Array</em>, 3d array representing the unweighted control points</li>
<li><em>Array</em>, 2d array representing the surface weight structure</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface = <span class="function"><span class="keyword">function</span><span class="params">( degreeU, knotsU, degreeV, knotsV, controlPoints, weights )</span> {</span>

	verb.geom.NurbsGeometry.call(<span class="keyword">this</span>);

	<span class="keyword">this</span>.setAll({
		<span class="string">"controlPoints"</span>: controlPoints,
		<span class="string">"weights"</span>: weights,
		<span class="string">"knotsU"</span>: knotsU ? knotsU.slice(<span class="number">0</span>) : [],
		<span class="string">"knotsV"</span>: knotsV ? knotsV.slice(<span class="number">0</span>) : [],
		<span class="string">"degreeU"</span>: degreeU,
		<span class="string">"degreeV"</span>: degreeV
	});

}.inherits( verb.geom.NurbsGeometry );</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <h4 id="point-u-v-callback-">point( u, v [, callback] )</h4>
<p>Sample a point at the given u, v parameter </p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The u parameter at which to sample</li>
<li><em>Number</em>, The v parameter at which to sample</li>
<li><em>Function</em>, Optional callback to do it async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface.prototype.point = <span class="function"><span class="keyword">function</span><span class="params">( u, v, callback )</span> {</span>

	<span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'rational_surface_point'</span>, 
							[ 	<span class="keyword">this</span>.get(<span class="string">'degreeU'</span>), <span class="keyword">this</span>.get(<span class="string">'knotsU'</span>), <span class="keyword">this</span>.get(<span class="string">'degreeV'</span>), <span class="keyword">this</span>.get(<span class="string">'knotsV'</span>), <span class="keyword">this</span>.homogenize(), u, v ], callback );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <h4 id="derivatives-u-v-num_derivs-callback-">derivatives( u, v, num_derivs [, callback] )</h4>
<p>Get derivatives at a given u, v parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The u parameter to sample the curve</li>
<li><em>Number</em>, The v parameter to sample the curve</li>
<li><em>Number</em>, The number of derivatives to obtain</li>
<li><em>Number</em>, The callback, if you want this async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface.prototype.derivatives = <span class="function"><span class="keyword">function</span><span class="params">( u, v, num_derivs, callback )</span> {</span>

	<span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'rational_surface_derivs'</span>, 
			[	<span class="keyword">this</span>.get(<span class="string">'degreeU'</span>), <span class="keyword">this</span>.get(<span class="string">'knotsU'</span>), <span class="keyword">this</span>.get(<span class="string">'degreeV'</span>), <span class="keyword">this</span>.get(<span class="string">'knotsV'</span>), <span class="keyword">this</span>.homogenize(), num_derivs, u, v ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <h4 id="tesselate-options-callback-">tesselate(options [, callback] )</h4>
<p>Tesselate the surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Object</em>, Tesselate the surface, given an options object includings a vdivs and udivs property</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface.prototype.tesselate = <span class="function"><span class="keyword">function</span><span class="params">(options, callback)</span>{</span>

	<span class="keyword">var</span> minDivsV = <span class="number">20</span>
		, minDivsU = <span class="number">20</span>;

	<span class="keyword">if</span> (options){
		minDivsV = options.minDivsV || minDivsV;
		minDivsU = options.minDivsU || minDivsU;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>naive surface tesselation, for now</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'tesselate_rational_surface_naive'</span>, 
			[	<span class="keyword">this</span>.get(<span class="string">'degreeU'</span>), <span class="keyword">this</span>.get(<span class="string">'knotsU'</span>), <span class="keyword">this</span>.get(<span class="string">'degreeV'</span>), <span class="keyword">this</span>.get(<span class="string">'knotsV'</span>), <span class="keyword">this</span>.homogenize(), 
			minDivsU, minDivsV ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <h4 id="transform-mat-">transform( mat )</h4>
<p>Transform a curve with the given matrix.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 4d array representing the transform</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface.prototype.transform = <span class="function"><span class="keyword">function</span><span class="params">( mat )</span>{</span>

	<span class="keyword">var</span> pts = <span class="keyword">this</span>.get(<span class="string">"controlPoints"</span>);

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pts.length; i++){
		<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; pts[i].length; j++){
			<span class="keyword">var</span> homoPt = pts[<span class="number">1</span>].push(<span class="number">1</span>);
			pts[i] = numeric.mul( mat, homoPt ).slice( <span class="number">0</span>, homoPt.length-<span class="number">2</span> );
		}
	}

	<span class="keyword">this</span>.set(<span class="string">'controlPoints'</span>, pts);

	<span class="keyword">return</span> <span class="keyword">this</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <h4 id="clone-">clone()</h4>
<p>Obtain a copy of the curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 4d array representing the transform</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface.prototype.clone = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>copy the control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> pts = <span class="keyword">this</span>.get(<span class="string">"controlPoints"</span>);
	<span class="keyword">var</span> pts_copy = [];

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pts.length; i++){
		pts_copy.push([]);
		<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; pts[i].length; j++){
			pts_copy[i].push( pts[i][j].slice( <span class="number">0</span> ) );
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>copy the weights</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> weights = <span class="keyword">this</span>.get(<span class="string">"weights"</span>);
	<span class="keyword">var</span> weights_copy = [];

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; weights.length; i++){
		weights_copy.push( weights[i].slice( <span class="number">0</span> ) );
	}

	<span class="keyword">return</span> <span class="keyword">new</span> verb.geom.NurbsSurface( <span class="keyword">this</span>.get(<span class="string">'degreeU'</span>), <span class="keyword">this</span>.get(<span class="string">'knotsU'</span>).slice(<span class="number">0</span>), 
		<span class="keyword">this</span>.get(<span class="string">'degreeV'</span>), <span class="keyword">this</span>.get(<span class="string">'knotsV'</span>).slice(<span class="number">0</span>), pts_copy, weights_copy );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <h4 id="homogenize-">homogenize()</h4>
<p>Obtain the homogeneous representation of the control points</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, 3d array of homogenized control points</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface.prototype.homogenize = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	<span class="keyword">return</span> verb.eval.nurbs.homogenize_2d( <span class="keyword">this</span>.get(<span class="string">'controlPoints'</span>), <span class="keyword">this</span>.get(<span class="string">'weights'</span>) );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <h4 id="update-">update()</h4>
<p>If this is a subtype of the NurbsSurface, this method will update the Nurbs representation
of the curve from those parameters.  This destroys any manual changes to the Nurbs rep.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface.prototype.update = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	<span class="keyword">if</span> ( !<span class="keyword">this</span>.nurbsRep ){
		<span class="keyword">return</span>;
	}

	<span class="keyword">var</span> curve_props = <span class="keyword">this</span>.nurbsRep();

	<span class="keyword">this</span>.setAll({
		<span class="string">"controlPoints"</span>: curve_props.control_points,
		<span class="string">"weights"</span>: curve_props.weights,
		<span class="string">"knotsU"</span>: curve_props.knots_u,
		<span class="string">"knotsV"</span>: curve_props.knots_v,
		<span class="string">"degreeU"</span>: curve_props.degree_u,
		<span class="string">"degreeV"</span>: curve_props.degree_v
	});

};</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <h3 id="new-arc-center-xaxis-yaxis-radius-interval-">new Arc(center, xaxis, yaxis, radius, interval)</h3>
<p>Constructor for Arc</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the center of the arc</li>
<li><em>Array</em>, Length 3 array representing the xaxis</li>
<li><em>Array</em>, Length 3 array representing the perpendicular yaxis</li>
<li><em>Number</em>, Radius of the arc</li>
<li><em>Interval</em>, Interval object representing the interval of the arc</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Arc = <span class="function"><span class="keyword">function</span><span class="params">(center, xaxis, yaxis, radius, interval)</span> {</span>

	verb.geom.NurbsCurve.call(<span class="keyword">this</span>);

	<span class="keyword">this</span>.setAll( {
		<span class="string">"center"</span>: center,
		<span class="string">"xaxis"</span>: xaxis,
		<span class="string">"yaxis"</span>: yaxis,
		<span class="string">"radius"</span>: radius,
		<span class="string">"interval"</span>: interval 
	});

	<span class="keyword">this</span>.update();
	<span class="keyword">this</span>.watchAll( [<span class="string">'center'</span>, <span class="string">'xaxis'</span>, <span class="string">'yaxis'</span>, <span class="string">'radius'</span>, <span class="string">'interval'</span>], <span class="keyword">this</span>.update );

}.inherits(verb.geom.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Arc.prototype.nurbsRep = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	<span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'get_arc'</span>, [ <span class="keyword">this</span>.get(<span class="string">"center"</span>), 
													 <span class="keyword">this</span>.get(<span class="string">"xaxis"</span>), 
													 <span class="keyword">this</span>.get(<span class="string">"yaxis"</span>), 
													 <span class="keyword">this</span>.get(<span class="string">"radius"</span>), 
													 <span class="keyword">this</span>.get(<span class="string">"interval"</span>).get(<span class="string">"min"</span>), 
													 <span class="keyword">this</span>.get(<span class="string">"interval"</span>).get(<span class="string">"max"</span>)] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <h3 id="new-beziercurve-control_points-weights-">new BezierCurve( control_points [, weights] )</h3>
<p>Constructor for BezierCurve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Array of Length 3 arrays representing the control pts of the bezier curve</li>
<li><em>Array</em>, Array of numbers representing the weights of the bezier curve, omit if you don&#39;t want this to be a rational curve</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BezierCurve = <span class="function"><span class="keyword">function</span><span class="params">( control_points, weights )</span> {</span>

	verb.geom.NurbsCurve.call(<span class="keyword">this</span>);
	
	<span class="keyword">this</span>.setAll( {
		<span class="string">"controlPoints"</span>: control_points ? control_points.slice(<span class="number">0</span>) : [],
		<span class="string">"weights"</span>: weights ? weights.slice(<span class="number">0</span>) : <span class="literal">undefined</span>
	});

	<span class="keyword">this</span>.update();

}.inherits( verb.geom.NurbsCurve );</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BezierCurve.prototype.nurbsRep = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	<span class="keyword">var</span> control_points = <span class="keyword">this</span>.get(<span class="string">'controlPoints'</span>);
	<span class="keyword">var</span> weights = <span class="keyword">this</span>.get(<span class="string">'weights'</span>);
	<span class="keyword">var</span> degree = control_points.length - <span class="number">1</span>;

	<span class="keyword">var</span> knots = [];
	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; degree + <span class="number">1</span>; i++){ knots.push(<span class="number">0</span>); }
	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; degree + <span class="number">1</span>; i++){ knots.push(<span class="number">1</span>); }</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>if weights aren&#39;t provided, build uniform weights</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">if</span> (weights === <span class="literal">undefined</span>){
		weights = [];
		<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; control_points.length; i++){
			weights.push(<span class="number">1</span>);
		}
	}

	<span class="keyword">return</span> {
		degree: degree,
		knots: knots, 
		control_points: control_points,
		weights: weights
	};

};</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <h3 id="new-boundingbox-points-">new BoundingBox([ points ])</h3>
<p>BoundingBox Constructor</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Points to add, if desired.  Otherwise, will not be initialized until add is called.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
	<span class="keyword">this</span>.initialized = <span class="literal">false</span>;
	<span class="keyword">this</span>.min = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>];
	<span class="keyword">this</span>.max = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>];

 	<span class="keyword">var</span> pt_args = Array.prototype.slice.call( arguments, <span class="number">0</span>);
 	<span class="keyword">this</span>.add_elements_sync(pt_args);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <h4 id="add_elements-point_array-callback-">add_elements( point_array, callback )</h4>
<p>Asynchronously add an array of points to the bounding box</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, An array of length-3 array of numbers </li>
<li><em>Function</em>, Function to call when all of the points in array have been added.  The only parameter to this
callback is this bounding box.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.add_elements = <span class="function"><span class="keyword">function</span><span class="params">( point_array, callback )</span> 
{</span>

	<span class="keyword">var</span> that = <span class="keyword">this</span>; 
	_.defer(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
		_.each( point_array, <span class="function"><span class="keyword">function</span><span class="params">(elem, index)</span> {</span>
			that.add(elem);
		});
		callback(that);
	});

};</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <h4 id="add_elements_sync-point_array-">add_elements_sync( point_array )</h4>
<p>Synchronously add an array of points to the bounding box</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, An array of length-3 array of numbers </li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Object</em>, This BoundingBox for chaining</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.add_elements_sync = <span class="function"><span class="keyword">function</span><span class="params">( point_array )</span> 
{</span>
	<span class="keyword">var</span> that = <span class="keyword">this</span>; 
	_.each( point_array, <span class="function"><span class="keyword">function</span><span class="params">(elem)</span> {</span>
		that.add(elem);
	});
	<span class="keyword">return</span> <span class="keyword">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <h4 id="add-point-">add( point )</h4>
<p>Adds a point to the bounding box, expanding the bounding box if the point is outside of it.
If the bounding box is not initialized, this method has that side effect.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, A length-3 array of numbers </li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Object</em>, This BoundingBox for chaining</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.add = <span class="function"><span class="keyword">function</span><span class="params">( point )</span> 
{</span>
	<span class="keyword">if</span> ( !<span class="keyword">this</span>.initialized )
	{
		<span class="keyword">this</span>.min = point.slice(<span class="number">0</span>);
		<span class="keyword">this</span>.max = point.slice(<span class="number">0</span>);
		<span class="keyword">this</span>.initialized = <span class="literal">true</span>;
		<span class="keyword">return</span> <span class="keyword">this</span>;
	}

	<span class="keyword">if</span> (point[<span class="number">0</span>] &gt; <span class="keyword">this</span>.max[<span class="number">0</span>] )
	{
		<span class="keyword">this</span>.max[<span class="number">0</span>] = point[<span class="number">0</span>];
	}

	<span class="keyword">if</span> (point[<span class="number">1</span>] &gt; <span class="keyword">this</span>.max[<span class="number">1</span>] )
	{
		<span class="keyword">this</span>.max[<span class="number">1</span>] = point[<span class="number">1</span>];
	}

	<span class="keyword">if</span> (point[<span class="number">2</span>] &gt; <span class="keyword">this</span>.max[<span class="number">2</span>] )
	{
		<span class="keyword">this</span>.max[<span class="number">2</span>] = point[<span class="number">2</span>];
	}

	<span class="keyword">if</span> (point[<span class="number">0</span>] &lt; <span class="keyword">this</span>.min[<span class="number">0</span>] )
	{
		<span class="keyword">this</span>.min[<span class="number">0</span>] = point[<span class="number">0</span>];
	}

	<span class="keyword">if</span> (point[<span class="number">1</span>] &lt; <span class="keyword">this</span>.min[<span class="number">1</span>] )
	{
		<span class="keyword">this</span>.min[<span class="number">1</span>] = point[<span class="number">1</span>];
	}

	<span class="keyword">if</span> (point[<span class="number">2</span>] &lt; <span class="keyword">this</span>.min[<span class="number">2</span>] )
	{
		<span class="keyword">this</span>.min[<span class="number">2</span>] = point[<span class="number">2</span>];
	}

	<span class="keyword">return</span> <span class="keyword">this</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <h4 id="contains-point-">contains( point )</h4>
<p>Determines if two intervals on the real number line intersect</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Beginning of first interval</li>
<li><em>Number</em>, End of first interval</li>
<li><em>Number</em>, Beginning of second interval</li>
<li><em>Number</em>, End of second interval</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Boolean</em>, true if the two intervals overlap, otherwise false</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.contains = <span class="function"><span class="keyword">function</span><span class="params">(point)</span> {</span>

	<span class="keyword">if</span> ( !<span class="keyword">this</span>.initialized )
	{
		<span class="keyword">return</span> <span class="literal">false</span>;
	}

	<span class="keyword">return</span> <span class="keyword">this</span>.intersects( <span class="keyword">new</span> verb.geom.BoundingBox(point) );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <h4 id="tolerance">TOLERANCE</h4>
<p>Defines the tolerance for bounding box operations</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.TOLERANCE = <span class="number">1e-4</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <h4 id="intervals_overlap-a1-a2-b1-b2-">intervals_overlap( a1, a2, b1, b2 )</h4>
<p>Determines if two intervals on the real number line intersect</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Beginning of first interval</li>
<li><em>Number</em>, End of first interval</li>
<li><em>Number</em>, Beginning of second interval</li>
<li><em>Number</em>, End of second interval</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Boolean</em>, true if the two intervals overlap, otherwise false</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.intervals_overlap = <span class="function"><span class="keyword">function</span><span class="params">( a1, a2, b1, b2 )</span> {</span>

	<span class="keyword">var</span> tol = verb.geom.BoundingBox.prototype.TOLERANCE
		, x1 = Math.min(a1, a2) - tol
		, x2 = Math.max(a1, a2) + tol
		, y1 = Math.min(b1, b2) - tol
		, y2 = Math.max(b1, b2) + tol;

	<span class="keyword">if</span> ( (x1 &gt;= y1 &amp;&amp; x1 &lt;= y2) || (x2 &gt;= y1 &amp;&amp; x2 &lt;= y2) || (y1 &gt;= x1 &amp;&amp; y1 &lt;= x2) || (y2 &gt;= x1 &amp;&amp; y2 &lt;= x2) )
	{
		<span class="keyword">return</span> <span class="literal">true</span>;
	}
	<span class="keyword">else</span> 
	{
		<span class="keyword">return</span> <span class="literal">false</span>;
	}

}</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <h4 id="intersects-bb-">intersects( bb )</h4>
<p>Determines if this bounding box intersects with another</p>
<p><strong>params</strong></p>
<ul>
<li><em>Object</em>, BoundingBox to check for intersection with this one</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Boolean</em>, true if the two bounding boxes intersect, otherwise false</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.intersects = <span class="function"><span class="keyword">function</span><span class="params">( bb )</span> {</span>

	<span class="keyword">if</span> ( !<span class="keyword">this</span>.initialized || !bb.initialized )
	{
		<span class="keyword">return</span> <span class="literal">false</span>;
	}

	<span class="keyword">var</span> a1 = <span class="keyword">this</span>.min
		, a2 = <span class="keyword">this</span>.max
		, b1 = bb.min
		, b2 = bb.max;

	<span class="keyword">if</span> ( <span class="keyword">this</span>.intervals_overlap(a1[<span class="number">0</span>], a2[<span class="number">0</span>], b1[<span class="number">0</span>], b2[<span class="number">0</span>]) 
			&amp;&amp; <span class="keyword">this</span>.intervals_overlap(a1[<span class="number">1</span>], a2[<span class="number">1</span>], b1[<span class="number">1</span>], b2[<span class="number">1</span>]) 
			&amp;&amp; <span class="keyword">this</span>.intervals_overlap(a1[<span class="number">2</span>], a2[<span class="number">2</span>], b1[<span class="number">2</span>], b2[<span class="number">2</span>] ) )
	{
		<span class="keyword">return</span> <span class="literal">true</span>;
	}

	<span class="keyword">return</span> <span class="literal">false</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <h4 id="clear-bb-">clear( bb )</h4>
<p>Clear the bounding box, leaving it in an uninitialized state.  Call add, add_elements in order to 
initialize</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Object</em>, this BoundingBox for chaining</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.clear = <span class="function"><span class="keyword">function</span><span class="params">( bb )</span> {</span>

	<span class="keyword">this</span>.initialized = <span class="literal">false</span>;
	<span class="keyword">return</span> <span class="keyword">this</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <h4 id="get_longest_axis-bb-">get_longest_axis( bb )</h4>
<p>Get longest axis of bounding box</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Number</em>, Index of longest axis</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.get_longest_axis = <span class="function"><span class="keyword">function</span><span class="params">( bb )</span> {</span>

	<span class="keyword">var</span> axis_lengths = [ 	<span class="keyword">this</span>.get_axis_length(<span class="number">0</span>), 
							<span class="keyword">this</span>.get_axis_length(<span class="number">1</span>), 
							<span class="keyword">this</span>.get_axis_length(<span class="number">2</span>)];

	<span class="keyword">return</span> axis_lengths.indexOf(Math.max.apply(Math, axis_lengths));

};</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <h4 id="get_axis_length-i-">get_axis_length( i )</h4>
<p>Get length of given axis. </p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Index of axis to inspect (between 0 and 2)</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Number</em>, Length of the given axis.  If axis is out of bounds, returns 0.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.get_axis_length = <span class="function"><span class="keyword">function</span><span class="params">( i )</span> {</span>

	<span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;

	<span class="keyword">return</span> Math.abs( <span class="keyword">this</span>.min[i] - <span class="keyword">this</span>.max[i] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <h4 id="intersect-bb-">intersect( bb )</h4>
<p>Compute the boolean intersection of this with another axis-aligned bounding box.  If the two
bounding boxes do not intersect, returns null.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Object</em>, BoundingBox to intersect with</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Object</em>, The bounding box formed by the intersection or null if there is no intersection.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.intersect = <span class="function"><span class="keyword">function</span><span class="params">( bb )</span> {</span>

	<span class="keyword">if</span> ( !<span class="keyword">this</span>.initialized )
	{
		<span class="keyword">return</span> <span class="literal">null</span>;
	}

	<span class="keyword">var</span> a1 = <span class="keyword">this</span>.min
		, a2 = <span class="keyword">this</span>.max
		, b1 = bb.min
		, b2 = bb.max;

	<span class="keyword">if</span> ( !<span class="keyword">this</span>.intersects(bb) )
		<span class="keyword">return</span> <span class="literal">null</span>;

	<span class="keyword">var</span> xmax = Math.min( a2[<span class="number">0</span>], b2[<span class="number">0</span>] )
		, xmin = Math.max( a1[<span class="number">0</span>], b1[<span class="number">0</span>] )
		, ymax = Math.min( a2[<span class="number">1</span>], b2[<span class="number">1</span>] )
		, ymin = Math.max( a1[<span class="number">1</span>], b1[<span class="number">1</span>] )
		, zmax = Math.min( a2[<span class="number">2</span>], b2[<span class="number">2</span>] )
		, zmin = Math.max( a1[<span class="number">2</span>], b1[<span class="number">2</span>] )
		, max_bb = [ xmax, ymax, zmax]
		, min_bb = [ xmin, ymin, zmin];

	<span class="keyword">return</span> <span class="keyword">new</span> verb.geom.BoundingBox(min_bb, max_bb);

}</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <h3 id="new-circle-center-xaxis-yaxis-xradius-yradius-">new Circle(center, xaxis, yaxis, xradius, yradius)</h3>
<p>Constructor for Circle</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the center of the circle</li>
<li><em>Array</em>, Length 3 array representing the xaxis</li>
<li><em>Array</em>, Length 3 array representing the perpendicular yaxis</li>
<li><em>Number</em>, Radius</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Circle = <span class="function"><span class="keyword">function</span><span class="params">(center, xaxis, yaxis, radius)</span> {</span>

	verb.geom.NurbsCurve.call(<span class="keyword">this</span>);
	
	<span class="keyword">this</span>.setAll({
		<span class="string">"center"</span>: center,
		<span class="string">"xaxis"</span>: xaxis,
		<span class="string">"yaxis"</span>: yaxis,
		<span class="string">"radius"</span>: radius 
	});

	<span class="keyword">this</span>.update();

	<span class="keyword">this</span>.watchAll( [<span class="string">'center'</span>, <span class="string">'xaxis'</span>, <span class="string">'yaxis'</span>, <span class="string">'radius'</span>], <span class="keyword">this</span>.update );

}.inherits(verb.geom.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Circle.prototype.nurbsRep = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	<span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'get_arc'</span>, [  <span class="keyword">this</span>.get(<span class="string">"center"</span>), 
																									 <span class="keyword">this</span>.get(<span class="string">"xaxis"</span>), 
																									 <span class="keyword">this</span>.get(<span class="string">"yaxis"</span>), 
																									 <span class="keyword">this</span>.get(<span class="string">"radius"</span>), 
																									 <span class="number">0</span>, 
																									 <span class="number">2</span> * Math.PI ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <h3 id="new-cone-axis-xaxis-base-height-radius-">new Cone(axis, xaxis, base, height, radius )</h3>
<p>Constructor for Cone</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the axis of the cone</li>
<li><em>Array</em>, Length 3 array representing the x axis, perpendicular to the axis</li>
<li><em>Array</em>, Length 3 array representing the base of the cone</li>
<li><em>Number</em>, Height of the cone</li>
<li><em>Number</em>, Radius of the cone</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Cone = <span class="function"><span class="keyword">function</span><span class="params">(axis, xaxis, base, height, radius )</span> {</span>

	verb.geom.NurbsSurface.call(<span class="keyword">this</span>);

	<span class="keyword">this</span>.setAll({
		<span class="string">"axis"</span>: axis,
		<span class="string">"xaxis"</span>: xaxis,
		<span class="string">"base"</span>: base,
		<span class="string">"height"</span>: height,
		<span class="string">"radius"</span>: radius 
	});

	<span class="keyword">var</span> surface_props = <span class="keyword">this</span>.nurbsRep();

	verb.geom.NurbsSurface.call(<span class="keyword">this</span>, surface_props.degree_u, surface_props.knots_u, surface_props.degree_v, surface_props.knots_v, surface_props.control_points, surface_props.weights );

	<span class="keyword">this</span>.watchAll( [<span class="string">'axis'</span>, <span class="string">'xaxis'</span>, <span class="string">'base'</span>, <span class="string">'height'</span>, <span class="string">'radius'</span>], <span class="keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Cone.prototype.nurbsRep = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	<span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'get_cone_surface'</span>, [ <span class="keyword">this</span>.get(<span class="string">"axis"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"xaxis"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"base"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"height"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"radius"</span>) ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <h3 id="new-cylinder-center-xaxis-yaxis-xradius-yradius-">new Cylinder(center, xaxis, yaxis, xradius, yradius)</h3>
<p>Constructor for Cylinder</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the axis of the cylinder</li>
<li><em>Array</em>, Length 3 array representing the x axis, perpendicular to the axis</li>
<li><em>Array</em>, Length 3 array representing the base of the cylinder</li>
<li><em>Number</em>, Height of the cylinder</li>
<li><em>Number</em>, Radius of the cylinder</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Cylinder = <span class="function"><span class="keyword">function</span><span class="params">(axis, xaxis, base, height, radius )</span> {</span>

	<span class="keyword">this</span>.setAll({
		<span class="string">"axis"</span>: axis,
		<span class="string">"xaxis"</span>: xaxis,
		<span class="string">"base"</span>: base,
		<span class="string">"height"</span>: height,
		<span class="string">"radius"</span>: radius 
	});

	<span class="keyword">var</span> surface_props = <span class="keyword">this</span>.nurbsRep();

	verb.geom.NurbsSurface.call(<span class="keyword">this</span>, surface_props.degree_u, surface_props.knots_u, surface_props.degree_v, surface_props.knots_v, surface_props.control_points, surface_props.weights );

	<span class="keyword">this</span>.watchAll( [<span class="string">'axis'</span>, <span class="string">'xaxis'</span>, <span class="string">'base'</span>, <span class="string">'height'</span>, <span class="string">'radius'</span>], <span class="keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Cylinder.prototype.nurbsRep = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>

  <span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'get_cylinder_surface'</span>, 
						  												 [ <span class="keyword">this</span>.get(<span class="string">"axis"</span>), 
						  												 	 <span class="keyword">this</span>.get(<span class="string">"xaxis"</span>), 
						  													 <span class="keyword">this</span>.get(<span class="string">"base"</span>), 
																				 <span class="keyword">this</span>.get(<span class="string">"height"</span>), 
																				 <span class="keyword">this</span>.get(<span class="string">"radius"</span>) ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <h3 id="new-ellipse-center-xaxis-yaxis-xradius-yradius-">new Ellipse(center, xaxis, yaxis, xradius, yradius)</h3>
<p>Constructor for EllipseArc</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the center of the arc</li>
<li><em>Array</em>, Length 3 array representing the xaxis</li>
<li><em>Array</em>, Length 3 array representing the perpendicular yaxis</li>
<li><em>Number</em>, Radius of the arc in the x direction</li>
<li><em>Number</em>, Radius of the arc in the y direction</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Ellipse = <span class="function"><span class="keyword">function</span><span class="params">(center, xaxis, yaxis, xradius, yradius)</span> {</span>

	verb.geom.NurbsCurve.call(<span class="keyword">this</span>);

	<span class="keyword">this</span>.setAll({
		<span class="string">"center"</span>: center,
		<span class="string">"xaxis"</span>: xaxis,
		<span class="string">"yaxis"</span>: yaxis,
		<span class="string">"xradius"</span>: xradius,
		<span class="string">"yradius"</span>: yradius
	});

	<span class="keyword">this</span>.update();

	<span class="keyword">this</span>.watchAll( [<span class="string">'center'</span>, <span class="string">'xaxis'</span>, <span class="string">'yaxis'</span>, <span class="string">'xradius'</span>, <span class="string">'yradius'</span>], <span class="keyword">this</span>.update );

}.inherits(verb.geom.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Ellipse.prototype.nurbsRep = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	<span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'get_ellipse_arc'</span>, [ <span class="keyword">this</span>.get(<span class="string">"center"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"xaxis"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"yaxis"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"xradius"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"yradius"</span>), 
															 <span class="number">0</span>, 
															 <span class="number">2</span> * Math.PI ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <h3 id="new-ellipsearc-center-xaxis-yaxis-xradius-yradius-interval-">new EllipseArc(center, xaxis, yaxis, xradius, yradius, interval)</h3>
<p>Constructor for EllipseArc</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the center of the arc</li>
<li><em>Array</em>, Length 3 array representing the xaxis</li>
<li><em>Array</em>, Length 3 array representing the perpendicular yaxis</li>
<li><em>Number</em>, Radius of the arc in the x direction</li>
<li><em>Number</em>, Radius of the arc in the y direction</li>
<li><em>Interval</em>, Interval object representing the interval of the arc</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.EllipseArc = <span class="function"><span class="keyword">function</span><span class="params">(center, xaxis, yaxis, xradius, yradius, interval)</span> {</span>

	verb.geom.NurbsCurve.call(<span class="keyword">this</span>);
	
	<span class="keyword">this</span>.setAll({
		<span class="string">"center"</span>: center,
		<span class="string">"xaxis"</span>: xaxis,
		<span class="string">"yaxis"</span>: yaxis,
		<span class="string">"xradius"</span>: xradius,
		<span class="string">"yradius"</span>: yradius,
		<span class="string">"interval"</span>: interval
	});

	<span class="keyword">this</span>.update();

	<span class="keyword">this</span>.watchAll( [<span class="string">'center'</span>, <span class="string">'xaxis'</span>, <span class="string">'yaxis'</span>, <span class="string">'xradius'</span>, <span class="string">'yradius'</span>, <span class="string">'interval'</span>], <span class="keyword">this</span>.update );

}.inherits(verb.geom.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.EllipseArc.prototype.nurbsRep = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	<span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'get_ellipse_arc'</span>, [ <span class="keyword">this</span>.get(<span class="string">"center"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"xaxis"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"yaxis"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"xradius"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"yradius"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"interval"</span>).get(<span class="string">"min"</span>), 
													 		 <span class="keyword">this</span>.get(<span class="string">"interval"</span>).get(<span class="string">"max"</span>)] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <h3 id="new-extrusion-p1-p2-p3-pt-">new Extrusion(p1, p2, p3, pt)</h3>
<p>Constructor for Extrusion</p>
<p><strong>params</strong></p>
<ul>
<li><em>NurbsCurve</em>, The curve to extrude</li>
<li><em>Array</em>, Length 3 representing the direction to extrude</li>
<li><em>Number</em>, The distance to extrude</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Extrusion = <span class="function"><span class="keyword">function</span><span class="params">(profile, axis, length )</span> {</span>

	verb.geom.NurbsSurface.call(<span class="keyword">this</span>);

	<span class="keyword">this</span>.setAll({ 
		  <span class="string">"profile"</span>: profile,
		  <span class="string">"axis"</span>: axis,
	      <span class="string">"length"</span>: length 
	  });

	<span class="keyword">this</span>.update();

	<span class="keyword">this</span>.watchAll( [<span class="string">'axis'</span>, <span class="string">'length'</span> ], <span class="keyword">this</span>.update );
	profile.watchAll( [<span class="string">'knots'</span>, <span class="string">'degree'</span>, <span class="string">'controlPoints'</span>, <span class="string">'weights'</span>], <span class="keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Extrusion.prototype.nurbsRep = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>

  <span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'get_extruded_surface'</span>, 
									[ <span class="keyword">this</span>.get(<span class="string">"axis"</span>), 
								 	  <span class="keyword">this</span>.get(<span class="string">"length"</span>), 
									  <span class="keyword">this</span>.get(<span class="string">"profile"</span>).get(<span class="string">"knots"</span>), 
									  <span class="keyword">this</span>.get(<span class="string">"profile"</span>).get(<span class="string">"degree"</span>), 
									  <span class="keyword">this</span>.get(<span class="string">"profile"</span>).get(<span class="string">"controlPoints"</span>),
									  <span class="keyword">this</span>.get(<span class="string">"profile"</span>).get(<span class="string">"weights"</span>)] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <h3 id="new-fourpointsurface-p1-p2-p3-pt-">new FourPointSurface(p1, p2, p3, pt)</h3>
<p>Constructor for FourPointSurface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the first position in ccw direction</li>
<li><em>Array</em>, Length 3 array representing the second position in ccw direction</li>
<li><em>Array</em>, Length 3 array representing the third position in ccw direction</li>
<li><em>Array</em>, Length 3 array representing the fourth position in ccw direction, repeat the third position to get a triangle</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.FourPointSurface = <span class="function"><span class="keyword">function</span><span class="params">(p1, p2, p3, p4)</span> {</span>

	verb.geom.NurbsSurface.call(<span class="keyword">this</span>);

	<span class="keyword">this</span>.setAll( {
		<span class="string">"p1"</span>: p1,
		<span class="string">"p2"</span>: p2,
		<span class="string">"p3"</span>: p3,
		<span class="string">"p4"</span>: p4
	});

	<span class="keyword">this</span>.update();

	<span class="keyword">this</span>.watchAll( [<span class="string">'p1'</span>, <span class="string">'p2'</span>, <span class="string">'p3'</span>, <span class="string">'p4'</span>], <span class="keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.FourPointSurface.prototype.nurbsRep = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	<span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'get_4pt_surface'</span>, [ <span class="keyword">this</span>.get(<span class="string">"p1"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"p2"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"p3"</span>), 
															 <span class="keyword">this</span>.get(<span class="string">"p4"</span>) ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <h3 id="new-interval-min-max-">new Interval(min, max)</h3>
<p>Constructor for Interval</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Start of interval </li>
<li><em>Number</em>, End of the interval </li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Interval = <span class="function"><span class="keyword">function</span><span class="params">(min, max)</span> {</span>

	verb.core.WatchObject.call(<span class="keyword">this</span>);
	
	<span class="keyword">this</span>.setAll({ 
		<span class="string">"min"</span>: min,
		<span class="string">"max"</span>: max 
	});

}.inherits(verb.core.WatchObject);</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <h3 id="new-interval2-minu-maxu-minv-maxv-">new Interval2(minu, maxu, minv, maxv)</h3>
<p>Constructor for Interval2</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Start of interval in the u direction</li>
<li><em>Number</em>, End of the interval in the u direction</li>
<li><em>Number</em>, Start of interval in the v direction</li>
<li><em>Number</em>, End of the interval in the v direction</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Interval2 = <span class="function"><span class="keyword">function</span><span class="params">(minu, maxu, minv, maxv)</span> {</span>

	verb.core.WatchObject.call(<span class="keyword">this</span>);
	
	<span class="keyword">this</span>.setAll({ 
		<span class="string">"uinterval"</span>: <span class="keyword">new</span> verb.geom.Interval(minu, maxu),
		<span class="string">"vinterval"</span>: <span class="keyword">new</span> verb.geom.Interval(minv, maxv)
	});

}.inherits(verb.core.WatchObject);</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <h3 id="new-line-start-end-">new Line(start, end)</h3>
<p>Constructor for a Line</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the start point</li>
<li><em>Array</em>, Length 3 array representing the end point</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Line = <span class="function"><span class="keyword">function</span><span class="params">(start, end)</span> {</span>

	verb.geom.NurbsCurve.call(<span class="keyword">this</span>);

	<span class="keyword">this</span>.setAll({ 
		<span class="string">"start"</span>: start,
		<span class="string">"end"</span>: end
	});

	<span class="keyword">this</span>.update();

	<span class="keyword">this</span>.watchAll([<span class="string">'start'</span>, <span class="string">'end'</span>], <span class="keyword">this</span>.update );

}.inherits(verb.geom.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Line.prototype.nurbsRep = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	<span class="keyword">return</span> {
			knots: [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], 
			control_points: [ <span class="keyword">this</span>.get(<span class="string">"start"</span>), <span class="keyword">this</span>.get(<span class="string">"end"</span>) ],
			weights: [<span class="number">1</span>,<span class="number">1</span>],
			degree: <span class="number">1</span>
	};

};</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <h3 id="new-planarsurface-base-uaxis-vaxis-ulength-vlength-">new PlanarSurface( base, uaxis, vaxis, ulength, vlength )</h3>
<p>Constructor for PlanarSurface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the base point</li>
<li><em>Array</em>, Length 3 array representing the uaxis, defines the one axis of the planar surface</li>
<li><em>Array</em>, Length 3 array representing the vaxis, defines the one second axis of the planar surface</li>
<li><em>Number</em>, Length in the u direction </li>
<li><em>Number</em>, Length in the v direction</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.PlanarSurface = <span class="function"><span class="keyword">function</span><span class="params">( base, uaxis, vaxis, ulength, vlength )</span> {</span>

	verb.geom.NurbsSurface.call(<span class="keyword">this</span>);

	<span class="keyword">this</span>.setAll({
		<span class="string">"base"</span>: base,
		<span class="string">"uaxis"</span>: uaxis,
		<span class="string">"vaxis"</span>: vaxis,
		<span class="string">"ulength"</span>: ulength,
		<span class="string">"vlength"</span>: vlength
	});

	<span class="keyword">this</span>.update();

	<span class="keyword">this</span>.watchAll( [<span class="string">'base'</span>, <span class="string">'uaxis'</span>, <span class="string">'vaxis'</span>, <span class="string">'ulength'</span>, <span class="string">'vlength'</span>], <span class="keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.PlanarSurface.prototype.nurbsRep = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	<span class="keyword">var</span> p1 = <span class="keyword">this</span>.get(<span class="string">'base'</span>)
		, uedge = numeric.mul( <span class="keyword">this</span>.get(<span class="string">'uaxis'</span>), <span class="keyword">this</span>.get(<span class="string">'ulength'</span>))
		, vedge = numeric.mul( <span class="keyword">this</span>.get(<span class="string">'vaxis'</span>), <span class="keyword">this</span>.get(<span class="string">'vlength'</span>))
		, p2 = numeric.add( p1, uedge )
		, p3 = numeric.add( p1, vedge, uedge )
		, p4 = numeric.add( p1, vedge );

	<span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'get_4pt_surface'</span>, [ p1, p2, p3, p4 ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <h3 id="new-polyline-points-">new PolyLine( points )</h3>
<p>Constructor for a PolyLine</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Array of length-3 arrays representing the points</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.PolyLine = <span class="function"><span class="keyword">function</span><span class="params">( points )</span> {</span>

	verb.geom.NurbsCurve.call(<span class="keyword">this</span>);

	<span class="keyword">this</span>.setAll( {
		<span class="string">"control_points"</span>: points ? points.slice(<span class="number">0</span>) : []
	});

	<span class="keyword">this</span>.update();

}.inherits(verb.geom.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.PolyLine.prototype.nurbsRep = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	<span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'get_polyline_curve'</span>, [ <span class="keyword">this</span>.get(<span class="string">"control_points"</span>) ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <h3 id="new-revolvedsurface-points-">new RevolvedSurface( points )</h3>
<p>Constructor for a RevolvedSurface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing a point on the revolve axis</li>
<li><em>Array</em>, The axis of the revolve</li>
<li><em>Array</em>, The angle to revolve on</li>
<li><em>NurbsCurve</em>, The curve to revolve</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.RevolvedSurface = <span class="function"><span class="keyword">function</span><span class="params">( center, axis, angle, profile )</span> {</span>

	verb.geom.NurbsSurface.call(<span class="keyword">this</span>);

	<span class="keyword">this</span>.setAll({
		<span class="string">"center"</span>: center,
		<span class="string">"axis"</span>: axis,
		<span class="string">"angle"</span>: angle,
		<span class="string">"profile"</span>: profile
	});

	<span class="keyword">this</span>.update();

	<span class="keyword">this</span>.watchAll( [<span class="string">'center'</span>, <span class="string">'axis'</span>, <span class="string">'angle'</span>, <span class="string">'profile'</span>], <span class="keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.RevolvedSurface.prototype.nurbsRep = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

	  <span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'get_revolved_surface'</span>, 
									[ <span class="keyword">this</span>.get(<span class="string">"center"</span>), 
									  <span class="keyword">this</span>.get(<span class="string">"axis"</span>), 
									  <span class="keyword">this</span>.get(<span class="string">"angle"</span>), 
									  <span class="keyword">this</span>.get(<span class="string">"profile"</span>).get(<span class="string">"knots"</span>), 
									  <span class="keyword">this</span>.get(<span class="string">"profile"</span>).get(<span class="string">"degree"</span>), 
									  <span class="keyword">this</span>.get(<span class="string">"profile"</span>).get(<span class="string">"controlPoints"</span>),
									  <span class="keyword">this</span>.get(<span class="string">"profile"</span>).get(<span class="string">"weights"</span>)] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <h3 id="new-sphere-center-radius-">new Sphere( center, radius )</h3>
<p>Constructor for a Sphere</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the center</li>
<li><em>Number</em>, Radius of the sphere</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Sphere = <span class="function"><span class="keyword">function</span><span class="params">( center, radius )</span> {</span>

	verb.geom.NurbsSurface.call(<span class="keyword">this</span>);

	<span class="keyword">this</span>.setAll({
		<span class="string">"center"</span>: center,
		<span class="string">"radius"</span>: radius
	});

	<span class="keyword">this</span>.update();
	<span class="keyword">this</span>.watchAll( [<span class="string">'center'</span>, <span class="string">'radius'</span>], <span class="keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Sphere.prototype.nurbsRep = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

  <span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'get_sphere_surface'</span>, 
										[ <span class="keyword">this</span>.get(<span class="string">"center"</span>), 
										  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],
										  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],
										  <span class="keyword">this</span>.get(<span class="string">"radius"</span>)] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <h3 id="new-sweeponerail-rail-profile-">new SweepOneRail( rail, profile )</h3>
<p>Constructor for a SweepOneRail</p>
<p><strong>params</strong></p>
<ul>
<li><em>NurbsCurve</em>, The path to sweep on</li>
<li><em>NurbsCurve</em>, The profile to sweep</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.SweepOneRail = <span class="function"><span class="keyword">function</span><span class="params">( rail, profile )</span> {</span>

	verb.geom.NurbsSurface.call(<span class="keyword">this</span>);

	<span class="keyword">this</span>.setAll({
		<span class="string">"rail"</span>: rail,
		<span class="string">"profile"</span>: profile
	});

	<span class="keyword">this</span>.update();

	<span class="keyword">this</span>.watchAll( [<span class="string">'rail'</span>, <span class="string">'profile'</span>], <span class="keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.SweepOneRail.prototype.nurbsRep = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
	
  <span class="keyword">return</span> <span class="keyword">this</span>.nurbsEngine.eval( <span class="string">'get_sweep1_surface'</span>, 
										[ <span class="keyword">this</span>.get(<span class="string">"profile"</span>).get(<span class="string">"knots"</span>), 
										  <span class="keyword">this</span>.get(<span class="string">"profile"</span>).get(<span class="string">"degree"</span>),
										  <span class="keyword">this</span>.get(<span class="string">"profile"</span>).get(<span class="string">"controlPoints"</span>),
										  <span class="keyword">this</span>.get(<span class="string">"profile"</span>).get(<span class="string">"weights"</span>),
										  <span class="keyword">this</span>.get(<span class="string">"rail"</span>).get(<span class="string">"knots"</span>),
										  <span class="keyword">this</span>.get(<span class="string">"rail"</span>).get(<span class="string">"degree"</span>),
										  <span class="keyword">this</span>.get(<span class="string">"rail"</span>).get(<span class="string">"controlPoints"</span>),
										  <span class="keyword">this</span>.get(<span class="string">"rail"</span>).get(<span class="string">"weights"</span>)] );

};



verb.intersect.curveCurve = <span class="function"><span class="keyword">function</span><span class="params">( curve1, curve2, callback )</span>{</span>

	<span class="keyword">if</span> (curve1 <span class="keyword">instanceof</span> verb.geom.NurbsCurve &amp;&amp; curve2 <span class="keyword">instanceof</span> verb.geom.NurbsCurve ){

		<span class="keyword">return</span> verb.nurbsEngine.eval( <span class="string">'intersect_rational_curves_by_aabb'</span>, 
							[ 	curve1.get(<span class="string">'degree'</span>), curve1.get(<span class="string">'knots'</span>), curve1.homogenize(), curve2.get(<span class="string">'degree'</span>), curve2.get(<span class="string">'knots'</span>), curve2.homogenize(), verb.TOLERANCE ], callback );


	}

}</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <h3 id="verb-eval">verb.eval</h3>
<p>This defines verb&#39;s core geometry library which is called by the current Engine.</p>
<h4 id="get_sweep1_surface-profile_knots-profile_degree-profile_control_points-profile_weights-rail_knots-rail_degree-rail_control_points-rail_weights-">get_sweep1_surface( profile_knots, profile_degree, profile_control_points, profile_weights, rail_knots, rail_degree, rail_control_points, rail_weights )</h4>
<p>Generate the control points, weights, and knots of an elliptical arc</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, the center</li>
<li><em>Array</em>, the xaxis</li>
<li><em>Array</em>, orthogonal yaxis</li>
<li><em>Number</em>, xradius of the ellipse arc</li>
<li><em>Number</em>, yradius of the ellipse arc</li>
<li><em>Number</em>, start angle of the ellipse arc, between 0 and 2pi, where 0 points at the xaxis</li>
<li><em>Number</em>, end angle of the arc, between 0 and 2pi, greater than the start angle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_sweep1_surface = <span class="function"><span class="keyword">function</span><span class="params">( profile_knots, profile_degree, profile_control_points, profile_weights, rail_knots, rail_degree, rail_control_points, rail_weights )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>for each point on rail, move all of the points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> homo_rail = verb.eval.nurbs.homogenize_1d( rail_control_points, rail_weights )
		, rail_start = verb.eval.nurbs.rational_curve_point( rail_degree, rail_knots, homo_rail, <span class="number">0</span> )
		, span = <span class="number">1.0</span> / rail_control_points.length
		, control_points = []
		, weights = [];

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rail_control_points.length; i++ ){</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>evaluate the point on the curve, subtracting it from the first point</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="keyword">var</span> rail_point = verb.eval.nurbs.rational_curve_point( rail_degree, rail_knots, homo_rail, i * span )
			, rail_offset = numeric.sub( rail_point, rail_start )
			, row_control_points = []
			, row_weights = [];

		<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; profile_control_points.length; j++ ){

			row_control_points.push( numeric.add(rail_offset, profile_control_points[j] ) );
			row_weights.push( profile_weights[j] * rail_weights[i] );

		}

		control_points.push( row_control_points);
		weights.push( row_weights );
	}

	<span class="keyword">return</span> {<span class="string">"knots_u"</span>: rail_knots, 
			<span class="string">"knots_v"</span>: profile_knots,
			<span class="string">"control_points"</span>: control_points, 
			<span class="string">"degree_u"</span>: rail_degree, 
			<span class="string">"degree_v"</span>: profile_degree, 
			<span class="string">"weights"</span>: weights };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <h4 id="get_ellipse_arc-center-xaxis-yaxis-xradius-yradius-start_angle-end_angle-">get_ellipse_arc( center, xaxis, yaxis, xradius, yradius, start_angle, end_angle )</h4>
<p>Generate the control points, weights, and knots of an elliptical arc</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, the center</li>
<li><em>Array</em>, the xaxis</li>
<li><em>Array</em>, orthogonal yaxis</li>
<li><em>Number</em>, xradius of the ellipse arc</li>
<li><em>Number</em>, yradius of the ellipse arc</li>
<li><em>Number</em>, start angle of the ellipse arc, between 0 and 2pi, where 0 points at the xaxis</li>
<li><em>Number</em>, end angle of the arc, between 0 and 2pi, greater than the start angle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_ellipse_arc = <span class="function"><span class="keyword">function</span><span class="params">( center, xaxis, yaxis, xradius, yradius, start_angle, end_angle )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>if the end angle is less than the start angle, do a circle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">if</span> (end_angle &lt; start_angle) end_angle = <span class="number">2</span> * Math.PI + start_angle;

	<span class="keyword">var</span> theta = end_angle - start_angle
		, narcs = <span class="number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>how many arcs?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">if</span> (theta &lt;= Math.PI / <span class="number">2</span>) {
		narcs = <span class="number">1</span>;
	} <span class="keyword">else</span> {
		<span class="keyword">if</span> (theta &lt;= Math.PI){
			narcs = <span class="number">2</span>;
		} <span class="keyword">else</span> <span class="keyword">if</span> (theta &lt;= <span class="number">3</span> * Math.PI / <span class="number">2</span>){
			narcs = <span class="number">3</span>;
		} <span class="keyword">else</span> {
			narcs = <span class="number">4</span>;
		}
	}

	<span class="keyword">var</span> dtheta = theta / narcs
		, n = <span class="number">2</span> * narcs
		, w1 = Math.cos( dtheta / <span class="number">2</span>) 
		, P0 = numeric.add( center, numeric.mul( xradius, Math.cos(start_angle), xaxis), numeric.mul( yradius, Math.sin(start_angle), yaxis ) )
		, T0 = numeric.sub( numeric.mul( Math.cos(start_angle), yaxis ), numeric.mul( Math.sin(start_angle), xaxis) )
		, Pw = verb.eval.nurbs.zeros_1d( narcs * <span class="number">2</span> )
		, U = verb.eval.nurbs.zeros_1d( <span class="number">2</span> *narcs + <span class="number">3</span> )
		, index = <span class="number">0</span>
		, angle = start_angle
		, W = verb.eval.nurbs.zeros_1d( narcs * <span class="number">2</span> );

	Pw[<span class="number">0</span>] = P0;
	W[<span class="number">0</span>] = <span class="number">1</span>;

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= narcs; i++){

		angle += dtheta;
		<span class="keyword">var</span> P2 = numeric.add( center, numeric.mul( xradius, Math.cos(angle), xaxis), numeric.mul( yradius, Math.sin(angle), yaxis ) )

		W[index+<span class="number">2</span>] = <span class="number">1</span>;
		Pw[index+<span class="number">2</span>] = P2;

		<span class="keyword">var</span> T2 = numeric.sub( numeric.mul( Math.cos(angle), yaxis ), numeric.mul( Math.sin(angle), xaxis) )

		<span class="keyword">var</span> params = verb.eval.geom.intersect_rays(P0, numeric.mul( <span class="number">1</span> / numeric.norm2(T0), T0), P2, numeric.mul( <span class="number">1</span> / numeric.norm2(T2), T2));
		<span class="keyword">var</span> P1 = numeric.add( P0, numeric.mul(T0, params[<span class="number">0</span>]));

		W[index+<span class="number">1</span>] = w1;
		Pw[index+<span class="number">1</span>] = P1;

		index += <span class="number">2</span>;

		<span class="keyword">if</span> (i &lt; narcs){
			P0 = P2;
			T0 = T2;
		}
	}

	<span class="keyword">var</span> j = <span class="number">2</span> *  narcs + <span class="number">1</span>;

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++){
		U[i] = <span class="number">0.0</span>;
		U[i+j] = <span class="number">1.0</span>;
	}

	<span class="keyword">switch</span> (narcs){
		<span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">break</span>;
		<span class="keyword">case</span> <span class="number">2</span>: U[<span class="number">3</span>] = U[<span class="number">4</span>] = <span class="number">0.5</span>; <span class="keyword">break</span>;
		<span class="keyword">case</span> <span class="number">3</span>: U[<span class="number">3</span>] = U[<span class="number">4</span>] = <span class="number">1</span>/<span class="number">3</span>;
						U[<span class="number">5</span>] = U[<span class="number">6</span>] = <span class="number">2</span>/<span class="number">3</span>; <span class="keyword">break</span>;
		<span class="keyword">case</span> <span class="number">4</span>: U[<span class="number">3</span>] = U[<span class="number">4</span>] = <span class="number">0.25</span>;
						U[<span class="number">5</span>] = U[<span class="number">6</span>] = <span class="number">0.5</span>;
						U[<span class="number">7</span>] = U[<span class="number">8</span>] = <span class="number">0.75</span>; <span class="keyword">break</span>;
	}

	<span class="keyword">return</span> {knots: U, control_points: Pw, degree: <span class="number">2</span>, weights: W };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <h4 id="get_sphere_surface-center-axis-xaxis-radius-">get_sphere_surface( center, axis, xaxis, radius )</h4>
<p>Generate the control points, weights, and knots of a sphere</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, the center of the sphere</li>
<li><em>Array</em>, normalized axis of sphere</li>
<li><em>Array</em>, vector perpendicular to axis of sphere, starting the rotation of the sphere</li>
<li><em>Number</em>, radius of the sphere</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots_u, knots_v, degree_u, degree_v</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_sphere_surface = <span class="function"><span class="keyword">function</span><span class="params">( center, axis, xaxis, radius )</span>{</span>

	<span class="keyword">var</span> arc = verb.eval.nurbs.get_arc(center, numeric.mul(axis, -<span class="number">1</span>), xaxis, radius, <span class="number">0</span>, Math.PI );

	<span class="keyword">return</span> verb.eval.nurbs.get_revolved_surface( center, axis, <span class="number">2</span> * Math.PI, arc.knots, arc.degree, arc.control_points, arc.weights );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <h4 id="get_polyline_curve-pts-">get_polyline_curve( pts )</h4>
<p>Generate the control points, weights, and knots of a polyline curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of points in curve</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_polyline_curve = <span class="function"><span class="keyword">function</span><span class="params">( pts )</span>{</span>

	<span class="keyword">var</span> num_spans = pts.length - <span class="number">1</span>
		, span = <span class="number">1.0</span> / num_spans
		, knots = [<span class="number">0</span>,<span class="number">0</span>];

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; num_spans; i++){
		knots.push(i * span);
	}

	knots.push(<span class="number">1</span>);
	knots.push(<span class="number">1</span>);

	<span class="keyword">var</span> weights = [];

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pts.length; i++){
		weights.push(<span class="number">1</span>);
	}

	<span class="keyword">return</span> {
			<span class="string">"knots"</span>: knots, 
			<span class="string">"control_points"</span>: pts.slice(<span class="number">0</span>), 
			<span class="string">"degree"</span>: <span class="number">1</span>,
			<span class="string">"weights"</span>: weights 
		};
			
}</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <h4 id="get_4pt_surface-p1-p2-p3-p4-">get_4pt_surface( p1, p2, p3, p4 )</h4>
<p>Generate the control points, weights, and knots of a surface define by 3 points</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, first point in counter-clockwise form</li>
<li><em>Array</em>, second point in counter-clockwise form</li>
<li><em>Array</em>, third point in counter-clockwise form</li>
<li><em>Array</em>, forth point in counter-clockwise form</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots_u, knots_v, degree_u, degree_v</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_4pt_surface = <span class="function"><span class="keyword">function</span><span class="params">( p1, p2, p3, p4 )</span>{</span>

	<span class="keyword">return</span> {<span class="string">"knots_u"</span>: [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], 
			<span class="string">"knots_v"</span>: [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], 
			<span class="string">"control_points"</span>: [ [p1, p4], [p2, p3] ], 
			<span class="string">"degree_u"</span>: <span class="number">1</span>, 
			<span class="string">"degree_v"</span>: <span class="number">1</span>,
			<span class="string">"weights"</span>: [ [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>] ] };
			
}</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <h4 id="get_cylinder_surface-axis-xaxis-base-height-radius-">get_cylinder_surface( axis, xaxis, base, height, radius )</h4>
<p>Generate the control points, weights, and knots of a cylinder</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, normalized axis of cylinder</li>
<li><em>Array</em>, xaxis in plane of cylinder</li>
<li><em>Array</em>, position of base of cylinder</li>
<li><em>Number</em>, height from base to top</li>
<li><em>Number</em>, radius of the cylinder</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots_u, knots_v, degree_u, degree_v</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_cylinder_surface = <span class="function"><span class="keyword">function</span><span class="params">( axis, xaxis, base, height, radius )</span>{</span>

	<span class="keyword">var</span> yaxis = crossprod( axis, xaxis )
		, angle = <span class="number">2</span> * Math.PI
		, circ = verb.eval.nurbs.get_arc( base, xaxis, yaxis, radius, <span class="number">0</span>, <span class="number">2</span> * Math.PI );

	<span class="keyword">return</span> verb.eval.nurbs.get_extruded_surface( axis, height, circ.knots, circ.degree, circ.control_points, circ.weights );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <h4 id="get_cone_surface-axis-xaxis-base-height-radius-">get_cone_surface( axis, xaxis, base, height, radius )</h4>
<p>Generate the control points, weights, and knots of a cone</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, normalized axis of cone</li>
<li><em>Array</em>, position of base of cone</li>
<li><em>Number</em>, height from base to tip</li>
<li><em>Number</em>, radius at the base of the cone</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_cone_surface = <span class="function"><span class="keyword">function</span><span class="params">( axis, xaxis, base, height, radius )</span>{</span>

	<span class="keyword">var</span> angle = <span class="number">2</span> * Math.PI
		, prof_degree = <span class="number">1</span>
		, prof_ctrl_pts = [ numeric.add( base, numeric.mul( height, axis ) ), numeric.add( base, numeric.mul( radius, xaxis ) )]
		, prof_knots = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]
		, prof_weights = [<span class="number">1</span>,<span class="number">1</span>];

	<span class="keyword">return</span> verb.eval.nurbs.get_revolved_surface(base, axis, angle, prof_knots, prof_degree, prof_ctrl_pts, prof_weights);

}</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <h4 id="get_extruded_surface-axis-length-prof_knots-prof_degree-prof_control_points-prof_weights-">get_extruded_surface( axis, length, prof_knots, prof_degree, prof_control_points, prof_weights)</h4>
<p>Generate the control points, weights, and knots of an extruded surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, axis of the extrusion</li>
<li><em>Array</em>, length of the extrusion</li>
<li><em>Number</em>, degree of the profile</li>
<li><em>Number</em>, control points of the profile</li>
<li><em>Number</em>, weights of the profile</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_extruded_surface = <span class="function"><span class="keyword">function</span><span class="params">( axis, length, prof_knots, prof_degree, prof_control_points, prof_weights)</span>{</span>

	<span class="keyword">var</span> control_points = verb.eval.nurbs.zeros_2d( <span class="number">2</span>, prof_control_points.length )
		, weights = verb.eval.nurbs.zeros_2d( <span class="number">2</span>, prof_control_points.length );</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>original control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; prof_control_points.length; j++){
		control_points[<span class="number">0</span>][j] = prof_control_points[j];
		weights[<span class="number">0</span>][j] = prof_weights[j];
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>build translated control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> translation = numeric.mul(axis, length);

	<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; prof_control_points.length; j++){
		control_points[<span class="number">1</span>][j] = numeric.add( translation, prof_control_points[j] );
		weights[<span class="number">1</span>][j] = prof_weights[j];
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>return all parameters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">return</span> {<span class="string">"knots_u"</span>: [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], 
			<span class="string">"knots_v"</span>: prof_knots, 
			<span class="string">"control_points"</span>: control_points, 
			<span class="string">"degree_u"</span>: <span class="number">1</span>, 
			<span class="string">"degree_v"</span>: prof_degree, 
			<span class="string">"weights"</span>: weights };
}</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <h4 id="get_revolved_surface-center-axis-theta-prof_knots-prof_degree-prof_control_points-prof_weights-">get_revolved_surface( center, axis, theta, prof_knots, prof_degree, prof_control_points, prof_weights)</h4>
<p>Generate the control points, weights, and knots of a revolved surface
(Corresponds to Algorithm A7.1 from Piegl &amp; Tiller)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, center of the rotation axis</li>
<li><em>Array</em>, axis of the rotation axis</li>
<li><em>Number</em>, angle to revolve around axis</li>
<li><em>Number</em>, degree of the generatrix</li>
<li><em>Number</em>, control points of the generatrix</li>
<li><em>Number</em>, weights of the generatrix</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>
<p>helper method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">crossprod</span><span class="params">(u,v)</span> {</span>
  <span class="keyword">return</span> [u[<span class="number">1</span>]*v[<span class="number">2</span>]-u[<span class="number">2</span>]*v[<span class="number">1</span>],u[<span class="number">2</span>]*v[<span class="number">0</span>]-u[<span class="number">0</span>]*v[<span class="number">2</span>],u[<span class="number">0</span>]*v[<span class="number">1</span>]-u[<span class="number">1</span>]*v[<span class="number">0</span>]];
}

verb.eval.nurbs.get_revolved_surface = <span class="function"><span class="keyword">function</span><span class="params">( center, axis, theta, prof_knots, prof_degree, prof_control_points, prof_weights)</span>{</span>

	<span class="keyword">var</span> narcs, knots_u, control_points, weights;

	<span class="keyword">if</span> (theta &lt;= Math.PI / <span class="number">2</span>) { <span class="comment">// less than 90</span>
		narcs = <span class="number">1</span>;
		knots_u = verb.eval.nurbs.zeros_1d( <span class="number">6</span> + <span class="number">2</span>  * (narcs-<span class="number">1</span>) );
	} <span class="keyword">else</span> {
		<span class="keyword">if</span> (theta &lt;= Math.PI){  <span class="comment">// between 90 and 180</span>
			narcs = <span class="number">2</span>;
			knots_u = verb.eval.nurbs.zeros_1d( <span class="number">6</span> + <span class="number">2</span> * (narcs-<span class="number">1</span>) );
			knots_u[<span class="number">3</span>]= knots_u[<span class="number">4</span>] = <span class="number">0.5</span>;
		} <span class="keyword">else</span> <span class="keyword">if</span> (theta &lt;= <span class="number">3</span> * Math.PI / <span class="number">2</span>){ <span class="comment">// between 180 and 270</span>
			narcs = <span class="number">3</span>;
			knots_u = verb.eval.nurbs.zeros_1d( <span class="number">6</span> + <span class="number">2</span> * (narcs-<span class="number">1</span>) );
			knots_u[<span class="number">3</span>]= knots_u[<span class="number">4</span>] = <span class="number">1</span>/<span class="number">3</span>;
			knots_u[<span class="number">5</span>]= knots_u[<span class="number">6</span>] = <span class="number">2</span>/<span class="number">3</span>;
		} <span class="keyword">else</span> { <span class="comment">// between 270 and 360</span>
			narcs = <span class="number">4</span>;
			knots_u = verb.eval.nurbs.zeros_1d( <span class="number">6</span> + <span class="number">2</span> * (narcs-<span class="number">1</span>) );
			knots_u[<span class="number">3</span>]= knots_u[<span class="number">4</span>] = <span class="number">1</span>/<span class="number">4</span>;
			knots_u[<span class="number">5</span>]= knots_u[<span class="number">6</span>] = <span class="number">1</span>/<span class="number">2</span>;
			knots_u[<span class="number">7</span>]= knots_u[<span class="number">8</span>] = <span class="number">3</span>/<span class="number">4</span>;
		}
	}

	<span class="keyword">var</span> dtheta = theta / narcs <span class="comment">// divide the interval into several points</span>
		, j = <span class="number">3</span> + <span class="number">2</span> * (narcs-<span class="number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>initialize the start and end knots
keep in mind that we only return the knot vector for the </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; j++, i++){
		knots_u[i] = <span class="number">0.0</span>;
		knots_u[j] = <span class="number">1.0</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>do some initialization</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> n = <span class="number">2</span> * narcs 
		, wm = Math.cos( dtheta/<span class="number">2.0</span> )
		, angle = <span class="number">0.0</span>
		, sines = verb.eval.nurbs.zeros_1d( narcs + <span class="number">1</span>)
		, cosines = verb.eval.nurbs.zeros_1d( narcs + <span class="number">1</span>)
		, control_points = verb.eval.nurbs.zeros_2d( <span class="number">2</span>*narcs + <span class="number">1</span>, prof_control_points.length )
		, weights = verb.eval.nurbs.zeros_2d( <span class="number">2</span>*narcs + <span class="number">1</span>, prof_control_points.length );</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <p>initialize the sines and cosines</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= narcs; i++){
		angle += dtheta;
		cosines[i] = Math.cos(angle);
		sines[i] = Math.sin(angle);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <p>for each pt in the generatrix
i.e. for each row of the 2d knot vectors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; prof_control_points.length; j++){</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>get the closest point of the generatrix point on the axis</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="keyword">var</span> O = verb.eval.geom.closest_point_on_ray(prof_control_points[j], center, axis)</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p>X is the vector from the axis to generatrix control pt</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			, X = numeric.sub( prof_control_points[j], O )</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>radius at that height</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			, r = numeric.norm2(X)</pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>Y is perpendicular to X and axis, and complete the coordinate system</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			, Y = crossprod(axis,X); 

		<span class="keyword">if</span> ( r &gt; verb.EPSILON ){
			X = numeric.mul( <span class="number">1</span> / r, X);
			Y = numeric.mul( <span class="number">1</span> / r, Y);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>the first row of control_points and weights is just the generatrix</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		control_points[<span class="number">0</span>][j] = prof_control_points[j];
		<span class="keyword">var</span> P0 = prof_control_points[j];
		weights[<span class="number">0</span>][j] = prof_weights[j];</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p>store T0 as the Y vector</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="keyword">var</span> T0 = Y
			, index = <span class="number">0</span>
			, angle = <span class="number">0.0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p>proceed around the circle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= narcs; i++){</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>O + r <em> cos(theta) </em> X + r <em> sin(theta) </em> Y
rotated generatrix pt</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="keyword">var</span> P2 = r == <span class="number">0</span> ? O : numeric.add( O, numeric.mul( r, cosines[i], X), numeric.mul( r, sines[i], Y) );

			control_points[index+<span class="number">2</span>][j] = P2;
			weights[index+<span class="number">2</span>][j] = prof_weights[j];</pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>construct the vector tangent to the rotation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="keyword">var</span> T2 = numeric.sub( numeric.mul( cosines[i], Y), numeric.mul(sines[i], X));</pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p>construct the next control pt</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="keyword">if</span> (r == <span class="number">0</span>){
				control_points[index+<span class="number">1</span>][j] = O;
			} <span class="keyword">else</span> {
				<span class="keyword">var</span> params = verb.eval.geom.intersect_rays(P0, numeric.mul( <span class="number">1</span> / numeric.norm2(T0), T0), P2, numeric.mul( <span class="number">1</span> / numeric.norm2(T2), T2));
				<span class="keyword">var</span> P1 = numeric.add( P0, numeric.mul(T0, params[<span class="number">0</span>]));

				control_points[index+<span class="number">1</span>][j] = P1;
			}

			weights[index+<span class="number">1</span>][j] = wm * prof_weights[j];

			index += <span class="number">2</span>;

			<span class="keyword">if</span> (i &lt; narcs)
			{
				P0 = P2;
				T0 = T2;
			}

		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>store all of the parameters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">return</span> {<span class="string">"knots_u"</span>: knots_u, 
			<span class="string">"knots_v"</span>: prof_knots, 
			<span class="string">"control_points"</span>: control_points, 
			<span class="string">"degree_u"</span>: <span class="number">2</span>, 
			<span class="string">"degree_v"</span>: prof_degree, 
			<span class="string">"weights"</span>: weights };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <h4 id="get_arc-center-xaxis-yaxis-radius-start_angle-end_angle-">get_arc( center, xaxis, yaxis, radius, start_angle, end_angle )</h4>
<p>Generate the control points, weights, and knots of an arbitrary arc
(Corresponds to Algorithm A7.1 from Piegl &amp; Tiller)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, the center of the arc</li>
<li><em>Array</em>, the xaxis of the arc</li>
<li><em>Array</em>, orthogonal yaxis of the arc</li>
<li><em>Number</em>, radius of the arc</li>
<li><em>Number</em>, start angle of the arc, between 0 and 2pi</li>
<li><em>Number</em>, end angle of the arc, between 0 and 2pi, greater than the start angle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_arc = <span class="function"><span class="keyword">function</span><span class="params">( center, xaxis, yaxis, radius, start_angle, end_angle )</span> {</span>

	<span class="keyword">return</span> verb.eval.nurbs.get_ellipse_arc( center, xaxis, yaxis, radius, radius, start_angle, end_angle );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <h4 id="intersect_rational_surfaces-not-sure-yet-">intersect_rational_surfaces( not, sure, yet )</h4>
<p>Intersect two NURBS surfaces</p>
<p><strong>params</strong></p>
<p><strong>returns</strong> </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.intersect_rational_surfaces = <span class="function"><span class="keyword">function</span><span class="params">( not, sure, yet )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <p>tesselate two nurbs surfaces
verb.eval.mesh.intersect_meshes_by_aabb
refine the curves using the two surfaces</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>}</pre></div></div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>
              <h4 id="intersect_meshes-vertices1-triangles1-uvs1-aabb1-vertices2-triangles2-uvs2-aabb2-">intersect_meshes( vertices1, triangles1, uvs1, aabb1, vertices2, triangles2, uvs2, aabb2)</h4>
<p>Intersect two meshes</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, top to bottom is increasing u direction, left to right is increasing v direction,
and where each control point is an array of length (dim+1)</li>
<li><em>Number</em>, u parameter at which to evaluate the surface point</li>
<li><em>Number</em>, v parameter at which to evaluate the surface point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.mesh.intersect_meshes = <span class="function"><span class="keyword">function</span><span class="params">( vertices1, triangles1, uvs1, aabb1, vertices2, triangles2, uvs2, aabb2)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>
              <p>tesselate two nurbs surfaces</p>
<p>call subroutine to:
put polygons into kd trees
intersect polygons via kd trees
build up curves
return poly line curves for further refinement</p>
<p>return collection of lists of points with parameter values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>}</pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <h4 id="intersect_meshes_by_aabb-points1-tris1-uvs1-points2-tris2-uvs2-">intersect_meshes_by_aabb( points1, tris1, uvs1, points2, tris2, uvs2 )</h4>
<p>Intersect two meshes via aabb intersection</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, top to bottom is increasing u direction, left to right is increasing v direction,
and where each control point is an array of length (dim+1)</li>
<li><em>Number</em>, u parameter at which to evaluate the surface point</li>
<li><em>Number</em>, v parameter at which to evaluate the surface point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.mesh.intersect_meshes_by_aabb = <span class="function"><span class="keyword">function</span><span class="params">( points1, tris1, uvs1, points2, tris2, uvs2 )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <p>build aabb for each mesh</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> tri_indices1 = _.range(tris1.length)
	  , tri_indices2 = _.range(tris2.length)
	  , aabb1 = verb.eval.mesh.make_mesh_aabb_tree( points1, tris1, tri_indices1 )
	  , aabb2 = verb.eval.mesh.make_mesh_aabb_tree( points2, tris2, tri_indices2 )</pre></div></div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>
              <p>intersect and get the pairs of triangle intersctions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		, intersection_pairs = verb.eval.mesh.intersect_aabb_tree( points1, tris1, points2, tris2, aabb1, aabb2 );</pre></div></div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>
              <p>get the segments of the intersection crv with uvs</p>
<p>sort the intersection segments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>}</pre></div></div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <h4 id="intersect_tris-points1-tri1-uvs1-points2-tri2-uvs2-">intersect_tris( points1, tri1, uvs1, points2, tri2, uvs2 )</h4>
<p>Intersect two triangles</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points of mesh1</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles of mesh1</li>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points of mesh2</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles of mesh2</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.intersect_tris = <span class="function"><span class="keyword">function</span><span class="params">( points1, tri1, uvs1, points2, tri2, uvs2 )</span> {</span>

  <span class="keyword">var</span> seg1a = [ points1[ tr1[<span class="number">0</span>] ], points1[ tr1[<span class="number">1</span>] ] ]
  	, seg1b = [ points1[ tr1[<span class="number">1</span>] ], points1[ tr1[<span class="number">2</span>] ] ]
  	, seg1c = [ points1[ tr1[<span class="number">2</span>] ], points1[ tr1[<span class="number">0</span>] ] ]
  	, seg2a = [ points2[ tr2[<span class="number">0</span>] ], points2[ tr2[<span class="number">1</span>] ] ]
  	, seg2b = [ points2[ tr2[<span class="number">1</span>] ], points2[ tr2[<span class="number">2</span>] ] ]
  	, seg2c = [ points2[ tr2[<span class="number">2</span>] ], points2[ tr2[<span class="number">0</span>] ] ] 
  	, segs1 = [ seg1a, seg1b, seg1c ]
  	, segs2 = [ seg2a, seg2b, seg2c ]
  	, int_results = []
  	, tri2norm = verb.eval.geom.get_tri_norm(points2, tri2)
  	, pt2 = points2[ tr2[<span class="number">0</span>] ];

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++){
  	
  	<span class="keyword">var</span> result = verb.eval.geom.intersect_segment_with_plane( segs1[i][<span class="number">0</span>], segs2[i][<span class="number">1</span>], pt2, tri2norm );
    
    <span class="keyword">if</span> ( result.intersects ){
    	int_results.push( result );
    }

  }</pre></div></div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              <p>if you don&#39;t have 2 intersections you do not have an intersection,
0 would mean a glancing intersection
3 means we don&#39;t have a triangle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> ( int_results.length !== <span class="number">2</span> ){
  	<span class="keyword">return</span> <span class="literal">null</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <p>what portions of the segment lie within triangle 2</p>
<p>intersect edges of triangle 2 with the segment, obtaining the &quot;inner&quot; triangle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> seg = [int_results[<span class="number">0</span>].point, int_results[<span class="number">1</span>].point ]
  	, seg_int_results = [];

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++){
  	<span class="keyword">var</span> seg_int_result = verb.eval.geom.intersect_segments( seg[<span class="number">0</span>], seg[<span class="number">1</span>], seg, b1, tol );
  	<span class="keyword">if</span> ( seg_int_result ){
  		seg_int_results.push( seg_int_result );
  	}
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>
              <p>all intersections should be with uv&#39;s </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> ( seg_int_results.length === <span class="number">0</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>
              <p>tri1 is intersecting and the intersection segment
is inside tri2</p>
<p>return the two outer points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  } <span class="keyword">else</span> <span class="keyword">if</span> ( seg_int_results.length === <span class="number">1</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <p>tri1 is intersecting and the intersection segment
is partially inside tri2</p>
<p>return the end point of seg that is INSIDE tri2 and the intersection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  } <span class="keyword">else</span> <span class="keyword">if</span> ( seg_int_results.length === <span class="number">2</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>
              <p>tri1 is intersecting and the intersection segment&#39;s
end points are outside of tri2</p>
<p>return the two seg_int_results </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  } 

}</pre></div></div>
            
        </li>
        
        
        <li id="section-152">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-152">&#182;</a>
              </div>
              <h4 id="intersect_segment_with_tri-p1-p0-points-tri-">intersect_segment_with_tri(  p1, p0, points, tri )</h4>
<p> Intersect ray/segment with triangle (from <a href="http://geomalgorithms.com/a06-_intersect-2.html">http://geomalgorithms.com/a06-_intersect-2.html</a>)</p>
<p> If intersecting a ray, the param needs to be between 0 and 1 and the caller is responsible
 for making that check</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 representing first point of the segment</li>
<li><em>Array</em>, array of length 3 representing second point of the segment</li>
<li><em>Array</em>, array of length 3 arrays representing the points of the triangle</li>
<li><em>Array</em>, array of length 3 containing int indices in the array of points, this allows passing a full mesh</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with an &quot;intersects&quot; property that is true or false and if true, a 
&quot;&quot; property giving the param on u, and &quot;t&quot; is the property on v, a &quot;point&quot; property
where the intersection took place, and &quot;p&quot; property representing the parameter along the segment</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.intersect_segment_with_tri = <span class="function"><span class="keyword">function</span><span class="params">( p1, p0, points, tri )</span> {</span>

	<span class="keyword">var</span> v0 = points[ tri[<span class="number">0</span>] ]
		, v1 = points[ tri[<span class="number">1</span>] ]
		, v2 = points[ tri[<span class="number">2</span>] ]
		, u = numeric.sub( v1, v0 )
		, v = numeric.sub( v2, v0 )
		, udotv = numeric.dot(u,v)
		, udotu = numeric.dot(u,u)
		, vdotv = numeric.dot(v,v)
		, denom = udotv * udotv - udotu * vdotv
		, s = ((udotv * numeric.dot(u,v)) - (vdotv * numeric.dot(w,u))) / denom
		, t = ((udotv * numeric.dot(w,u)) - (udotu * numeric.dot(w,v))) / denom;

	<span class="keyword">if</span> (s &gt; <span class="number">1.0</span> + EPSILON || t &gt; <span class="number">1.0</span> + EPSILON || t &lt; -EPSILON || s &lt; -EPSILON || s + t &gt; <span class="number">1.0</span> + EPSILON){
		<span class="keyword">return</span> <span class="literal">null</span>;
	}

	<span class="keyword">var</span> pt = numeric.add( v0, numeric.add( numeric.mul( s, u ), numeric.mul( t, v ) ) )
		, p1mp0 = numeric.sub(p1, p0)
		, p1mp0norm = numeric.dot( p1mp0, p1mp0 )
		, ptmp0 = numeric.sub(pt, p0)
		, ptmp0norm = numeric.dot( ptmp0, ptmp0 )
		, p = ptmp0norm / p1mp0norm;

	<span class="keyword">return</span> { point: pt, s: s, t: t, param: p };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-153">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-153">&#182;</a>
              </div>
              <h4 id="intersect_segment_with_plane-p0-p1-v0-n-">intersect_segment_with_plane( p0, p1, v0, n )</h4>
<p> Intersect ray/segment with plane (from <a href="http://geomalgorithms.com/a06-_intersect-2.html">http://geomalgorithms.com/a06-_intersect-2.html</a>)</p>
<p> If intersecting a ray, the param needs to be between 0 and 1 and the caller is responsible
 for making that check</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 representing first point of the segment</li>
<li><em>Array</em>, array of length 3 representing second point of the segment</li>
<li><em>Array</em>, array of length 3 representing an origin point on the plane</li>
<li><em>Array</em>, array of length 3 representing the normal of the plane</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with an &quot;intersects&quot; property that is true or false and if true, a 
&quot;aram&quot; property giving the intersection parameter on the ray/segment.  </li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.intersect_segment_with_plane = <span class="function"><span class="keyword">function</span><span class="params">( p0, p1, v0, n )</span> {</span>

	<span class="keyword">var</span> denom = numeric.dot( n, numeric.sub(p0,p1) );</pre></div></div>
            
        </li>
        
        
        <li id="section-154">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-154">&#182;</a>
              </div>
              <p>parallel case</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">if</span> ( abs( denom ) &lt; EPSILON ) { 
   	<span class="keyword">return</span> <span class="literal">null</span>;
 	}

 	<span class="keyword">var</span> numer = numeric.dot( n, numeric.sub(v0,p0) );

	<span class="keyword">return</span> { param: numer / denom };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-155">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-155">&#182;</a>
              </div>
              <h4 id="intersect_aabb_trees-points1-tris1-points2-tris2-aabb_tree1-aabb_tree2-">intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1, aabb_tree2 )</h4>
<p> Intersect two aabb trees - a recursive function</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points of mesh1</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles of mesh1</li>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points of mesh2</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles of mesh2</li>
<li><em>Object</em>, nested object representing the aabb tree of the first mesh</li>
<li><em>Object</em>, nested object representing the aabb tree of the second mesh</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a list of pairs of triangle indices for mesh1 and mesh2 that are intersecting</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.intersect_aabb_trees = <span class="function"><span class="keyword">function</span><span class="params">( points1, tris1, points2, tris2, aabb_tree1, aabb_tree2 )</span> {</span>

  <span class="keyword">var</span> intersects = aabb_tree1.bounding_box.intersects( aabb_tree2.bounding_box );

  <span class="keyword">if</span> (!intersects){
  	<span class="keyword">return</span> [];
  }

  <span class="keyword">if</span> (aabb_tree1.children.length === <span class="number">0</span> &amp;&amp; aabb_tree2.children.length === <span class="number">0</span>){ 

  	<span class="keyword">return</span> [ [aabb_tree1.triangle, aabb_tree2.triangle ] ]; 

  } <span class="keyword">else</span> <span class="keyword">if</span> (aabb_tree1.children.length === <span class="number">0</span> &amp;&amp; aabb_tree2.children.length != <span class="number">0</span>){

  	<span class="keyword">return</span>     verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1, aabb_tree2.children[<span class="number">0</span>] )
  		.concat( verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1, aabb_tree2.children[<span class="number">1</span>] ) );

  } <span class="keyword">else</span> <span class="keyword">if</span> (aabb_tree1.children.length != <span class="number">0</span> &amp;&amp; aabb_tree2.children.length === <span class="number">0</span>){

  	<span class="keyword">return</span>     verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1.children[<span class="number">0</span>], aabb_tree2 )
  		.concat( verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1.children[<span class="number">1</span>], aabb_tree2 ) );

  } <span class="keyword">else</span> <span class="keyword">if</span> (aabb_tree1.children.length != <span class="number">0</span> &amp;&amp; aabb_tree2.children.length != <span class="number">0</span>){

  	<span class="keyword">return</span>     verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1.children[<span class="number">0</span>], aabb_tree2.children[<span class="number">0</span>] )
  		.concat( verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1.children[<span class="number">0</span>], aabb_tree2.children[<span class="number">1</span>] ) )
  		.concat( verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1.children[<span class="number">1</span>], aabb_tree2.children[<span class="number">0</span>] ) )
  		.concat( verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1.children[<span class="number">1</span>], aabb_tree2.children[<span class="number">1</span>] ) );

  }

}</pre></div></div>
            
        </li>
        
        
        <li id="section-156">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-156">&#182;</a>
              </div>
              <h4 id="make_mesh_aabb_tree-points-tris-tri_indices-">make_mesh_aabb_tree( points, tris, tri_indices )</h4>
<p>Make tree of axis aligned bounding boxes </p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles</li>
<li><em>Array</em>, array of numbers representing the relevant triangles to use to form aabb</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.mesh.make_mesh_aabb_tree = <span class="function"><span class="keyword">function</span><span class="params">( points, tris, tri_indices )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-157">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-157">&#182;</a>
              </div>
              <p>build bb</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> aabb = { 	bounding_box: verb.eval.mesh.make_mesh_aabb( points, tris, tri_indices ), 
								children: [] };</pre></div></div>
            
        </li>
        
        
        <li id="section-158">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-158">&#182;</a>
              </div>
              <p>if only one ele, terminate recursion and store the triangles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">if</span> (tri_indices.length === <span class="number">1</span>){
		aabb.triangle = tri_indices[<span class="number">0</span>];
		<span class="keyword">return</span> aabb;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-159">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-159">&#182;</a>
              </div>
              <p>sort triangles in sub mesh</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> sorted_tri_indices = verb.eval.mesh.sort_tris_on_longest_axis( aabb.bounding_box, points, tris, tri_indices )
		, tri_indices_a = sorted_tri_indices.slice( <span class="number">0</span>, Math.floor( sorted_tri_indices.length / <span class="number">2</span> ) )
		, tri_indices_b = sorted_tri_indices.slice( Math.floor( sorted_tri_indices.length / <span class="number">2</span> ), sorted_tri_indices.length );</pre></div></div>
            
        </li>
        
        
        <li id="section-160">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-160">&#182;</a>
              </div>
              <p>recurse </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	aabb.children = [ verb.eval.mesh.make_mesh_aabb_tree(points, tris, tri_indices_a), 
										verb.eval.mesh.make_mesh_aabb_tree(points, tris, tri_indices_b) ];</pre></div></div>
            
        </li>
        
        
        <li id="section-161">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-161">&#182;</a>
              </div>
              <p>return result</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">return</span> aabb;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-162">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-162">&#182;</a>
              </div>
              <h4 id="make_mesh_aabb-points-tris-tri_indices-">make_mesh_aabb( points, tris, tri_indices )</h4>
<p>Form axis-aligned bounding box from triangles of mesh</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles</li>
<li><em>Array</em>, array of numbers representing the relevant triangles</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.mesh.make_mesh_aabb = <span class="function"><span class="keyword">function</span><span class="params">( points, tris, tri_indices )</span> {</span>

	<span class="keyword">var</span> bb = <span class="keyword">new</span> verb.geom.BoundingBox();

	<span class="keyword">for</span> (<span class="keyword">var</span> i = tri_indices.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {
		
		<span class="keyword">var</span> tri_i = tri_indices[i];

		bb.add( points[ tris[ tri_i ][<span class="number">0</span>] ] );
		bb.add( points[ tris[ tri_i ][<span class="number">1</span>] ] );
		bb.add( points[ tris[ tri_i ][<span class="number">2</span>] ] );

	};

	<span class="keyword">return</span> bb;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-163">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-163">&#182;</a>
              </div>
              <h4 id="sort_tris_on_longest_axis-container_bb-points-tris-tri_indices-">sort_tris_on_longest_axis( container_bb, points, tris, tri_indices )</h4>
<p>Sort triangles on longest axis</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.mesh.sort_tris_on_longest_axis = <span class="function"><span class="keyword">function</span><span class="params">( container_bb, points, tris, tri_indices )</span> {</span>

	<span class="keyword">var</span> long_axis = container_bb.get_longest_axis();

	<span class="keyword">var</span> axis_position_map = [];
	<span class="keyword">for</span> (<span class="keyword">var</span> i = tri_indices.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {

		<span class="keyword">var</span> tri_i = tri_indices[i],
			tri_min = verb.eval.mesh.get_min_coordinate_on_axis( points, tris[ tri_i ], long_axis );

		axis_position_map.push( [ tri_min, tri_i ] );

	}

	axis_position_map.sort(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span> {</span> <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] } );

	<span class="keyword">var</span> sorted_tri_indices = [];
	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = axis_position_map.length; i &lt; l; i++) {
		sorted_tri_indices.push( axis_position_map[i][<span class="number">1</span>] );
	}

	<span class="keyword">return</span> sorted_tri_indices;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-164">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-164">&#182;</a>
              </div>
              <h4 id="get_min_coordinate_on_axis-points-tri-axis-">get_min_coordinate_on_axis( points, tri, axis )</h4>
<p>Get min coordinate on axis</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points</li>
<li><em>Array</em>, length 3 array of point indices for the triangle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, a point represented by an array of length 3</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.mesh.get_min_coordinate_on_axis = <span class="function"><span class="keyword">function</span><span class="params">( points, tri, axis )</span> {</span>

	<span class="keyword">var</span> axis_coords = [];

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++){
		axis_coords.push( points[ tri[i] ][ axis ] );
	}

	<span class="keyword">return</span> Math.min.apply(Math, axis_coords);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-165">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-165">&#182;</a>
              </div>
              <h4 id="get_tri_centroid-points-tri-">get_tri_centroid( points, tri )</h4>
<p>Get triangle centroid</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points</li>
<li><em>Array</em>, length 3 array of point indices for the triangle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length 3</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.get_tri_centroid = <span class="function"><span class="keyword">function</span><span class="params">( points, tri )</span> {</span>

	<span class="keyword">var</span> centroid = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>];

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++){
		<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++){
			centroid[j] += points[ tri[i] ][j];
		}
	}

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++){
		centroid[i] /= <span class="number">3</span>;
	}

	<span class="keyword">return</span> centroid;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-166">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-166">&#182;</a>
              </div>
              <h4 id="get_tri_norm-points-tri-">get_tri_norm( points, tri )</h4>
<p>Get triangle normal</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points</li>
<li><em>Array</em>, length 3 array of point indices for the triangle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a normal vector represented by an array of length 3</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.get_tri_norm = <span class="function"><span class="keyword">function</span><span class="params">( points, tri )</span> {</span>

	<span class="keyword">var</span> v0 = points[ tri[<span class="number">0</span>] ]
		, v1 = points[ tri[<span class="number">1</span>] ]
		, v2 = points[ tri[<span class="number">2</span>] ]
		, u = numeric.sub( v1, v0 )
		, v = numeric.sub( v2, v0 )
		, n = numeric.cross( u, v );

	<span class="keyword">return</span> numeric.mul( <span class="number">1</span> / numeric.norm2( n ), n );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-167">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-167">&#182;</a>
              </div>
              <h4 id="tesselate_rational_surface_naive-degree_u-knots_u-degree_v-knots_v-homo_control_points-divs_u-divs_v-">tesselate_rational_surface_naive( degree_u, knots_u, degree_v, knots_v, homo_control_points, divs_u, divs_v )</h4>
<p>Tesselate a nurbs surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, top to bottom is increasing u direction, left to right is increasing v direction,
and where each control point is an array of length (dim+1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, first element of array is an array of positions, second element are 3-tuple of triangle windings, third element is the 
uvs</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.tesselate_rational_surface_naive = <span class="function"><span class="keyword">function</span><span class="params">( degree_u, knots_u, degree_v, knots_v, homo_control_points, divs_u, divs_v )</span> {</span>


	<span class="keyword">if</span> ( divs_u &lt; <span class="number">1</span> ) {
		divs_u = <span class="number">1</span>;
	}

	<span class="keyword">if</span> ( divs_v &lt; <span class="number">1</span> ) {
		divs_v = <span class="number">1</span>;
	}

	<span class="keyword">var</span> span_u = <span class="number">1</span> / divs_u,
		span_v = <span class="number">1</span> / divs_v;
  
  <span class="keyword">var</span> points = [];
  <span class="keyword">var</span> uvs = [];
  <span class="keyword">var</span> normals = [];

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs_u + <span class="number">1</span>; i++) {
		<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; divs_v + <span class="number">1</span>; j++) {

			<span class="keyword">var</span> pt_u = i * span_u, 
				pt_v = j * span_v;

			uvs.push( [pt_u, pt_v] );

			<span class="keyword">var</span> derivs = verb.eval.nurbs.rational_surface_derivs( degree_u, knots_u, degree_v, knots_v, homo_control_points, <span class="number">1</span>, pt_u, pt_v );
			<span class="keyword">var</span> pt = derivs[<span class="number">0</span>][<span class="number">0</span>];

			points.push( pt );

			<span class="keyword">var</span> normal = numeric.cross(  derivs[<span class="number">0</span>][<span class="number">1</span>], derivs[<span class="number">1</span>][<span class="number">0</span>] );
			normals.push( normal );

		}
	}

  	<span class="keyword">var</span> faces = [];

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs_u ; i++) {
		<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; divs_v ; j++) {

			<span class="keyword">var</span> a_i = i * (divs_v + <span class="number">1</span>) + j,
				b_i = (i + <span class="number">1</span>) * (divs_v + <span class="number">1</span>) + j,
				c_i = b_i + <span class="number">1</span>,
				d_i = a_i + <span class="number">1</span>,
				abc = [a_i, b_i, c_i],
				acd = [a_i, c_i, d_i];

			faces.push(abc);
			faces.push(acd);

		}
	}

	<span class="keyword">return</span> { points: points, faces : faces, uvs: uvs, normals: normals };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-168">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-168">&#182;</a>
              </div>
              <h4 id="rational_curve_curve_bb_intersect_refine-degree1-knots1-control_points1-degree2-knots2-control_points2-start_params-">rational_curve_curve_bb_intersect_refine( degree1, knots1, control_points1, degree2, knots2, control_points2, start_params )</h4>
<p>Refine an intersection pair for two curves given an initial guess.  This is an unconstrained minimization,
so the caller is responsible for providing a very good initial guess.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve1</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 1</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi) for curve 1</li>
<li><em>Number</em>, integer degree of curve2</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 2</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi) for curve 2</li>
<li><em>Array</em>, length 2 array with first param guess in first position and second param guess in second position</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a length 3 array containing the [ distance// distance, u1, u2 ]</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_curve_curve_bb_intersect_refine = <span class="function"><span class="keyword">function</span><span class="params">( degree1, knots1, control_points1, degree2, knots2, control_points2, start_params )</span> {</span>

	<span class="keyword">var</span> objective = <span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span> 

		<span class="keyword">var</span> p1 = verb.eval.nurbs.rational_curve_point(degree1, knots1, control_points1, x[<span class="number">0</span>])
			, p2 = verb.eval.nurbs.rational_curve_point(degree2, knots2, control_points2, x[<span class="number">1</span>])
			, p1_p2 = numeric.sub(p1, p2);

		<span class="keyword">return</span> numeric.dot(p1_p2, p1_p2);
	}

	<span class="keyword">var</span> sol_obj = numeric.uncmin( objective, start_params);

	<span class="keyword">return</span> [sol_obj.f].concat( sol_obj.solution );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-169">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-169">&#182;</a>
              </div>
              <h4 id="intersect_rational_curves_by_aabb-degree1-knots1-control_points1-degree2-knots2-control_points2-sample_tol-tol-">intersect_rational_curves_by_aabb( degree1, knots1, control_points1, degree2, knots2, control_points2, sample_tol, tol )</h4>
<p>Intersect two NURBS curves</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve1</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 1</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) for curve 1</li>
<li><em>Number</em>, integer degree of curve2</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 2</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) for curve 2</li>
<li><em>Number</em>, tolerance for the intersection</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a 2d array specifying the intersections on u params of intersections on curve 1 and cruve 2</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.intersect_rational_curves_by_aabb = <span class="function"><span class="keyword">function</span><span class="params">( degree1, knots1, control_points1, degree2, knots2, control_points2, sample_tol, tol )</span> {</span>

	<span class="keyword">var</span> up1 = verb.eval.nurbs.rational_curve_adaptive_sample( degree1, knots1, control_points1, sample_tol )
		, up2 = verb.eval.nurbs.rational_curve_adaptive_sample( degree1, knots1, control_points1, sample_tol )
		, u1 = up1.map( <span class="function"><span class="keyword">function</span><span class="params">(el)</span> {</span> <span class="keyword">return</span> el[<span class="number">0</span>]; })
		, u2 = up2.map( <span class="function"><span class="keyword">function</span><span class="params">(el)</span> {</span> <span class="keyword">return</span> el[<span class="number">0</span>]; })
		, p1 = up1.map( <span class="function"><span class="keyword">function</span><span class="params">(el)</span> {</span> <span class="keyword">return</span> el.slice(<span class="number">1</span>) })
		, p2 = up2.map( <span class="function"><span class="keyword">function</span><span class="params">(el)</span> {</span> <span class="keyword">return</span> el.slice(<span class="number">1</span>) });

	<span class="keyword">return</span> verb.eval.nurbs.intersect_parametric_polylines_by_aabb( p1, p2, u1, u2, tol );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-170">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-170">&#182;</a>
              </div>
              <h4 id="intersect_parametric_polylines_by_aabb-p1-p2-u1-u2-tol-">intersect_parametric_polylines_by_aabb( p1, p2, u1, u2, tol )</h4>
<p>Intersect two polyline curves, keeping track of parameterization on each</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of [parameter point] values for curve 1</li>
<li><em>Array</em>, array of [parameter point] values for curve 2</li>
<li><em>Number</em>, tolerance for the intersection</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a 2d array specifying the intersections on u params of intersections on curve 1 and cruve 2</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.intersect_parametric_polylines_by_aabb = <span class="function"><span class="keyword">function</span><span class="params">( p1, p2, u1, u2, tol )</span> {</span>

	<span class="keyword">var</span> bb1 = <span class="keyword">new</span> verb.geom.BoundingBox(p1)
		, bb2 = <span class="keyword">new</span> verb.geom.BoundingBox(p2)

	<span class="keyword">if</span> ( !bb1.intersects(bb2) ) <span class="keyword">return</span>;

	<span class="keyword">if</span> (p1.length === <span class="number">2</span> &amp;&amp; p2.length === <span class="number">2</span> ){

			<span class="keyword">var</span> inter = verb.eval.geom.segment_segment_intersect(p1[<span class="number">0</span>],p1[<span class="number">1</span>], p2[<span class="number">0</span>], p2[<span class="number">1</span>], tol);

			<span class="keyword">if</span> ( inter != <span class="literal">null</span> ){

			 	inter[<span class="number">0</span>][<span class="number">0</span>] = inter[<span class="number">0</span>][<span class="number">0</span>] * ( u1[<span class="number">1</span>]-u1[<span class="number">0</span>] ) + u1[<span class="number">0</span>];
			 	inter[<span class="number">1</span>][<span class="number">0</span>] = inter[<span class="number">1</span>][<span class="number">0</span>] * ( u2[<span class="number">1</span>]-u2[<span class="number">0</span>] ) + u2[<span class="number">0</span>];

			 	<span class="keyword">return</span> inter;

			} 

	} <span class="keyword">else</span> <span class="keyword">if</span> (p1.length === <span class="number">2</span>) {

		<span class="keyword">var</span> p2_mid = Math.ceil( p2.length / <span class="number">2</span> ),
				p2_a = p2.slice( <span class="number">0</span>, p2_mid ),
				u2_a = u2.slice(<span class="number">0</span>, p2_mid ),
				p2_b = p2.slice( p2_mid-<span class="number">1</span> )
				u2_b = p2.slice( p2_mid-<span class="number">1</span> );

		<span class="keyword">return</span> 	 verb.eval.nurbs.parametric_polyline_polyline_bb_intersect(p1, p2_a, u1, u2_a, tol)
		.concat( verb.eval.nurbs.parametric_polyline_polyline_bb_intersect(p1, p2_b, u1, u2_b, tol) );

	} <span class="keyword">else</span> <span class="keyword">if</span> (p2.length === <span class="number">2</span>) {

		<span class="keyword">var</span> p1_mid = Math.ceil( p1.length / <span class="number">2</span> ),
				p1_a = p1.slice( <span class="number">0</span>, p1_mid ),
				u1_a = u1.slice(<span class="number">0</span>, p1_mid ),
				p1_b = p1.slice( p1_mid-<span class="number">1</span> )
				u1_b = p1.slice( p1_mid-<span class="number">1</span> );

		<span class="keyword">return</span> 		 verb.eval.nurbs.parametric_polyline_polyline_bb_intersect(p2, p1_a, u2, p1_a, tol)
			.concat( verb.eval.nurbs.parametric_polyline_polyline_bb_intersect(p2, p1_b, u2, u1_b, tol) );

	} <span class="keyword">else</span> {

		<span class="keyword">var</span> p1_mid = Math.ceil( p1.length / <span class="number">2</span> ),
				p1_a = p1.slice( <span class="number">0</span>, p1_mid ),
				u1_a = u1.slice(<span class="number">0</span>, p1_mid ),
				p1_b = p1.slice( p1_mid-<span class="number">1</span> ),
				u1_b = p1.slice( p1_mid-<span class="number">1</span> ),
				p2_mid = Math.ceil( p2.length / <span class="number">2</span> ),
				p2_a = p2.slice( <span class="number">0</span>, p2_mid ),
				u2_a = u2.slice(<span class="number">0</span>, p2_mid ),
				p2_b = p2.slice( p2_mid-<span class="number">1</span> ),
				u2_b = p2.slice( p2_mid-<span class="number">1</span> );

		<span class="keyword">return</span> 		 verb.eval.nurbs.parametric_polyline_polyline_bb_intersect(p1_a, p2_a, u1_a, p2_a, tol)
			.concat( verb.eval.nurbs.parametric_polyline_polyline_bb_intersect(p1_a, p2_b, u1_a, u2_b, tol) )
			.concat( verb.eval.nurbs.parametric_polyline_polyline_bb_intersect(p1_b, p2_a, u1_b, u2_a, tol) )
			.concat( verb.eval.nurbs.parametric_polyline_polyline_bb_intersect(p1_b, p2_b, u1_b, u2_b, tol) );

	}

	<span class="keyword">return</span> [];

}</pre></div></div>
            
        </li>
        
        
        <li id="section-171">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-171">&#182;</a>
              </div>
              <h4 id="intersect_segments-a0-a1-b0-b1-tol-">intersect_segments( a0, a1, b0, b1, tol )</h4>
<p>Find the closest parameter on two rays, see <a href="http://geomalgorithms.com/a07-_distance.html">http://geomalgorithms.com/a07-_distance.html</a></p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, first point on a</li>
<li><em>Array</em>, second point on a</li>
<li><em>Array</em>, first point on b</li>
<li><em>Array</em>, second point on b</li>
<li><em>Number</em>, tolerance for the intersection</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a 2d array specifying the intersections on u params of intersections on curve 1 and cruve 2</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.intersect_segments = <span class="function"><span class="keyword">function</span><span class="params">( a0, a1, b0, b1, tol )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-172">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-172">&#182;</a>
              </div>
              <p>get axis and length of segments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> a1ma0 = numeric.sub(a1, a0),
			aN = Math.sqrt( numeric.dot(a1ma0, a1ma0) ),
			a = numeric.mul( <span class="number">1</span>/ aN, a1ma0 )
			b1mb0 = numeric.sub(b1, b0),
			bN = Math.sqrt( numeric.dot(b1mb0, b1mb0) ),
			a = numeric.mul( <span class="number">1</span> / bN, a1ma0 )
			int_params = ray_ray_intersect(a0, a, b0, b);

	<span class="keyword">if</span> ( int_params != <span class="literal">null</span> ) {

		<span class="keyword">var</span> u1 = Math.min( Math.max( <span class="number">0</span>, int_params[<span class="number">0</span>] / a ), <span class="number">1.0</span>),
				u2 = Math.min( Math.max( <span class="number">0</span>, int_params[<span class="number">1</span>] / b ), <span class="number">1.0</span>),
				int_a = numeric.add( numeric.mul( u1, a1ma0 ), a0 ),
				int_b = numeric.add( numeric.mul( u2, b1mb0 ), b0 ),
				dist = numeric.norm2Squared( numeric.sub(int_a, int_b) );

		<span class="keyword">if</span> (  dist &lt; tolerance*tolerance ) {
			<span class="keyword">return</span> [ [u1].concat(int_a), [u2].concat(int_b) ] ;
		} 

	}
	
	<span class="keyword">return</span> <span class="literal">null</span>;

 }</pre></div></div>
            
        </li>
        
        
        <li id="section-173">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-173">&#182;</a>
              </div>
              <h4 id="closest_point_on_ray-pt-o-r-">closest_point_on_ray( pt, o, r )</h4>
<p>Find the closest point on a ray</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, point to project</li>
<li><em>Array</em>, origin for ray</li>
<li><em>Array</em>, direction of ray 1, assumed normalized</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, [param, pt]</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.closest_point_on_ray = <span class="function"><span class="keyword">function</span><span class="params">( pt, o, r )</span> {</span>

		<span class="keyword">var</span> o2pt = numeric.sub(pt,o)
			, do2ptr = numeric.dot(o2pt, r)
			, proj = numeric.add(o, numeric.mul(do2ptr, r));

		<span class="keyword">return</span> proj;

 }</pre></div></div>
            
        </li>
        
        
        <li id="section-174">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-174">&#182;</a>
              </div>
              <h4 id="intersect_rays-a0-a-b0-b-">intersect_rays( a0, a, b0, b )</h4>
<p>Find the closest parameter on two rays, see <a href="http://geomalgorithms.com/a07-_distance.html">http://geomalgorithms.com/a07-_distance.html</a></p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, origin for ray 1</li>
<li><em>Array</em>, direction of ray 1, assumed normalized</li>
<li><em>Array</em>, origin for ray 1</li>
<li><em>Array</em>, direction of ray 1, assumed normalized</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a 2d array specifying the intersections on u params of intersections on curve 1 and curve 2</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.intersect_rays = <span class="function"><span class="keyword">function</span><span class="params">( a0, a, b0, b )</span> {</span>

   <span class="keyword">var</span> dab = numeric.dot( a, b ),
		   dab0 = numeric.dot( a, b0 ),
		   daa0 = numeric.dot( a, a0 ),
		   dbb0 = numeric.dot( b, b0 ),
		   dba0 = numeric.dot( b, a0 ),
		   daa = numeric.dot( a, a ),
		   dbb = numeric.dot( b, b ),
		   div = daa*dbb - dab*dab;</pre></div></div>
            
        </li>
        
        
        <li id="section-175">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-175">&#182;</a>
              </div>
              <p>parallel case</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>   <span class="keyword">if</span> ( Math.abs( div ) &lt; verb.EPSILON ) { 
	   <span class="keyword">return</span> <span class="literal">null</span>;
   }

   <span class="keyword">var</span> num = dab * (dab0-daa0) - daa * (dbb0-dba0),
   		 w = num / div,
			 t = (dab0 - daa0 + w * dab)/daa;

		<span class="keyword">return</span> [t, w];

 }</pre></div></div>
            
        </li>
        
        
        <li id="section-176">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-176">&#182;</a>
              </div>
              <h4 id="rational_curve_regular_sample-degree-knots-control_points-num_samples-include_u-">rational_curve_regular_sample( degree, knots, control_points, num_samples [, include_u] )</h4>
<p>Sample a NURBS curve assuming parameterization 0 to 1, corresponds to <a href="http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf">http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf</a></p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values </li>
<li><em>Array</em>, 1d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) </li>
<li><em>Number</em>, integer number of samples</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an dictionary of parameter - point pairs</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_curve_regular_sample = <span class="function"><span class="keyword">function</span><span class="params">( degree, knots, control_points, num_samples, include_u )</span> {</span>

	<span class="keyword">return</span> verb.eval.nurbs.rational_curve_regular_sample_range( degree, knots, control_points, <span class="number">0</span>, <span class="number">1.0</span>, num_samples, include_u);

}</pre></div></div>
            
        </li>
        
        
        <li id="section-177">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-177">&#182;</a>
              </div>
              <h4 id="rational_curve_regular_sample_range-degree-knots-control_points-start_u-end_u-num_samples-include_u-">rational_curve_regular_sample_range( degree, knots, control_points, start_u, end_u, num_samples, include_u )</h4>
<p>Sample a NURBS curve assuming parameterization 0 to 1, corresponds to <a href="http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf">http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf</a></p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values </li>
<li><em>Array</em>, 1d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) </li>
<li><em>Number</em>, start parameter for sampling</li>
<li><em>Number</em>, end parameter for sampling</li>
<li><em>Number</em>, integer number of samples</li>
<li><em>Boolean</em>, whether to prefix the point with the parameter</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an dictionary of parameter - point pairs</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_curve_regular_sample_range = <span class="function"><span class="keyword">function</span><span class="params">( degree, knots, control_points, start_u, end_u, num_samples, include_u )</span> {</span>

	<span class="keyword">if</span> (num_samples &lt; <span class="number">1</span>){
		num_samples = <span class="number">2</span>;
	}

	<span class="keyword">var</span> p = [],
		span = (end_u - start_u) / (num_samples - <span class="number">1</span>),
		u = <span class="number">0</span>;

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num_samples; i++){

		u = start_u + span * i;
		<span class="keyword">if</span> ( include_u ){
			p.push( [u].concat( verb.eval.nurbs.rational_curve_point(degree, knots, control_points, u) ) );
		} <span class="keyword">else</span> {
			p.push( verb.eval.nurbs.rational_curve_point(degree, knots, control_points, u) );
		}
	
	}

	<span class="keyword">return</span> p;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-178">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-178">&#182;</a>
              </div>
              <h4 id="rational_curve_adaptive_sample-degree-knots-control_points-tol-include_u-">rational_curve_adaptive_sample( degree, knots, control_points, tol, include_u )</h4>
<p>Sample a NURBS curve assuming parameterization 0 to 1, corresponds to <a href="http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf">http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf</a></p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values </li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi) </li>
<li><em>Number</em>, tolerance for the adaptive scheme</li>
<li><em>Boolean</em>, whether to prefix the point with the parameter</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an array of dim + 1 length where the first element is the param where it was sampled and the remaining the pt</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_curve_adaptive_sample = <span class="function"><span class="keyword">function</span><span class="params">( degree, knots, control_points, tol, include_u )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-179">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-179">&#182;</a>
              </div>
              <p>if degree is 1, just return the dehomogenized control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">if</span> (degree === <span class="number">1</span>){
		<span class="keyword">return</span> control_points.map( verb.eval.nurbs.dehomogenize );
	}

	<span class="keyword">return</span> verb.eval.nurbs.rational_curve_adaptive_sample_range( degree, knots, control_points, <span class="number">0</span>, <span class="number">1.0</span>, tol, include_u );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-180">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-180">&#182;</a>
              </div>
              <h4 id="rational_curve_adaptive_sample_range-degree-knots-control_points-start_u-end_u-tol-include_u-">rational_curve_adaptive_sample_range( degree, knots, control_points, start_u, end_u, tol, include_u )</h4>
<p>Sample a NURBS curve at 3 points, facilitating adaptive sampling</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values </li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi) </li>
<li><em>Number</em>, start parameter for sampling</li>
<li><em>Number</em>, end parameter for sampling</li>
<li><em>Boolean</em>, whether to prefix the point with the parameter</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an array of dim + 1 length where the first element is the param where it was sampled and the remaining the pt</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_curve_adaptive_sample_range = <span class="function"><span class="keyword">function</span><span class="params">( degree, knots, control_points, start_u, end_u, tol, include_u )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-181">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-181">&#182;</a>
              </div>
              <p>sample curve at three pts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> p1 = verb.eval.nurbs.rational_curve_point(degree, knots, control_points, start_u),
		p3 = verb.eval.nurbs.rational_curve_point(degree, knots, control_points, end_u),
		t = <span class="number">0.5</span> + <span class="number">0.2</span> * Math.random(),
		mid_u = start_u + (end_u - start_u) * t,
		p2 = verb.eval.nurbs.rational_curve_point(degree, knots, control_points, mid_u);</pre></div></div>
            
        </li>
        
        
        <li id="section-182">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-182">&#182;</a>
              </div>
              <p>if the two end control points are coincident, the three point test will always return 0, let&#39;s split the curve</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="keyword">var</span> diff = numeric.sub( p1, p3);
		<span class="keyword">var</span> diff2 = numeric.sub( p1, p2);</pre></div></div>
            
        </li>
        
        
        <li id="section-183">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-183">&#182;</a>
              </div>
              <p>the first condition checks if the curve makes up a loop, if so, we will need to continue evaluation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="keyword">if</span> ( ( numeric.dot( diff, diff ) &lt; tol &amp;&amp; numeric.dot( diff2, diff2 ) &gt; tol ) || !verb.eval.nurbs.three_points_are_flat( p1, p2, p3, tol ) ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-184">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-184">&#182;</a>
              </div>
              <p>recurse on the two halves</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="keyword">var</span> left_pts = verb.eval.nurbs.rational_curve_adaptive_sample_range( degree, knots, control_points, start_u, mid_u, tol, include_u )
				, right_pts = verb.eval.nurbs.rational_curve_adaptive_sample_range( degree, knots, control_points, mid_u, end_u, tol, include_u );</pre></div></div>
            
        </li>
        
        
        <li id="section-185">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-185">&#182;</a>
              </div>
              <p>concatenate the two        </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="keyword">return</span> left_pts.slice(<span class="number">0</span>, -<span class="number">1</span>).concat(right_pts);

		} <span class="keyword">else</span> {

			<span class="keyword">if</span> (include_u){
				<span class="keyword">return</span> [ 	[ start_u ].concat(p1) , [end_u].concat(p3) ];
			} <span class="keyword">else</span> {
				<span class="keyword">return</span> [ 	p1, p3 ];
			}

		}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-186">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-186">&#182;</a>
              </div>
              <h4 id="three_points_are_flat-p1-p2-p3-tol-">three_points_are_flat( p1, p2, p3, tol )</h4>
<p>Determine if three points form a straight line within a given tolerance for their 2 * squared area</p>
<pre><code>     * p2
    / \
   /   \
  /     \ 
 /       \
* p1 ---- * p3</code></pre>
<p>The area metric is 2 * the squared norm of the cross product of two edges, requiring no square roots and no divisions</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, p1</li>
<li><em>Array</em>, p2</li>
<li><em>Array</em>, p3</li>
<li><em>Number</em>, The tolerance for whether the three points form a line</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, Whether the triangle passes the test</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.three_points_are_flat = <span class="function"><span class="keyword">function</span><span class="params">( p1, p2, p3, tol )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-187">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-187">&#182;</a>
              </div>
              <p>find the area of the triangle without using a square root</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> p2mp1 = numeric.sub( p2, p1 )
		, p3mp1 = numeric.sub( p3, p1 )
		, norm = crossprod( p2mp1, p3mp1 )
		, area = numeric.dot( norm, norm );

	<span class="keyword">return</span> area &lt; tol;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-188">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-188">&#182;</a>
              </div>
              <h4 id="curve_knot_insert-degree-knots-control_points-u-s-r-">curve_knot_insert( degree, knots, control_points, u, s, r )</h4>
<p>Insert a knot along a rational curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the derivatives</li>
<li><em>Number</em>, v parameter at which to evaluate the derivatives</li>
<li><em>Array</em>, 1d array of control point weights </li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.curve_knot_insert = <span class="function"><span class="keyword">function</span><span class="params">( degree, knots, control_points, u, s, r )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-189">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-189">&#182;</a>
              </div>
              <p>np is n for the initial curve
nq is n for the output curve with knots inserted
k is the span on which the knots are inserted
s is the initial multiplicity of the point
r is the number of times to insert the knot
control_points is initial set of control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> dim = control_points[<span class="number">0</span>].length
		, np = knots.length - degree - <span class="number">2</span>
		, num_pts = control_points.length
		, k = verb.eval.nurbs.knot_span( degree, u, knots )
		, mp = np + degree + <span class="number">1</span>
		, nq = np + r
		, num_pts_post = num_pts + r    
		, Rw = <span class="keyword">new</span> Array( degree + <span class="number">1</span> )  
		, knots_post = <span class="keyword">new</span> Array( knots.length + r ) 
		, control_points_post = <span class="keyword">new</span> Array( num_pts_post ) 
		, i = <span class="number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-190">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-190">&#182;</a>
              </div>
              <p>new knot vector</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= k; i++) {
		knots_post[i] = knots[i];
	}
	
	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= r; i++) {
		knots_post[k+i] = u; 
	}

	<span class="keyword">for</span> (i = k+<span class="number">1</span>; i &lt;= mp; i++)
	{
		knots_post[i+r] = knots[i];
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-191">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-191">&#182;</a>
              </div>
              <p>control point generation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= k-degree; i++)
	{
		control_points_post[i] = control_points[i]; 
	}

	<span class="keyword">for</span> (i = k-s; i &lt;= np; i++)
	{
		control_points_post[i+r] = control_points[i];
	}

	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= degree-s; i++)
	{
		Rw[i] = control_points[k-degree+<span class="number">1</span>];
	}

	<span class="keyword">var</span> L = <span class="number">0</span>
		, alpha = <span class="number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-192">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-192">&#182;</a>
              </div>
              <p>insert knot r times</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= r; j++) {

		L = k-degree+j;

		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= degree-j-s; i++) {

			alpha = ( u - knots[L+i] ) / ( knots[i+k+<span class="number">1</span>] - knots[L+i] );
			Rw[i] = numeric.add( numeric.mul( alpha, Rw[i+<span class="number">1</span>] ), numeric.mul( (<span class="number">1.0</span> - alpha), Rw[i]) );

		}

		control_points_post[ L ] = Rw[<span class="number">0</span>];
		control_points_post[k+r-j-s] = Rw[degree-j-s];

	}</pre></div></div>
            
        </li>
        
        
        <li id="section-193">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-193">&#182;</a>
              </div>
              <p>not so confident about this part</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">for</span> (i = L+<span class="number">1</span>; i &lt; k-s; i++) <span class="comment">// set remaining control points</span>
	{
		control_points_post[i] = Rw[ i - L ];
	}

	<span class="keyword">return</span> [knots_post, control_points_post];

}</pre></div></div>
            
        </li>
        
        
        <li id="section-194">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-194">&#182;</a>
              </div>
              <h4 id="rational_surface_derivs-degree_u-knots_u-degree_v-knots_v-homo_control_points-num_derivs-u-v-">rational_surface_derivs( degree_u, knots_u, degree_v, knots_v, homo_control_points, num_derivs, u, v)</h4>
<p>Compute the derivatives at a point on a NURBS surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the derivatives</li>
<li><em>Number</em>, v parameter at which to evaluate the derivatives</li>
<li><em>Array</em>, 1d array of control point weights </li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_surface_derivs = <span class="function"><span class="keyword">function</span><span class="params">( degree_u, knots_u, degree_v, knots_v, homo_control_points, num_derivs, u, v)</span> {</span>

	<span class="keyword">var</span> SKL_homo = verb.eval.nurbs.surface_derivs( degree_u, knots_u, degree_v, knots_v, homo_control_points, num_derivs, u, v )
		, ders = verb.eval.nurbs.separate_homo_derivs_2d( SKL_homo )
		, Aders = ders[<span class="number">0</span>]
		, wders = ders[<span class="number">1</span>]
		, k = <span class="number">0</span>
		, i  = <span class="number">0</span>
		, j = <span class="number">0</span>
		, l = <span class="number">0</span>
		, SKL = []
		, dim = Aders[<span class="number">0</span>][<span class="number">0</span>].length;

	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= num_derivs; k++) {
		SKL.push([]);

		<span class="keyword">for</span> (l = <span class="number">0</span>; l &lt;= num_derivs-k; l++) {

			<span class="keyword">var</span> v = Aders[k][l];
			<span class="keyword">for</span> (j=<span class="number">1</span>; j &lt;= l; j++) {
				v = numeric.sub( v, numeric.mul( numeric.mul( binomial.get(l, j), wders[<span class="number">0</span>][j] ), SKL[k][l-j] ) );
			}

			<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; i++) {
				v = numeric.sub( v, numeric.mul( numeric.mul( binomial.get(k, i), wders[i][<span class="number">0</span>] ), SKL[k-i][l] ) );
				
				<span class="keyword">var</span> v2 = verb.eval.nurbs.zeros_1d(dim);

				<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= l; j++) {
					v2 = numeric.add( v2, numeric.mul( numeric.mul( binomial.get(l, j), wders[i][j] ), SKL[k-i][l-j] ) );
				}

				v = numeric.sub( v, numeric.mul( binomial.get(k, i), v2) );

			}
			SKL[k].push( numeric.mul(<span class="number">1</span>/wders[<span class="number">0</span>][<span class="number">0</span>], v )); <span class="comment">// demogenize</span>

		}
	}

	<span class="keyword">return</span> SKL;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-195">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-195">&#182;</a>
              </div>
              <h4 id="rational_surface_point-degree_u-knots_u-degree_v-knots_v-homo_control_points-u-v-">rational_surface_point( degree_u, knots_u,  degree_v, knots_v, homo_control_points, u, v )</h4>
<p>Compute a point on a NURBS surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points (tensor), top to bottom is increasing u direction, left to right is increasing v direction,
and where each control point is an array of length (dim+1)</li>
<li><em>Number</em>, u parameter at which to evaluate the surface point</li>
<li><em>Number</em>, v parameter at which to evaluate the surface point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_surface_point = <span class="function"><span class="keyword">function</span><span class="params">( degree_u, knots_u,  degree_v, knots_v, homo_control_points, u, v )</span> {</span>

	<span class="keyword">return</span> verb.eval.nurbs.dehomogenize( verb.eval.nurbs.surface_point( degree_u, knots_u,  degree_v, knots_v, homo_control_points, u, v ) );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-196">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-196">&#182;</a>
              </div>
              <h4 id="rational_curve_derivs-degree-knots-homo_control_points-u-num_derivs-">rational_curve_derivs( degree, knots, homo_control_points, u, num_derivs )</h4>
<p>Determine the derivatives of a NURBS curve at a given parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi)</li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_curve_derivs = <span class="function"><span class="keyword">function</span><span class="params">( degree, knots, homo_control_points, u, num_derivs )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-197">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-197">&#182;</a>
              </div>
              <p>compute the derivatives of the control points
separate derivative array into two</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="keyword">var</span> ders = verb.eval.nurbs.separate_homo_derivs_1d( verb.eval.nurbs.curve_derivs( degree, knots, homo_control_points, u, num_derivs ) )
		, Aders = ders[<span class="number">0</span>]
		, wders = ders[<span class="number">1</span>]
		, k = <span class="number">0</span>
		, i  = <span class="number">0</span>
		, CK = [];

	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= num_derivs; k++) {
		<span class="keyword">var</span> v = Aders[k];

		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; i++) {
			v = numeric.sub( v, numeric.mul( numeric.mul( binomial.get(k, i), wders[i] ), CK[k-i] ) );
		}
		CK.push( numeric.mul(<span class="number">1</span>/wders[<span class="number">0</span>], v )); <span class="comment">// demogenize</span>
	}

	<span class="keyword">return</span> CK;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-198">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-198">&#182;</a>
              </div>
              <h4 id="separate_homo_derivs_1d-ck-">separate_homo_derivs_1d( ck )</h4>
<p>Separate the array of derivatives into the A(u) component and w(u), i.e. the weight and everything else without dehomogenization</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 1d array of homogeneous derivatives</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an array with Aders and wders as element 0 and 1, respectively</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.separate_homo_derivs_1d = <span class="function"><span class="keyword">function</span><span class="params">( CK )</span> {</span>

	<span class="keyword">var</span> dim = CK[<span class="number">0</span>].length
		, last = dim-<span class="number">1</span>
		, Aders = []
		, wders = [];

	<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = CK.length; i &lt; l; i++ ) {
		Aders.push( CK[i].slice(<span class="number">0</span>, last) );
		wders.push( CK[i][last] );
	}

	<span class="keyword">return</span> [Aders, wders];

};</pre></div></div>
            
        </li>
        
        
        <li id="section-199">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-199">&#182;</a>
              </div>
              <h4 id="separate_homo_derivs_2d-skl-">separate_homo_derivs_2d( skl )</h4>
<p>Separate the array of derivatives into the A(u) component and w(u), i.e. the weight and everything else without dehomogenization</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 2d array of homogeneous derivatives</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an array with Aders and wders as element 0 and 1, respectively</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.separate_homo_derivs_2d = <span class="function"><span class="keyword">function</span><span class="params">( SKL )</span> {</span>

	<span class="keyword">var</span> Aders = []
		, wders = [];

	<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = SKL.length; i &lt; l; i++ ) {
		<span class="keyword">var</span> CK = verb.eval.nurbs.separate_homo_derivs_1d( SKL[i] );
		Aders.push( CK[<span class="number">0</span>] );
		wders.push( CK[<span class="number">1</span>] );
	}

	<span class="keyword">return</span> [Aders, wders];

};</pre></div></div>
            
        </li>
        
        
        <li id="section-200">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-200">&#182;</a>
              </div>
              <h4 id="rational_curve_point-degree-knots-homo_control_points-u-">rational_curve_point( degree, knots, homo_control_points, u)</h4>
<p>Compute a point on a NURBS curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi)</li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_curve_point = <span class="function"><span class="keyword">function</span><span class="params">( degree, knots, homo_control_points, u)</span> {</span>

	<span class="keyword">return</span> verb.eval.nurbs.dehomogenize( verb.eval.nurbs.curve_point( degree, knots, homo_control_points, u) );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-201">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-201">&#182;</a>
              </div>
              <h4 id="dehomogenize-homo_point-">dehomogenize( homo_point )</h4>
<p>Dehomogenize a point </p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, a point represented by an array (wi*pi, wi) with length (dim+1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array pi with length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.dehomogenize = <span class="function"><span class="keyword">function</span><span class="params">( homo_point )</span> {</span>

	<span class="keyword">var</span> dim = homo_point.length
		, point = []
		, wt = homo_point[dim-<span class="number">1</span>];

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; homo_point.length-<span class="number">1</span>;i++)
		point.push( homo_point[i] / wt );

	<span class="keyword">return</span> point;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-202">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-202">&#182;</a>
              </div>
              <h4 id="homogenize_1d-control_points-weights-">homogenize_1d( control_points, weights)</h4>
<p>Transform a 1d array of points into their homogeneous equivalents</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 1d array of control points, (actually a 2d array of size (m x dim) )</li>
<li><em>Array</em>, array of control point weights, the same size as the array of control points (m x 1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 1d array of control points where each point is (wi*pi, wi) where wi 
i the ith control point weight and pi is the ith control point, 
hence the dimension of the point is dim + 1</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.homogenize_1d = <span class="function"><span class="keyword">function</span><span class="params">( control_points, weights)</span> {</span>

	<span class="keyword">var</span> rows = control_points.length
		, dim = control_points[<span class="number">0</span>].length
		, k = <span class="number">0</span>
		, homo_control_points = []
		, wt = <span class="number">0</span>
		, ref_pt = [];

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rows; i++) {

		<span class="keyword">var</span> pt = [];
		ref_pt = control_points[i];
		wt = weights[i];

		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; dim; k++) {
			pt.push( ref_pt[k] * wt );
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-203">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-203">&#182;</a>
              </div>
              <p>append the weight</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		pt.push(wt);

		homo_control_points.push(pt);
	}

	<span class="keyword">return</span> homo_control_points;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-204">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-204">&#182;</a>
              </div>
              <h4 id="homogenize_2d-control_points-weights-">homogenize_2d( control_points, weights)</h4>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 2d array of control points, (actually a 3d array of size m x n x dim)</li>
<li><em>Array</em>, array of control point weights, the same size as the control points array (m x n x 1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 1d array of control points where each point is (wi*pi, wi) where wi 
i the ith control point weight and pi is the ith control point, the size is 
(m x n x dim+1)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.homogenize_2d = <span class="function"><span class="keyword">function</span><span class="params">( control_points, weights)</span> {</span>

	<span class="keyword">var</span> rows = control_points.length
		, cols = control_points[<span class="number">0</span>].length
		, dim = control_points[<span class="number">0</span>][<span class="number">0</span>].length
		, j = <span class="number">0</span>
		, k = <span class="number">0</span>
		, homo_control_points = []
		, wt = <span class="number">0</span>
		, ref_pt = [];

	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rows; i++) {
		homo_control_points.push( verb.eval.nurbs.homogenize_1d(control_points[i], weights[i]) );
	}

	<span class="keyword">return</span> homo_control_points;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-205">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-205">&#182;</a>
              </div>
              <h4 id="surface_derivs-degree_u-knots_u-degree_v-knots_v-control_points-num_derivatives-u-v-">surface_derivs( degree_u, knots_u, degree_v, knots_v, control_points, num_derivatives, u, v )</h4>
<p>Compute the derivatives on a non-uniform, non-rational B spline surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the derivatives</li>
<li><em>Number</em>, v parameter at which to evaluate the derivatives</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.surface_derivs = <span class="function"><span class="keyword">function</span><span class="params">( degree_u, knots_u, degree_v, knots_v, control_points, num_derivatives, u, v )</span> {</span>

	<span class="keyword">var</span> n = knots_u.length - degree_u - <span class="number">2</span>
		, m = knots_v.length - degree_v - <span class="number">2</span>;

	<span class="keyword">return</span> verb.eval.nurbs.surface_derivs_given_n_m( n, degree_u, knots_u, m, degree_v, knots_v, control_points, num_derivatives, u, v );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-206">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-206">&#182;</a>
              </div>
              <h4 id="surface_derivs_given_n_m-n-degree_u-knots_u-m-degree_v-knots_v-control_points-num_derivatives-u-v-">surface_derivs_given_n_m( n, degree_u, knots_u, m, degree_v, knots_v, control_points, num_derivatives, u, v )</h4>
<p>Compute the derivatives on a non-uniform, non-rational B spline surface 
(corresponds to algorithm 3.6 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions in u dir - 1 = knots_u.length - degree_u - 2</li>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer number of basis functions in v dir - 1 = knots_u.length - degree_u - 2</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the derivatives</li>
<li><em>Number</em>, v parameter at which to evaluate the derivatives</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.surface_derivs_given_n_m = <span class="function"><span class="keyword">function</span><span class="params">( n, degree_u, knots_u, m, degree_v, knots_v, control_points, num_derivatives, u, v )</span> {</span>

	<span class="keyword">if</span> ( verb.eval.nurbs.are_valid_relations(degree_u, control_points.length, knots_u.length ) === <span class="literal">false</span> ||
		verb.eval.nurbs.are_valid_relations(degree_v, control_points[<span class="number">0</span>].length, knots_v.length ) === <span class="literal">false</span> ) {
		console.error(<span class="string">'Invalid relations between control points, knot vector, and n'</span>);
		<span class="keyword">return</span> <span class="literal">null</span>;
	}

	<span class="keyword">var</span> dim = control_points[<span class="number">0</span>][<span class="number">0</span>].length
		, du = Math.min(num_derivatives, degree_u)
		, dv = Math.min(num_derivatives, degree_v)
		, SKL = verb.eval.nurbs.zeros_3d( du+<span class="number">1</span>, dv+<span class="number">1</span>, dim )
		, knot_span_index_u = verb.eval.nurbs.knot_span_given_n( n, degree_u, u, knots_u )
		, knot_span_index_v = verb.eval.nurbs.knot_span_given_n( m, degree_v, v, knots_v )
		, uders = verb.eval.nurbs.deriv_basis_functions_given_n_i( knot_span_index_u, u, degree_u, n, knots_u )  
		, vders = verb.eval.nurbs.deriv_basis_functions_given_n_i( knot_span_index_v, v, degree_v, m, knots_v )
		, temp = verb.eval.nurbs.zeros_2d( degree_v+<span class="number">1</span>, dim )
		, k = <span class="number">0</span>
		, s = <span class="number">0</span>
		, r = <span class="number">0</span>
		, l = <span class="number">0</span>
		, dd = <span class="number">0</span>;

	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= du; k++) {	
		<span class="keyword">for</span> (s = <span class="number">0</span>; s &lt;= degree_v; s++) {		
			temp[s] = verb.eval.nurbs.zeros_1d( dim );

			<span class="keyword">for</span> (r = <span class="number">0</span>; r &lt;= degree_u; r++) {	
				temp[s] = numeric.add( temp[s], numeric.mul( uders[k][r], control_points[knot_span_index_u-degree_u+r][knot_span_index_v-degree_v+s]) );
			}
		}

		dd = Math.min(num_derivatives-k, dv);

		<span class="keyword">for</span> (l = <span class="number">0</span>; l &lt;= dd; l++) {	
			SKL[k][l] = verb.eval.nurbs.zeros_1d( dim );

			<span class="keyword">for</span> (s = <span class="number">0</span>; s &lt;= degree_v; s++) {	
				SKL[k][l] = numeric.add( SKL[k][l], numeric.mul( vders[l][s], temp[s] ) );
			}
		}
	}

	<span class="keyword">return</span> SKL;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-207">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-207">&#182;</a>
              </div>
              <h4 id="surface_point-degree_u-knots_u-degree_v-knots_v-control_points-u-v-">surface_point( degree_u, knots_u, degree_v, knots_v, control_points, u, v)</h4>
<p>Compute a point on a non-uniform, non-rational B-spline surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the surface point</li>
<li><em>Number</em>, v parameter at which to evaluate the surface point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.surface_point = <span class="function"><span class="keyword">function</span><span class="params">( degree_u, knots_u, degree_v, knots_v, control_points, u, v)</span> {</span>

	<span class="keyword">var</span> n = knots_u.length - degree_u - <span class="number">2</span>
		, m = knots_v.length - degree_v - <span class="number">2</span>;

	<span class="keyword">return</span> 	verb.eval.nurbs.surface_point_given_n_m( n, degree_u, knots_u, m, degree_v, knots_v, control_points, u, v );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-208">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-208">&#182;</a>
              </div>
              <h4 id="surface_point_given_n_m-n-degree_u-knots_u-m-degree_v-knots_v-control_points-u-v-">surface_point_given_n_m( n, degree_u, knots_u, m, degree_v, knots_v, control_points, u, v )</h4>
<p>Compute a point on a non-uniform, non-rational B spline surface
(corresponds to algorithm 3.5 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions in u dir - 1 = knots_u.length - degree_u - 2</li>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the surface point</li>
<li><em>Number</em>, v parameter at which to evaluate the surface point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.surface_point_given_n_m = <span class="function"><span class="keyword">function</span><span class="params">( n, degree_u, knots_u, m, degree_v, knots_v, control_points, u, v )</span> {</span>

	<span class="keyword">if</span> ( verb.eval.nurbs.are_valid_relations(degree_u, control_points.length, knots_u.length ) === <span class="literal">false</span> ||
		verb.eval.nurbs.are_valid_relations(degree_v, control_points[<span class="number">0</span>].length, knots_v.length ) === <span class="literal">false</span> ) {
		console.error(<span class="string">'Invalid relations between control points, knot vector, and n'</span>);
		<span class="keyword">return</span> <span class="literal">null</span>;
	}

	<span class="keyword">var</span> dim = control_points[<span class="number">0</span>][<span class="number">0</span>].length
		, knot_span_index_u = verb.eval.nurbs.knot_span_given_n( n, degree_u, u, knots_u )
		, knot_span_index_v = verb.eval.nurbs.knot_span_given_n( m, degree_v, v, knots_v )
		, u_basis_vals = verb.eval.nurbs.basis_functions_given_knot_span_index( knot_span_index_u, u, degree_u, knots_u )
		, v_basis_vals = verb.eval.nurbs.basis_functions_given_knot_span_index( knot_span_index_v, v, degree_v, knots_v )
		, uind = knot_span_index_u - degree_u
		, vind = knot_span_index_v
		, position = verb.eval.nurbs.zeros_1d( dim )
		, temp = verb.eval.nurbs.zeros_1d( dim )
		, l = <span class="number">0</span>
		, k = <span class="number">0</span>;

	<span class="keyword">for</span> (l = <span class="number">0</span>; l &lt;= degree_v; l++) {	

		temp = verb.eval.nurbs.zeros_1d( dim );
		vind = knot_span_index_v - degree_v + l;

		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= degree_u; k++) {	
			temp = numeric.add( temp, numeric.mul( u_basis_vals[k], control_points[uind+k][vind]) );
		}

		position = numeric.add( position, numeric.mul(v_basis_vals[l], temp) );
	}

	<span class="keyword">return</span> position;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-209">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-209">&#182;</a>
              </div>
              <h4 id="curve_derivs-degree-knots-control_points-u-num_derivs-">curve_derivs( degree, knots, control_points, u, num_derivs )</h4>
<p>Determine the derivatives of a non-uniform, non-rational B-spline curve at a given parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of control points, where each control point is an array of length (dim)  </li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.curve_derivs = <span class="function"><span class="keyword">function</span><span class="params">( degree, knots, control_points, u, num_derivs )</span> {</span>

	<span class="keyword">var</span> n = knots.length - degree - <span class="number">2</span>;
	<span class="keyword">return</span> verb.eval.nurbs.curve_derivs_given_n( n, degree, knots, control_points, u, num_derivs );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-210">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-210">&#182;</a>
              </div>
              <h4 id="curve_derivs_given_n-n-degree-knots-control_points-u-num_derivatives-">curve_derivs_given_n( n, degree, knots, control_points, u, num_derivatives )</h4>
<p>Determine the derivatives of a non-uniform, non-rational B-spline curve at a given parameter
(corresponds to algorithm 3.1 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions - 1 = knots.length - degree - 2</li>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of control points, where each control point is an array of length (dim)  </li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.curve_derivs_given_n = <span class="function"><span class="keyword">function</span><span class="params">( n, degree, knots, control_points, u, num_derivatives )</span> {</span>

	<span class="keyword">if</span> ( verb.eval.nurbs.are_valid_relations(degree, control_points.length, knots.length ) === <span class="literal">false</span> ) {
		console.error(<span class="string">'Invalid relations between control points, knot vector, and n'</span>);
		<span class="keyword">return</span> <span class="literal">null</span>;
	}

	<span class="keyword">var</span> dim = control_points[<span class="number">0</span>].length
		, du = Math.min(num_derivatives, degree)
		, CK = verb.eval.nurbs.zeros_2d( du+<span class="number">1</span>, dim )
		, knot_span_index = verb.eval.nurbs.knot_span_given_n( n, degree, u, knots )
		, nders = verb.eval.nurbs.deriv_basis_functions_given_n_i( knot_span_index, u, degree, du, knots )
		, k = <span class="number">0</span>
		, j = <span class="number">0</span>;

	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= du; k++) {	
		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= degree; j++) {
			CK[k] = numeric.add( CK[k], numeric.mul( nders[k][j], control_points[ knot_span_index - degree + j ] ) )
		}
	}
	<span class="keyword">return</span> CK;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-211">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-211">&#182;</a>
              </div>
              <h4 id="are_valid_relations-degree-num_control_points-knots_length-">are_valid_relations( degree, num_control_points, knots_length )</h4>
<p>Confirm the relations between degree (p), number of control points(n+1), and the number of knots (m+1)
via The NURBS Book (section 3.2, Second Edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Number</em>, integer number of control points</li>
<li><em>Number</em>, integer length of the knot vector (including duplicate knots)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Boolean</em>, whether the values are correct</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.are_valid_relations = <span class="function"><span class="keyword">function</span><span class="params">( degree, num_control_points, knots_length )</span> {</span>

	<span class="keyword">return</span> ( num_control_points + degree + <span class="number">1</span> - knots_length ) === <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-212">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-212">&#182;</a>
              </div>
              <h4 id="curve_point-degree-knots-control_points-u-">curve_point( degree, knots, control_points, u)</h4>
<p>Compute a point on a non-uniform, non-rational b-spline curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of control points, where each control point is an array of length (dim)  </li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.curve_point = <span class="function"><span class="keyword">function</span><span class="params">( degree, knots, control_points, u)</span> {</span>

	<span class="keyword">var</span> n = knots.length - degree - <span class="number">2</span>;
	<span class="keyword">return</span> verb.eval.nurbs.curve_point_given_n( n, degree, knots, control_points, u);

}</pre></div></div>
            
        </li>
        
        
        <li id="section-213">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-213">&#182;</a>
              </div>
              <h4 id="curve_point_given_n-n-degree-knots-control_points-u-">curve_point_given_n( n, degree, knots, control_points, u)</h4>
<p>Compute a point on a non-uniform, non-rational b-spline curve
(corresponds to algorithm 3.1 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions - 1 = knots.length - degree - 2</li>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of control points, where each control point is an array of length (dim)  </li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.curve_point_given_n = <span class="function"><span class="keyword">function</span><span class="params">( n, degree, knots, control_points, u)</span> {</span>

	<span class="keyword">if</span> ( verb.eval.nurbs.are_valid_relations(degree, control_points.length, knots.length ) === <span class="literal">false</span> ) {
		console.error(<span class="string">'Invalid relations between control points, knot vector, and n'</span>);
		<span class="keyword">return</span> <span class="literal">null</span>;
	}

	<span class="keyword">var</span> knot_span_index = verb.eval.nurbs.knot_span_given_n( n, degree, u, knots )
		, basis_values = verb.eval.nurbs.basis_functions_given_knot_span_index( knot_span_index, u, degree, knots ) 
		, position = verb.eval.nurbs.zeros_1d( control_points[<span class="number">0</span>].length );

		<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt;= degree; j++ )	{
			position = numeric.add( position, numeric.mul( basis_values[j], control_points[ knot_span_index - degree + j ] ) );
		}

		<span class="keyword">return</span> position;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-214">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-214">&#182;</a>
              </div>
              <h4 id="zeros_1d-size-">zeros_1d(size)</h4>
<p>Generate a 1d array of zeros</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of rows</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 1d array of given size</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.zeros_1d = <span class="function"><span class="keyword">function</span><span class="params">(size)</span> {</span>
  size = size &gt; <span class="number">0</span> ? size : <span class="number">0</span>;

  <span class="keyword">var</span> arr = [];

  <span class="keyword">while</span>(size--) {
    arr.push(<span class="number">0</span>);
  }

  <span class="keyword">return</span> arr;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-215">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-215">&#182;</a>
              </div>
              <h4 id="zeros_2d-rows-cols-">zeros_2d(rows, cols)</h4>
<p>Generate a 2D array of zeros</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of rows</li>
<li><em>Number</em>, integer number of columns</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 2d array of given size</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.zeros_2d = <span class="function"><span class="keyword">function</span><span class="params">(rows, cols)</span> {</span>
  cols = cols &gt; <span class="number">0</span> ? cols : <span class="number">0</span>;
  rows = rows &gt; <span class="number">0</span> ? rows : <span class="number">0</span>;

  <span class="keyword">var</span> arr = [];
  <span class="keyword">var</span> cols_temp = cols;
  <span class="keyword">var</span> rows_temp = rows;

  <span class="keyword">while</span>(rows--) {
    arr.push([]);

    <span class="keyword">while</span>(cols_temp--) {
      arr[rows_temp-rows-<span class="number">1</span>].push(<span class="number">0</span>);
    }
    cols_temp = cols;
  }

  <span class="keyword">return</span> arr;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-216">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-216">&#182;</a>
              </div>
              <h4 id="zeros_3d-rows-cols-dim-">zeros_3d(rows, cols, dim)</h4>
<p>Generate a 3D array of zeros</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of rows</li>
<li><em>Number</em>, integer number of columns</li>
<li><em>Number</em>, integer depth (i.e. dimension of arrays in 2d matrix)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 3d array of given size</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.zeros_3d = <span class="function"><span class="keyword">function</span><span class="params">(rows, cols, dim)</span> {</span>
  cols = cols &gt; <span class="number">0</span> ? cols : <span class="number">0</span>;
  rows = rows &gt; <span class="number">0</span> ? rows : <span class="number">0</span>;

  <span class="keyword">var</span> arr = [];
  <span class="keyword">var</span> cols_temp = cols;
  <span class="keyword">var</span> rows_temp = rows;

  <span class="keyword">while</span>(rows--) {
    arr.push([]);

    <span class="keyword">while</span>(cols_temp--) {
      arr[rows_temp-rows-<span class="number">1</span>].push( verb.eval.nurbs.zeros_1d(dim) );
    }
    cols_temp = cols;
  }

  <span class="keyword">return</span> arr;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-217">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-217">&#182;</a>
              </div>
              <h4 id="deriv_basis_functions-u-degree-knots-">deriv_basis_functions( u, degree, knots )</h4>
<p>Compute the non-vanishing basis functions and their derivatives</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, float parameter</li>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 2d array of basis and derivative values of size (n+1, p+1) The nth row is the nth derivative and the first row is made up of the basis function values.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.deriv_basis_functions = <span class="function"><span class="keyword">function</span><span class="params">( u, degree, knots )</span>
{</span>
	<span class="keyword">var</span> knot_span_index = verb.eval.nurbs.knot_span( degree, u, knots )
		, m = knots.length - <span class="number">1</span>
		, n = m - degree - <span class="number">1</span>;

	<span class="keyword">return</span> verb.eval.nurbs.deriv_basis_functions_given_n_i( knot_span_index, u, degree, n, knots );
}</pre></div></div>
            
        </li>
        
        
        <li id="section-218">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-218">&#182;</a>
              </div>
              <h4 id="deriv_basis_functions_given_n_i-knot_span_index-u-p-n-knots-">deriv_basis_functions_given_n_i( knot_span_index, u, p, n, knots )</h4>
<p>Compute the non-vanishing basis functions and their derivatives
(corresponds to algorithm 2.3 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer knot span index</li>
<li><em>Number</em>, float parameter</li>
<li><em>Number</em>, integer degree</li>
<li><em>Number</em>, integer number of basis functions - 1 = knots.length - degree - 2</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 2d array of basis and derivative values of size (n+1, p+1) The nth row is the nth derivative and the first row is made up of the basis function values.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.deriv_basis_functions_given_n_i = <span class="function"><span class="keyword">function</span><span class="params">( knot_span_index, u, p, n, knots )</span>
{</span>
	<span class="keyword">var</span> ndu = verb.eval.nurbs.zeros_2d(p+<span class="number">1</span>, p+<span class="number">1</span>)
		, left = <span class="keyword">new</span> Array( p + <span class="number">1</span> )
		, right = <span class="keyword">new</span> Array( p + <span class="number">1</span> )
		, saved = <span class="number">0</span>
		, temp = <span class="number">0</span>
		, j = <span class="number">1</span>
		, r = <span class="number">0</span>;

	ndu[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0</span>;

	<span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= p; j++) {

		left[j] = u - knots[knot_span_index+<span class="number">1</span>-j];
		right[j] = knots[knot_span_index+j] - u;
		saved = <span class="number">0.0</span>;

		<span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; j; r++) {

			ndu[j][r] = right[r+<span class="number">1</span>] + left[j-r];
			temp = ndu[r][j-<span class="number">1</span>] / ndu[j][r];

			ndu[r][j] = saved + right[r+<span class="number">1</span>]*temp;
			saved = left[j-r]*temp;

		}
		ndu[j][j] = saved;
	}


	<span class="keyword">var</span> ders = verb.eval.nurbs.zeros_2d(n+<span class="number">1</span>, p+<span class="number">1</span>)
		, a = verb.eval.nurbs.zeros_2d(<span class="number">2</span>, p+<span class="number">1</span>)
		, k = <span class="number">1</span>
		, s1 = <span class="number">0</span>
		, s2 = <span class="number">1</span>
		, d = <span class="number">0</span>
		, rk = <span class="number">0</span>
		, pk = <span class="number">0</span>
		, j1 = <span class="number">0</span>
		, j2 = <span class="number">0</span>;

	<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt;= p; j++) {
		ders[<span class="number">0</span>][j] = ndu[j][p];
	}

	<span class="keyword">for</span> (r = <span class="number">0</span>; r&lt;=p; r++) {
		s1 = <span class="number">0</span>;
		s2 = <span class="number">1</span>;
		a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0</span>;

		<span class="keyword">for</span> (k=<span class="number">1</span>; k&lt;=n ;k++)
		{
			d = <span class="number">0.0</span>;
			rk = r - k;
			pk = p - k;

			<span class="keyword">if</span> (r &gt;= k) {
				a[s2][<span class="number">0</span>] = a[s1][<span class="number">0</span>] / ndu[pk+<span class="number">1</span>][rk];
				d = a[s2][<span class="number">0</span>]*ndu[rk][pk];
			}

			<span class="keyword">if</span> (rk &gt;= -<span class="number">1</span>) {
				j1 = <span class="number">1</span>;
			} <span class="keyword">else</span> {
				j1 = -rk;
			}

			<span class="keyword">if</span> (r-<span class="number">1</span> &lt;= pk) {
				j2 = k-<span class="number">1</span>;
			} <span class="keyword">else</span> {
				j2 = p - r;
			}

			<span class="keyword">for</span> (j = j1; j &lt;= j2; j++) {
				a[s2][j] = ( a[s1][j] - a[s1][ j - <span class="number">1</span> ] ) / ndu[ pk + <span class="number">1</span> ][ rk + j ];
				d += a[s2][j]*ndu[rk+j][pk];
			}

			<span class="keyword">if</span> (r &lt;= pk)
			{
				a[s2][k] = -a[s1][k-<span class="number">1</span>]/ndu[pk+<span class="number">1</span>][r];
				d += a[s2][k] * ndu[r][pk];
			}

			ders[k][r] = d;
			j = s1;
			s1 = s2;
			s2 = j;
		}
	}

	r = p;
	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++) {
		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= p; j++) {
			ders[k][j] *= r;
		}
		r *= (p-k);
	}

	<span class="keyword">return</span> ders;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-219">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-219">&#182;</a>
              </div>
              <h4 id="basis_functions-u-degree-knots-">basis_functions( u, degree, knots )</h4>
<p>Compute the non-vanishing basis functions</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, float parameter</li>
<li><em>Number</em>, integer degree of function</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, list of non-vanishing basis functions</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.basis_functions = <span class="function"><span class="keyword">function</span><span class="params">( u, degree, knots )</span>
{</span>
	<span class="keyword">var</span> knot_span_index = verb.eval.nurbs.knot_span(u, degree, knots);
	<span class="keyword">return</span> verb.eval.nurbs.basis_functions_given_knot_span_index( knot_span_index, u, degree, knots );
};</pre></div></div>
            
        </li>
        
        
        <li id="section-220">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-220">&#182;</a>
              </div>
              <h4 id="basis_functions_given_knot_span_index-knot_span_index-u-degree-knots-">basis_functions_given_knot_span_index( knot_span_index, u, degree, knots )</h4>
<p>Compute the non-vanishing basis functions
(corresponds to algorithm 2.2 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer knot span index</li>
<li><em>Number</em>, float parameter</li>
<li><em>Number</em>, integer degree of function</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, list of non-vanishing basis functions</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.basis_functions_given_knot_span_index = <span class="function"><span class="keyword">function</span><span class="params">( knot_span_index, u, degree, knots )</span>
{</span>
	<span class="keyword">var</span> basis_functions = <span class="keyword">new</span> Array( degree + <span class="number">1</span> )
		, left = <span class="keyword">new</span> Array( degree + <span class="number">1</span> )
		, right = <span class="keyword">new</span> Array( degree + <span class="number">1</span> )
		, saved = <span class="number">0</span>
		, temp = <span class="number">0</span>;

	basis_functions[<span class="number">0</span>] = <span class="number">1.0</span>;

	<span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= degree; j++) {

		left[j] = u - knots[knot_span_index+<span class="number">1</span>-j];
		right[j] = knots[knot_span_index+j] - u;
		saved = <span class="number">0.0</span>;

		<span class="keyword">for</span> (<span class="keyword">var</span> r = <span class="number">0</span>; r &lt; j; r++) {

			temp = basis_functions[r] / ( right[r+<span class="number">1</span>] + left[j-r] );
			basis_functions[r] = saved + right[r+<span class="number">1</span>]*temp;
			saved = left[j-r]*temp;

		}

		basis_functions[j] = saved;
	}

	<span class="keyword">return</span> basis_functions;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-221">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-221">&#182;</a>
              </div>
              <h4 id="knot_span-degree-u-knots-">knot_span( degree, u, knots )</h4>
<p>Find the span on the knot vector without supplying n</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of function</li>
<li><em>Number</em>, float parameter</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, the index of the knot span</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.knot_span = <span class="function"><span class="keyword">function</span><span class="params">( degree, u, knots )</span>
{</span>

	<span class="keyword">var</span> m = knots.length - <span class="number">1</span>
		, n = m - degree - <span class="number">1</span>;

	<span class="keyword">return</span> verb.eval.nurbs.knot_span_given_n(n, degree, u, knots);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-222">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-222">&#182;</a>
              </div>
              <h4 id="knot_span_given_n-n-degree-u-knots-">knot_span_given_n( n, degree, u, knots )</h4>
<p>Find the span on the knot vector knots of the given parameter
(corresponds to algorithm 2.1 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions - 1 = knots.length - degree - 2</li>
<li><em>Number</em>, integer degree of function</li>
<li><em>Number</em>, float parameter</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, the index of the knot span</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.knot_span_given_n = <span class="function"><span class="keyword">function</span><span class="params">( n, degree, u, knots )</span>
{</span>
	<span class="keyword">if</span> ( u &gt;= knots[n+<span class="number">1</span>] )
	{
		<span class="keyword">return</span> n;
	}

	<span class="keyword">if</span> ( u &lt; knots[degree] )
	{
		<span class="keyword">return</span> degree;
	}

	<span class="keyword">var</span> low = degree
		, high = n+<span class="number">1</span>
		, mid = Math.floor( (low + high) / <span class="number">2</span> );

	<span class="keyword">while</span>( u &lt; knots[ mid ] || u &gt;= knots[ mid + <span class="number">1</span> ] )
	{
		<span class="keyword">if</span> ( u &lt; knots[ mid ] )
		{
			high = mid;
		}
		<span class="keyword">else</span> 
		{
			low = mid;
		}
		mid = Math.floor( (low + high) / <span class="number">2</span> );
	}

	<span class="keyword">return</span> mid;

};</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
